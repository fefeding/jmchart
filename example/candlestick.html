<!doctype html>
<html>
	<head>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type" />
        <meta name="viewport" content="width=device-width,initial-scale=1">
		<!--<script type="text/javascript" src="../src/jmchart.debug.js" id="jmgraph" ></script>-->
        <script src="js/vconsole.js"></script>
        
		<style>
		html,body {
			margin:0;
			padding:0;
			width:100%;
			height:100%;
		}
		</style>
		<script type="module">
			import jmChart from '../dist/jmchart.esm.js';
			(function load() {
				var w = window.innerWidth || window.document.body.clientWidth;
				var h = Math.min((window.innerHeight || window.document.body.clientHeight) * 0.5, 500);	

                var vConsole = new window.VConsole();

				inichart(w,h);
			})();
			

			function inichart(w, h) {

					const chart = new jmChart('mycanvas', {
						width: w,
						height: h,
                        xField: 'day',
                        enableAnimate: false,
                        legendPosition: 'top',
                        legendVisible: false, // 不显示图例
						// 最大和最小X值，  这里一般不用指定，除非硬是需要
						minXValue : 0,
						maxXValue : 10,
                        touchGraph: true, // 是否依赖生成操作图层，当点比较多时，性能低下可以把它设为true
						//autoRefresh: true,
						//minYValue: -100,
						//maxYValue: 15,
                        // 格式化x标签值
                        xLabelFormat: (v, item, index) => {
                            // 只展示第一个和最后一个
                            //if(index % 5 === 0) {
                            //    return v;
                            //}  
                            //return '';
                        },
                        style: {
                            layout: 'inside',	// inside 二边不对齐Y轴，内缩一个刻度 | normal
							// 跟随标线
							markLine: {
								x: false, // 显示X标线
								y: true, // 显示Y标线
								stroke: 'red',
								fill: '#fff',
								lineWidth: 1,
                                longtap: true // 长按启用
							},
                            // x轴 Y轴隐藏
                            axis: {
								stroke: 'transparent',
								align: 'center', // label居中对齐
                                grid: {
                                    x: false,  // 不显示X轴网格
                                    y: false     // 显示Y轴网格
                                }
                            },
                            // 隐藏边框
                            chartArea: {
                                //stroke: 'transparent'
                            },
                            margin: {
                                top: 30,
                                left: 50,
                                right: 10,
                                bottom: 30
                            }
                        }
					});	
                    // touch改变数据点事件
					chart.on('touchPointChange', function(args) {
						console.log(args);
                        document.getElementById('mydatalog').innerHTML = JSON.stringify(args.points[0].data);
					});		
                    

					const line = chart.createSeries('candlestick', {
                        // 如果字段名跟下面的一至，可以不指定
						fields: [
							'start',  // 开盘
                            'end',      // 收盘
                            'max',     // 最大值
                            'min'      // 最小值
						],
                        style: {
                            // 阴线颜色
                            negativeColor: 'green',
                            // 阳线颜色
                            masculineColor: 'red',
                            lineWidth: 2,
                            //barWidth: 15
                        }
					});

                    
                    const data = createData(); // 生成测试数据

                    
                    let dataCount = 20; // 展示数据个数
                    let dataIndex = data.length - dataCount; // 展示数据起始索引

					function refresh() {
                        chart.data = data.filter((d, i) => {
                            if(i >= dataIndex && i < dataCount + dataIndex) return true;   
                            return false;                         
                        });                        
						chart.refresh();
					}
					
					refresh(0, 20);

                    // 根据滑动来绘制数据
                    let dataTouchPosition = {
                        x: 0,
                        touching: false, // 是否在滑动中
                        scaleTouching : false,
                        touche1X: 0,
                        touche1Y: 0,
                        touche2X: 0,
                        touche2Y: 0
                    };
                    chart.on('touchstart', (args) => {
                        // 双指滑动， 缩放
                        if(args.event.touches.length === 2) {
                            dataTouchPosition.scaleTouching = true;
                            dataTouchPosition.touche1X = args.event.touches[0].pageX;
                            dataTouchPosition.touche2X = args.event.touches[1].pageX;
                            dataTouchPosition.touche1Y = args.event.touches[0].pageY;
                            dataTouchPosition.touche2Y = args.event.touches[1].pageY;
                        }
                        else {
                            dataTouchPosition.touching = true;
                        }
                        dataTouchPosition.x = args.position.x;
                    });	

                    // 长按了
                    chart.on('longtapstart', (args) => {
                        dataTouchPosition.touching = false;// 长按取消数据滑动
                        
                        document.getElementById('mylog').innerHTML = 'longtapstart:';
                        console.log('longtapstart', args);
                    });
                    chart.on('touchmove', (args) => {
                        if(!args.target || !args.target.chartGraph) return;
                        console.log('touchmove', args);

                        // 双指缩放
                        if(dataTouchPosition.scaleTouching && args.event.touches.length === 2) {
                            const ox = dataTouchPosition.touche1X - args.event.touches[0].pageX + args.event.touches[1].pageX - dataTouchPosition.touche2X;
                            const oy = dataTouchPosition.touche1Y - args.event.touches[0].pageY + args.event.touches[1].pageY - dataTouchPosition.touche2Y;
                            // 数据偏移量 
                            const offDataCount = Math.round(Math.sqrt(ox * ox + oy * oy) / args.target.bounds.width * dataCount);

                            if(Math.abs(offDataCount) > 0) {
                                let index = Math.max(dataIndex + offDataCount, 0);
                                dataCount += offDataCount * 2;
                                // 展示数据个数不能越过数组上限
                                if(dataCount > data.length) dataCount = data.length;
                                if(dataCount > data.length - index) dataCount = data.length - index;

                                refresh();// 刷新数据

                                dataTouchPosition.touche1X = args.event.touches[0].pageX;
                                dataTouchPosition.touche2X = args.event.touches[1].pageX;

                                document.getElementById('mylog').innerHTML = 'scaleTouching:' + offDataCount;
                            }
                        }
                        // 在滑动标线，则不处理
                        //else if(args.target.chartGraph.yMarkLine && args.target.chartGraph.yMarkLine.visible) {
                        //    dataTouchPosition.touching = false;
                        //}
                        else if(dataTouchPosition.touching) {
                            const ox = dataTouchPosition.x - args.position.x;
                            // 数据偏移量
                            const offDataCount = Math.round(ox / args.target.bounds.width * dataCount);
                            if(Math.abs(offDataCount) > 0) {
                                let index = dataIndex + offDataCount;
                                if(index < 0) index = 0
                                else if(index > data.length - dataCount) index = data.length - dataCount;

                                // 刷新数据
                                dataIndex = index;
                                refresh();

                                dataTouchPosition.x = args.position.x;
                            }
                        }
                    });	
                    chart.on('touchend touchcancel touchleave', (args) => {
                        dataTouchPosition.touching = false;
                        dataTouchPosition.scaleTouching = false;
                        console.log('touchend');
                    });
				}

                function createData() {
                    const data = [];
                    const startDate = new Date('2021/01/01 00:00:00');
                    for(var i = 0;i<365;i++) {
                        startDate.setDate(startDate.getDate() + 1);
                        const d = {
                            day : startDate.getFullYear() + '-' + ('00'+(startDate.getMonth()+1)).substr(-2) + '-' + ('00'+startDate.getDate()).substr(-2),
                            start :  Math.random() * 5 + 15,
                            end:  Math.random() * 5 + 15
                        };
                        d.max = Math.max(d.start, d.end) + Math.random() * 5;
                        d.min = Math.min(d.start, d.end) - Math.random() * 5;
                        data.push(d);
                    }
                    return data;
                }
		</script>
	</head>
	<body>
		<div id="mycanvas">
			</div>	
        <hr />
        <div id="mydatalog" style="word-wrap:break-word">
			</div>		
        <hr />
        <div id="mylog" style="word-wrap:break-word">
			</div>	
	</body>
</html>