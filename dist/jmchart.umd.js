(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jmchart = {}));
}(this, (function (exports) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var interopRequireDefault = createCommonjsModule(function (module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(interopRequireDefault);

  var mesh=createCommonjsModule(function(module,exports){(function webpackUniversalModuleDefinition(root,factory){module.exports=factory();})(commonjsGlobal,function(){return(/******/function(modules){// webpackBootstrap
  /******/ // The module cache
  /******/var installedModules={};/******/ /******/ // The require function
  /******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
  /******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
  /******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
  /******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
  /******/module.l=true;/******/ /******/ // Return the exports of the module
  /******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
  /******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
  /******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
  /******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{enumerable:true,get:getter});/******/}/******/};/******/ /******/ // define __esModule on exports
  /******/__webpack_require__.r=function(exports){/******/if(typeof Symbol!=='undefined'&&Symbol.toStringTag){/******/Object.defineProperty(exports,Symbol.toStringTag,{value:'Module'});/******/}/******/Object.defineProperty(exports,'__esModule',{value:true});/******/};/******/ /******/ // create a fake namespace object
  /******/ // mode & 1: value is a module id, require it
  /******/ // mode & 2: merge all properties of value into the ns
  /******/ // mode & 4: return value when already ns object
  /******/ // mode & 8|1: behave like require
  /******/__webpack_require__.t=function(value,mode){/******/if(mode&1)value=__webpack_require__(value);/******/if(mode&8)return value;/******/if(mode&4&&typeof value==='object'&&value&&value.__esModule)return value;/******/var ns=Object.create(null);/******/__webpack_require__.r(ns);/******/Object.defineProperty(ns,'default',{enumerable:true,value:value});/******/if(mode&2&&typeof value!='string')for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key];}.bind(null,key));/******/return ns;/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
  /******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
  /******/__webpack_require__.p="/js/";/******/ /******/ /******/ // Load entry module and return exports
  /******/return __webpack_require__(__webpack_require__.s=0);/******/}([/* 0 */ /***/ /* 1 */ /***/ /* 2 */ /***/ /* 3 */ /***/ /* 4 */ /***/ /* 5 */ /***/ /* 6 */ /***/ /* 7 */ /***/ /* 8 */ /***/ /* 9 */ /***/ /* 10 */ /***/ /* 11 */ /***/ /* 12 */ /***/ /* 13 */ /***/ /* 14 */ /***/ /* 15 */ /***/ /* 16 */ /***/ /* 17 */ /***/ /* 18 */ /***/ /* 19 */ /***/ /* 20 */ /***/ /* 21 */ /***/ /* 22 */ /***/ /* 23 */ /***/ /* 24 */ /***/ /* 25 */ /***/ /* 26 */ /***/ /* 27 */ /***/ /* 28 */ /***/ /* 29 */ /***/ /* 30 */ /***/ /* 31 */ /***/ /* 32 */ /***/ /* 33 */ /***/ /* 34 */ /***/ /* 35 */ /***/ /* 36 */ /***/ /* 37 */ /***/ /* 38 */ /***/ /* 39 */ /***/ /* 40 */ /***/ /* 41 */ /***/ /* 42 */ /***/ /* 43 */ /***/ /* 44 */ /***/ /* 45 */ /***/ /* 46 */ /***/ /* 47 */ /***/ /* 48 */ /***/ /* 49 */ /***/ /* 50 */ /***/ /* 51 */ /***/ /* 52 */ /***/ /* 53 */ /***/ /* 54 */ /***/ /* 55 */ /***/ /* 56 */ /***/ /* 57 */ /***/ /* 58 */ /***/ /* 59 */ /***/ /* 60 */ /***/ /* 61 */ /***/ /* 62 */ /***/ /* 63 */ /***/ /* 64 */ /***/ /* 65 */ /***/ /* 66 */ /***/ /* 67 */ /***/ /* 68 */ /***/ /* 69 */ /***/ /* 70 */ /***/ /* 71 */ /***/ /* 72 */ /***/ /* 73 */ /***/ /* 74 */ /***/ /* 75 */ /***/ /* 76 */ /***/ /* 77 */ /***/ /* 78 */ /***/ /* 79 */ /***/ /* 80 */ /***/ /* 81 */ /***/ /* 82 */ /***/ /* 83 */ /***/ /* 84 */ /***/ /* 85 */ /***/ /* 86 */ /***/ /******/function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony import */var _renderer__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(12);/* harmony reexport (safe) */__webpack_require__.d(__webpack_exports__,"Renderer",function(){return _renderer__WEBPACK_IMPORTED_MODULE_0__["default"];});/* harmony import */var _figure2d__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(56);/* harmony reexport (safe) */__webpack_require__.d(__webpack_exports__,"Figure2D",function(){return _figure2d__WEBPACK_IMPORTED_MODULE_1__["default"];});/* harmony import */var _mesh2d__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(73);/* harmony reexport (safe) */__webpack_require__.d(__webpack_exports__,"Mesh2D",function(){return _mesh2d__WEBPACK_IMPORTED_MODULE_2__["default"];});/* harmony import */var _mesh_cloud__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(45);/* harmony reexport (safe) */__webpack_require__.d(__webpack_exports__,"MeshCloud",function(){return _mesh_cloud__WEBPACK_IMPORTED_MODULE_3__["default"];});/* harmony import */var _utils_parse_font__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(39);/* harmony reexport (safe) */__webpack_require__.d(__webpack_exports__,"parseFont",function(){return _utils_parse_font__WEBPACK_IMPORTED_MODULE_4__["default"];});/* harmony import */var _utils_parse_color__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(47);/* harmony reexport (safe) */__webpack_require__.d(__webpack_exports__,"parseColor",function(){return _utils_parse_color__WEBPACK_IMPORTED_MODULE_5__["default"];});/* harmony import */var _utils_env__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(37);/* harmony reexport (safe) */__webpack_require__.d(__webpack_exports__,"ENV",function(){return _utils_env__WEBPACK_IMPORTED_MODULE_6__["default"];});__webpack_require__(1).glMatrix.setMatrixArrayType(Array);/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"glMatrix",function(){return _common_js__WEBPACK_IMPORTED_MODULE_0__;});/* harmony import */var _mat2_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(3);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"mat2",function(){return _mat2_js__WEBPACK_IMPORTED_MODULE_1__;});/* harmony import */var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(4);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"mat2d",function(){return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__;});/* harmony import */var _mat3_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(5);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"mat3",function(){return _mat3_js__WEBPACK_IMPORTED_MODULE_3__;});/* harmony import */var _mat4_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(6);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"mat4",function(){return _mat4_js__WEBPACK_IMPORTED_MODULE_4__;});/* harmony import */var _quat_js__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(7);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"quat",function(){return _quat_js__WEBPACK_IMPORTED_MODULE_5__;});/* harmony import */var _quat2_js__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(10);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"quat2",function(){return _quat2_js__WEBPACK_IMPORTED_MODULE_6__;});/* harmony import */var _vec2_js__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(11);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"vec2",function(){return _vec2_js__WEBPACK_IMPORTED_MODULE_7__;});/* harmony import */var _vec3_js__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(8);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"vec3",function(){return _vec3_js__WEBPACK_IMPORTED_MODULE_8__;});/* harmony import */var _vec4_js__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(9);/* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__,"vec4",function(){return _vec4_js__WEBPACK_IMPORTED_MODULE_9__;});/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"EPSILON",function(){return EPSILON;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"ARRAY_TYPE",function(){return ARRAY_TYPE;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"RANDOM",function(){return RANDOM;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"setMatrixArrayType",function(){return setMatrixArrayType;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"toRadian",function(){return toRadian;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/**
   * Common utilities
   * @module glMatrix
   */ // Configuration Constants
  var EPSILON=0.000001;var ARRAY_TYPE=typeof Float32Array!=='undefined'?Float32Array:Array;var RANDOM=Math.random;/**
   * Sets the type of array used when creating new vectors and matrices
   *
   * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
   */function setMatrixArrayType(type){ARRAY_TYPE=type;}var degree=Math.PI/180;/**
   * Convert Degree To Radian
   *
   * @param {Number} a Angle in Degrees
   */function toRadian(a){return a*degree;}/**
   * Tests whether or not the arguments have approximately the same value, within an absolute
   * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
   * than or equal to 1.0, and a relative tolerance is used for larger values)
   *
   * @param {Number} a The first number to test.
   * @param {Number} b The second number to test.
   * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
   */function equals(a,b){return Math.abs(a-b)<=EPSILON*Math.max(1.0,Math.abs(a),Math.abs(b));}if(!Math.hypot)Math.hypot=function(){var y=0,i=arguments.length;while(i--){y+=arguments[i]*arguments[i];}return Math.sqrt(y);};/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"identity",function(){return identity;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transpose",function(){return transpose;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"invert",function(){return invert;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"adjoint",function(){return adjoint;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"determinant",function(){return determinant;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotate",function(){return rotate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotation",function(){return fromRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromScaling",function(){return fromScaling;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"frob",function(){return frob;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"LDU",function(){return LDU;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"subtract",function(){return subtract;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalar",function(){return multiplyScalar;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalarAndAdd",function(){return multiplyScalarAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/**
   * 2x2 Matrix
   * @module mat2
   */ /**
   * Creates a new identity mat2
   *
   * @returns {mat2} a new 2x2 matrix
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[1]=0;out[2]=0;}out[0]=1;out[3]=1;return out;}/**
   * Creates a new mat2 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat2} a matrix to clone
   * @returns {mat2} a new 2x2 matrix
   */function clone(a){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];return out;}/**
   * Copy the values from one mat2 to another
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];return out;}/**
   * Set a mat2 to the identity matrix
   *
   * @param {mat2} out the receiving matrix
   * @returns {mat2} out
   */function identity(out){out[0]=1;out[1]=0;out[2]=0;out[3]=1;return out;}/**
   * Create a new mat2 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out A new 2x2 matrix
   */function fromValues(m00,m01,m10,m11){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);out[0]=m00;out[1]=m01;out[2]=m10;out[3]=m11;return out;}/**
   * Set the components of a mat2 to the given values
   *
   * @param {mat2} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out
   */function set(out,m00,m01,m10,m11){out[0]=m00;out[1]=m01;out[2]=m10;out[3]=m11;return out;}/**
   * Transpose the values of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */function transpose(out,a){// If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if(out===a){var a1=a[1];out[1]=a[2];out[2]=a1;}else {out[0]=a[0];out[1]=a[2];out[2]=a[1];out[3]=a[3];}return out;}/**
   * Inverts a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */function invert(out,a){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];// Calculate the determinant
  var det=a0*a3-a2*a1;if(!det){return null;}det=1.0/det;out[0]=a3*det;out[1]=-a1*det;out[2]=-a2*det;out[3]=a0*det;return out;}/**
   * Calculates the adjugate of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */function adjoint(out,a){// Caching this value is nessecary if out == a
  var a0=a[0];out[0]=a[3];out[1]=-a[1];out[2]=-a[2];out[3]=a0;return out;}/**
   * Calculates the determinant of a mat2
   *
   * @param {ReadonlyMat2} a the source matrix
   * @returns {Number} determinant of a
   */function determinant(a){return a[0]*a[3]-a[2]*a[1];}/**
   * Multiplies two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @returns {mat2} out
   */function multiply(out,a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];var b0=b[0],b1=b[1],b2=b[2],b3=b[3];out[0]=a0*b0+a2*b1;out[1]=a1*b0+a3*b1;out[2]=a0*b2+a2*b3;out[3]=a1*b2+a3*b3;return out;}/**
   * Rotates a mat2 by the given angle
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */function rotate(out,a,rad){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];var s=Math.sin(rad);var c=Math.cos(rad);out[0]=a0*c+a2*s;out[1]=a1*c+a3*s;out[2]=a0*-s+a2*c;out[3]=a1*-s+a3*c;return out;}/**
   * Scales the mat2 by the dimensions in the given vec2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the matrix to rotate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat2} out
   **/function scale(out,a,v){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];var v0=v[0],v1=v[1];out[0]=a0*v0;out[1]=a1*v0;out[2]=a2*v1;out[3]=a3*v1;return out;}/**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */function fromRotation(out,rad){var s=Math.sin(rad);var c=Math.cos(rad);out[0]=c;out[1]=s;out[2]=-s;out[3]=c;return out;}/**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat2} out
   */function fromScaling(out,v){out[0]=v[0];out[1]=0;out[2]=0;out[3]=v[1];return out;}/**
   * Returns a string representation of a mat2
   *
   * @param {ReadonlyMat2} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */function str(a){return "mat2("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")";}/**
   * Returns Frobenius norm of a mat2
   *
   * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */function frob(a){return Math.hypot(a[0],a[1],a[2],a[3]);}/**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @param {ReadonlyMat2} L the lower triangular matrix
   * @param {ReadonlyMat2} D the diagonal matrix
   * @param {ReadonlyMat2} U the upper triangular matrix
   * @param {ReadonlyMat2} a the input matrix to factorize
   */function LDU(L,D,U,a){L[2]=a[2]/a[0];U[0]=a[0];U[1]=a[1];U[3]=a[3]-L[2]*U[1];return [L,D,U];}/**
   * Adds two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @returns {mat2} out
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];out[3]=a[3]+b[3];return out;}/**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @returns {mat2} out
   */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];out[3]=a[3]-b[3];return out;}/**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat2} a The first matrix.
   * @param {ReadonlyMat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3];}/**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat2} a The first matrix.
   * @param {ReadonlyMat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];var b0=b[0],b1=b[1],b2=b[2],b3=b[3];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a3),Math.abs(b3));}/**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2} out
   */function multiplyScalar(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;out[3]=a[3]*b;return out;}/**
   * Adds two mat2's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2} out the receiving vector
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2} out
   */function multiplyScalarAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;out[3]=a[3]+b[3]*scale;return out;}/**
   * Alias for {@link mat2.multiply}
   * @function
   */var mul=multiply;/**
   * Alias for {@link mat2.subtract}
   * @function
   */var sub=subtract;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"identity",function(){return identity;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"invert",function(){return invert;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"determinant",function(){return determinant;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotate",function(){return rotate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"translate",function(){return translate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotation",function(){return fromRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromScaling",function(){return fromScaling;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromTranslation",function(){return fromTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"frob",function(){return frob;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"subtract",function(){return subtract;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalar",function(){return multiplyScalar;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalarAndAdd",function(){return multiplyScalarAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/**
   * 2x3 Matrix
   * @module mat2d
   * @description
   * A mat2d contains six elements defined as:
   * <pre>
   * [a, b,
   *  c, d,
   *  tx, ty]
   * </pre>
   * This is a short form for the 3x3 matrix:
   * <pre>
   * [a, b, 0,
   *  c, d, 0,
   *  tx, ty, 1]
   * </pre>
   * The last column is ignored so the array is shorter and operations are faster.
   */ /**
   * Creates a new identity mat2d
   *
   * @returns {mat2d} a new 2x3 matrix
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[1]=0;out[2]=0;out[4]=0;out[5]=0;}out[0]=1;out[3]=1;return out;}/**
   * Creates a new mat2d initialized with values from an existing matrix
   *
   * @param {ReadonlyMat2d} a matrix to clone
   * @returns {mat2d} a new 2x3 matrix
   */function clone(a){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];return out;}/**
   * Copy the values from one mat2d to another
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the source matrix
   * @returns {mat2d} out
   */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];return out;}/**
   * Set a mat2d to the identity matrix
   *
   * @param {mat2d} out the receiving matrix
   * @returns {mat2d} out
   */function identity(out){out[0]=1;out[1]=0;out[2]=0;out[3]=1;out[4]=0;out[5]=0;return out;}/**
   * Create a new mat2d with the given values
   *
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} A new mat2d
   */function fromValues(a,b,c,d,tx,ty){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);out[0]=a;out[1]=b;out[2]=c;out[3]=d;out[4]=tx;out[5]=ty;return out;}/**
   * Set the components of a mat2d to the given values
   *
   * @param {mat2d} out the receiving matrix
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} out
   */function set(out,a,b,c,d,tx,ty){out[0]=a;out[1]=b;out[2]=c;out[3]=d;out[4]=tx;out[5]=ty;return out;}/**
   * Inverts a mat2d
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the source matrix
   * @returns {mat2d} out
   */function invert(out,a){var aa=a[0],ab=a[1],ac=a[2],ad=a[3];var atx=a[4],aty=a[5];var det=aa*ad-ab*ac;if(!det){return null;}det=1.0/det;out[0]=ad*det;out[1]=-ab*det;out[2]=-ac*det;out[3]=aa*det;out[4]=(ac*aty-ad*atx)*det;out[5]=(ab*atx-aa*aty)*det;return out;}/**
   * Calculates the determinant of a mat2d
   *
   * @param {ReadonlyMat2d} a the source matrix
   * @returns {Number} determinant of a
   */function determinant(a){return a[0]*a[3]-a[1]*a[2];}/**
   * Multiplies two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @returns {mat2d} out
   */function multiply(out,a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5];var b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5];out[0]=a0*b0+a2*b1;out[1]=a1*b0+a3*b1;out[2]=a0*b2+a2*b3;out[3]=a1*b2+a3*b3;out[4]=a0*b4+a2*b5+a4;out[5]=a1*b4+a3*b5+a5;return out;}/**
   * Rotates a mat2d by the given angle
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */function rotate(out,a,rad){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5];var s=Math.sin(rad);var c=Math.cos(rad);out[0]=a0*c+a2*s;out[1]=a1*c+a3*s;out[2]=a0*-s+a2*c;out[3]=a1*-s+a3*c;out[4]=a4;out[5]=a5;return out;}/**
   * Scales the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to translate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat2d} out
   **/function scale(out,a,v){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5];var v0=v[0],v1=v[1];out[0]=a0*v0;out[1]=a1*v0;out[2]=a2*v1;out[3]=a3*v1;out[4]=a4;out[5]=a5;return out;}/**
   * Translates the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to translate
   * @param {ReadonlyVec2} v the vec2 to translate the matrix by
   * @returns {mat2d} out
   **/function translate(out,a,v){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5];var v0=v[0],v1=v[1];out[0]=a0;out[1]=a1;out[2]=a2;out[3]=a3;out[4]=a0*v0+a2*v1+a4;out[5]=a1*v0+a3*v1+a5;return out;}/**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.rotate(dest, dest, rad);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */function fromRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);out[0]=c;out[1]=s;out[2]=-s;out[3]=c;out[4]=0;out[5]=0;return out;}/**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.scale(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat2d} out
   */function fromScaling(out,v){out[0]=v[0];out[1]=0;out[2]=0;out[3]=v[1];out[4]=0;out[5]=0;return out;}/**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.translate(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {ReadonlyVec2} v Translation vector
   * @returns {mat2d} out
   */function fromTranslation(out,v){out[0]=1;out[1]=0;out[2]=0;out[3]=1;out[4]=v[0];out[5]=v[1];return out;}/**
   * Returns a string representation of a mat2d
   *
   * @param {ReadonlyMat2d} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */function str(a){return "mat2d("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+")";}/**
   * Returns Frobenius norm of a mat2d
   *
   * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */function frob(a){return Math.hypot(a[0],a[1],a[2],a[3],a[4],a[5],1);}/**
   * Adds two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @returns {mat2d} out
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];out[3]=a[3]+b[3];out[4]=a[4]+b[4];out[5]=a[5]+b[5];return out;}/**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @returns {mat2d} out
   */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];out[3]=a[3]-b[3];out[4]=a[4]-b[4];out[5]=a[5]-b[5];return out;}/**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2d} out
   */function multiplyScalar(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;out[3]=a[3]*b;out[4]=a[4]*b;out[5]=a[5]*b;return out;}/**
   * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2d} out the receiving vector
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2d} out
   */function multiplyScalarAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;out[3]=a[3]+b[3]*scale;out[4]=a[4]+b[4]*scale;out[5]=a[5]+b[5]*scale;return out;}/**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat2d} a The first matrix.
   * @param {ReadonlyMat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&a[4]===b[4]&&a[5]===b[5];}/**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat2d} a The first matrix.
   * @param {ReadonlyMat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5];var b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a3),Math.abs(b3))&&Math.abs(a4-b4)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a4),Math.abs(b4))&&Math.abs(a5-b5)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a5),Math.abs(b5));}/**
   * Alias for {@link mat2d.multiply}
   * @function
   */var mul=multiply;/**
   * Alias for {@link mat2d.subtract}
   * @function
   */var sub=subtract;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromMat4",function(){return fromMat4;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"identity",function(){return identity;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transpose",function(){return transpose;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"invert",function(){return invert;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"adjoint",function(){return adjoint;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"determinant",function(){return determinant;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"translate",function(){return translate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotate",function(){return rotate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromTranslation",function(){return fromTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotation",function(){return fromRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromScaling",function(){return fromScaling;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromMat2d",function(){return fromMat2d;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromQuat",function(){return fromQuat;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normalFromMat4",function(){return normalFromMat4;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"projection",function(){return projection;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"frob",function(){return frob;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"subtract",function(){return subtract;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalar",function(){return multiplyScalar;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalarAndAdd",function(){return multiplyScalarAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/**
   * 3x3 Matrix
   * @module mat3
   */ /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[1]=0;out[2]=0;out[3]=0;out[5]=0;out[6]=0;out[7]=0;}out[0]=1;out[4]=1;out[8]=1;return out;}/**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {ReadonlyMat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */function fromMat4(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[4];out[4]=a[5];out[5]=a[6];out[6]=a[8];out[7]=a[9];out[8]=a[10];return out;}/**
   * Creates a new mat3 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat3} a matrix to clone
   * @returns {mat3} a new 3x3 matrix
   */function clone(a){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];return out;}/**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];return out;}/**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */function fromValues(m00,m01,m02,m10,m11,m12,m20,m21,m22){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);out[0]=m00;out[1]=m01;out[2]=m02;out[3]=m10;out[4]=m11;out[5]=m12;out[6]=m20;out[7]=m21;out[8]=m22;return out;}/**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */function set(out,m00,m01,m02,m10,m11,m12,m20,m21,m22){out[0]=m00;out[1]=m01;out[2]=m02;out[3]=m10;out[4]=m11;out[5]=m12;out[6]=m20;out[7]=m21;out[8]=m22;return out;}/**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */function identity(out){out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=1;out[5]=0;out[6]=0;out[7]=0;out[8]=1;return out;}/**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */function transpose(out,a){// If we are transposing ourselves we can skip a few steps but have to cache some values
  if(out===a){var a01=a[1],a02=a[2],a12=a[5];out[1]=a[3];out[2]=a[6];out[3]=a01;out[5]=a[7];out[6]=a02;out[7]=a12;}else {out[0]=a[0];out[1]=a[3];out[2]=a[6];out[3]=a[1];out[4]=a[4];out[5]=a[7];out[6]=a[2];out[7]=a[5];out[8]=a[8];}return out;}/**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */function invert(out,a){var a00=a[0],a01=a[1],a02=a[2];var a10=a[3],a11=a[4],a12=a[5];var a20=a[6],a21=a[7],a22=a[8];var b01=a22*a11-a12*a21;var b11=-a22*a10+a12*a20;var b21=a21*a10-a11*a20;// Calculate the determinant
  var det=a00*b01+a01*b11+a02*b21;if(!det){return null;}det=1.0/det;out[0]=b01*det;out[1]=(-a22*a01+a02*a21)*det;out[2]=(a12*a01-a02*a11)*det;out[3]=b11*det;out[4]=(a22*a00-a02*a20)*det;out[5]=(-a12*a00+a02*a10)*det;out[6]=b21*det;out[7]=(-a21*a00+a01*a20)*det;out[8]=(a11*a00-a01*a10)*det;return out;}/**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */function adjoint(out,a){var a00=a[0],a01=a[1],a02=a[2];var a10=a[3],a11=a[4],a12=a[5];var a20=a[6],a21=a[7],a22=a[8];out[0]=a11*a22-a12*a21;out[1]=a02*a21-a01*a22;out[2]=a01*a12-a02*a11;out[3]=a12*a20-a10*a22;out[4]=a00*a22-a02*a20;out[5]=a02*a10-a00*a12;out[6]=a10*a21-a11*a20;out[7]=a01*a20-a00*a21;out[8]=a00*a11-a01*a10;return out;}/**
   * Calculates the determinant of a mat3
   *
   * @param {ReadonlyMat3} a the source matrix
   * @returns {Number} determinant of a
   */function determinant(a){var a00=a[0],a01=a[1],a02=a[2];var a10=a[3],a11=a[4],a12=a[5];var a20=a[6],a21=a[7],a22=a[8];return a00*(a22*a11-a12*a21)+a01*(-a22*a10+a12*a20)+a02*(a21*a10-a11*a20);}/**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */function multiply(out,a,b){var a00=a[0],a01=a[1],a02=a[2];var a10=a[3],a11=a[4],a12=a[5];var a20=a[6],a21=a[7],a22=a[8];var b00=b[0],b01=b[1],b02=b[2];var b10=b[3],b11=b[4],b12=b[5];var b20=b[6],b21=b[7],b22=b[8];out[0]=b00*a00+b01*a10+b02*a20;out[1]=b00*a01+b01*a11+b02*a21;out[2]=b00*a02+b01*a12+b02*a22;out[3]=b10*a00+b11*a10+b12*a20;out[4]=b10*a01+b11*a11+b12*a21;out[5]=b10*a02+b11*a12+b12*a22;out[6]=b20*a00+b21*a10+b22*a20;out[7]=b20*a01+b21*a11+b22*a21;out[8]=b20*a02+b21*a12+b22*a22;return out;}/**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to translate
   * @param {ReadonlyVec2} v vector to translate by
   * @returns {mat3} out
   */function translate(out,a,v){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8],x=v[0],y=v[1];out[0]=a00;out[1]=a01;out[2]=a02;out[3]=a10;out[4]=a11;out[5]=a12;out[6]=x*a00+y*a10+a20;out[7]=x*a01+y*a11+a21;out[8]=x*a02+y*a12+a22;return out;}/**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */function rotate(out,a,rad){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8],s=Math.sin(rad),c=Math.cos(rad);out[0]=c*a00+s*a10;out[1]=c*a01+s*a11;out[2]=c*a02+s*a12;out[3]=c*a10-s*a00;out[4]=c*a11-s*a01;out[5]=c*a12-s*a02;out[6]=a20;out[7]=a21;out[8]=a22;return out;}/**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/function scale(out,a,v){var x=v[0],y=v[1];out[0]=x*a[0];out[1]=x*a[1];out[2]=x*a[2];out[3]=y*a[3];out[4]=y*a[4];out[5]=y*a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];return out;}/**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Translation vector
   * @returns {mat3} out
   */function fromTranslation(out,v){out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=1;out[5]=0;out[6]=v[0];out[7]=v[1];out[8]=1;return out;}/**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */function fromRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);out[0]=c;out[1]=s;out[2]=0;out[3]=-s;out[4]=c;out[5]=0;out[6]=0;out[7]=0;out[8]=1;return out;}/**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat3} out
   */function fromScaling(out,v){out[0]=v[0];out[1]=0;out[2]=0;out[3]=0;out[4]=v[1];out[5]=0;out[6]=0;out[7]=0;out[8]=1;return out;}/**
   * Copies the values from a mat2d into a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to copy
   * @returns {mat3} out
   **/function fromMat2d(out,a){out[0]=a[0];out[1]=a[1];out[2]=0;out[3]=a[2];out[4]=a[3];out[5]=0;out[6]=a[4];out[7]=a[5];out[8]=1;return out;}/**
   * Calculates a 3x3 matrix from the given quaternion
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat3} out
   */function fromQuat(out,q){var x=q[0],y=q[1],z=q[2],w=q[3];var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var yx=y*x2;var yy=y*y2;var zx=z*x2;var zy=z*y2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;out[0]=1-yy-zz;out[3]=yx-wz;out[6]=zx+wy;out[1]=yx+wz;out[4]=1-xx-zz;out[7]=zy-wx;out[2]=zx-wy;out[5]=zy+wx;out[8]=1-xx-yy;return out;}/**
   * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
   *
   * @returns {mat3} out
   */function normalFromMat4(out,a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3];var a10=a[4],a11=a[5],a12=a[6],a13=a[7];var a20=a[8],a21=a[9],a22=a[10],a23=a[11];var a30=a[12],a31=a[13],a32=a[14],a33=a[15];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;// Calculate the determinant
  var det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;if(!det){return null;}det=1.0/det;out[0]=(a11*b11-a12*b10+a13*b09)*det;out[1]=(a12*b08-a10*b11-a13*b07)*det;out[2]=(a10*b10-a11*b08+a13*b06)*det;out[3]=(a02*b10-a01*b11-a03*b09)*det;out[4]=(a00*b11-a02*b08+a03*b07)*det;out[5]=(a01*b08-a00*b10-a03*b06)*det;out[6]=(a31*b05-a32*b04+a33*b03)*det;out[7]=(a32*b02-a30*b05-a33*b01)*det;out[8]=(a30*b04-a31*b02+a33*b00)*det;return out;}/**
   * Generates a 2D projection matrix with the given bounds
   *
   * @param {mat3} out mat3 frustum matrix will be written into
   * @param {number} width Width of your gl context
   * @param {number} height Height of gl context
   * @returns {mat3} out
   */function projection(out,width,height){out[0]=2/width;out[1]=0;out[2]=0;out[3]=0;out[4]=-2/height;out[5]=0;out[6]=-1;out[7]=1;out[8]=1;return out;}/**
   * Returns a string representation of a mat3
   *
   * @param {ReadonlyMat3} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */function str(a){return "mat3("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+")";}/**
   * Returns Frobenius norm of a mat3
   *
   * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */function frob(a){return Math.hypot(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);}/**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];out[3]=a[3]+b[3];out[4]=a[4]+b[4];out[5]=a[5]+b[5];out[6]=a[6]+b[6];out[7]=a[7]+b[7];out[8]=a[8]+b[8];return out;}/**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];out[3]=a[3]-b[3];out[4]=a[4]-b[4];out[5]=a[5]-b[5];out[6]=a[6]-b[6];out[7]=a[7]-b[7];out[8]=a[8]-b[8];return out;}/**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat3} out
   */function multiplyScalar(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;out[3]=a[3]*b;out[4]=a[4]*b;out[5]=a[5]*b;out[6]=a[6]*b;out[7]=a[7]*b;out[8]=a[8]*b;return out;}/**
   * Adds two mat3's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat3} out the receiving vector
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat3} out
   */function multiplyScalarAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;out[3]=a[3]+b[3]*scale;out[4]=a[4]+b[4]*scale;out[5]=a[5]+b[5]*scale;out[6]=a[6]+b[6]*scale;out[7]=a[7]+b[7]*scale;out[8]=a[8]+b[8]*scale;return out;}/**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat3} a The first matrix.
   * @param {ReadonlyMat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&a[4]===b[4]&&a[5]===b[5]&&a[6]===b[6]&&a[7]===b[7]&&a[8]===b[8];}/**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat3} a The first matrix.
   * @param {ReadonlyMat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],a6=a[6],a7=a[7],a8=a[8];var b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5],b6=b[6],b7=b[7],b8=b[8];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a3),Math.abs(b3))&&Math.abs(a4-b4)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a4),Math.abs(b4))&&Math.abs(a5-b5)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a5),Math.abs(b5))&&Math.abs(a6-b6)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a6),Math.abs(b6))&&Math.abs(a7-b7)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a7),Math.abs(b7))&&Math.abs(a8-b8)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a8),Math.abs(b8));}/**
   * Alias for {@link mat3.multiply}
   * @function
   */var mul=multiply;/**
   * Alias for {@link mat3.subtract}
   * @function
   */var sub=subtract;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"identity",function(){return identity;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transpose",function(){return transpose;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"invert",function(){return invert;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"adjoint",function(){return adjoint;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"determinant",function(){return determinant;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"translate",function(){return translate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotate",function(){return rotate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateX",function(){return rotateX;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateY",function(){return rotateY;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateZ",function(){return rotateZ;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromTranslation",function(){return fromTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromScaling",function(){return fromScaling;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotation",function(){return fromRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromXRotation",function(){return fromXRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromYRotation",function(){return fromYRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromZRotation",function(){return fromZRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotationTranslation",function(){return fromRotationTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromQuat2",function(){return fromQuat2;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getTranslation",function(){return getTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getScaling",function(){return getScaling;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getRotation",function(){return getRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotationTranslationScale",function(){return fromRotationTranslationScale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotationTranslationScaleOrigin",function(){return fromRotationTranslationScaleOrigin;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromQuat",function(){return fromQuat;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"frustum",function(){return frustum;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"perspective",function(){return perspective;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"perspectiveFromFieldOfView",function(){return perspectiveFromFieldOfView;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"ortho",function(){return ortho;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"lookAt",function(){return lookAt;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"targetTo",function(){return targetTo;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"frob",function(){return frob;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"subtract",function(){return subtract;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalar",function(){return multiplyScalar;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiplyScalarAndAdd",function(){return multiplyScalarAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */ /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[11]=0;out[12]=0;out[13]=0;out[14]=0;}out[0]=1;out[5]=1;out[10]=1;out[15]=1;return out;}/**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */function clone(a){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return out;}/**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return out;}/**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */function fromValues(m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);out[0]=m00;out[1]=m01;out[2]=m02;out[3]=m03;out[4]=m10;out[5]=m11;out[6]=m12;out[7]=m13;out[8]=m20;out[9]=m21;out[10]=m22;out[11]=m23;out[12]=m30;out[13]=m31;out[14]=m32;out[15]=m33;return out;}/**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */function set(out,m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33){out[0]=m00;out[1]=m01;out[2]=m02;out[3]=m03;out[4]=m10;out[5]=m11;out[6]=m12;out[7]=m13;out[8]=m20;out[9]=m21;out[10]=m22;out[11]=m23;out[12]=m30;out[13]=m31;out[14]=m32;out[15]=m33;return out;}/**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */function identity(out){out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=1;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=1;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;}/**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */function transpose(out,a){// If we are transposing ourselves we can skip a few steps but have to cache some values
  if(out===a){var a01=a[1],a02=a[2],a03=a[3];var a12=a[6],a13=a[7];var a23=a[11];out[1]=a[4];out[2]=a[8];out[3]=a[12];out[4]=a01;out[6]=a[9];out[7]=a[13];out[8]=a02;out[9]=a12;out[11]=a[14];out[12]=a03;out[13]=a13;out[14]=a23;}else {out[0]=a[0];out[1]=a[4];out[2]=a[8];out[3]=a[12];out[4]=a[1];out[5]=a[5];out[6]=a[9];out[7]=a[13];out[8]=a[2];out[9]=a[6];out[10]=a[10];out[11]=a[14];out[12]=a[3];out[13]=a[7];out[14]=a[11];out[15]=a[15];}return out;}/**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */function invert(out,a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3];var a10=a[4],a11=a[5],a12=a[6],a13=a[7];var a20=a[8],a21=a[9],a22=a[10],a23=a[11];var a30=a[12],a31=a[13],a32=a[14],a33=a[15];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;// Calculate the determinant
  var det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;if(!det){return null;}det=1.0/det;out[0]=(a11*b11-a12*b10+a13*b09)*det;out[1]=(a02*b10-a01*b11-a03*b09)*det;out[2]=(a31*b05-a32*b04+a33*b03)*det;out[3]=(a22*b04-a21*b05-a23*b03)*det;out[4]=(a12*b08-a10*b11-a13*b07)*det;out[5]=(a00*b11-a02*b08+a03*b07)*det;out[6]=(a32*b02-a30*b05-a33*b01)*det;out[7]=(a20*b05-a22*b02+a23*b01)*det;out[8]=(a10*b10-a11*b08+a13*b06)*det;out[9]=(a01*b08-a00*b10-a03*b06)*det;out[10]=(a30*b04-a31*b02+a33*b00)*det;out[11]=(a21*b02-a20*b04-a23*b00)*det;out[12]=(a11*b07-a10*b09-a12*b06)*det;out[13]=(a00*b09-a01*b07+a02*b06)*det;out[14]=(a31*b01-a30*b03-a32*b00)*det;out[15]=(a20*b03-a21*b01+a22*b00)*det;return out;}/**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */function adjoint(out,a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3];var a10=a[4],a11=a[5],a12=a[6],a13=a[7];var a20=a[8],a21=a[9],a22=a[10],a23=a[11];var a30=a[12],a31=a[13],a32=a[14],a33=a[15];out[0]=a11*(a22*a33-a23*a32)-a21*(a12*a33-a13*a32)+a31*(a12*a23-a13*a22);out[1]=-(a01*(a22*a33-a23*a32)-a21*(a02*a33-a03*a32)+a31*(a02*a23-a03*a22));out[2]=a01*(a12*a33-a13*a32)-a11*(a02*a33-a03*a32)+a31*(a02*a13-a03*a12);out[3]=-(a01*(a12*a23-a13*a22)-a11*(a02*a23-a03*a22)+a21*(a02*a13-a03*a12));out[4]=-(a10*(a22*a33-a23*a32)-a20*(a12*a33-a13*a32)+a30*(a12*a23-a13*a22));out[5]=a00*(a22*a33-a23*a32)-a20*(a02*a33-a03*a32)+a30*(a02*a23-a03*a22);out[6]=-(a00*(a12*a33-a13*a32)-a10*(a02*a33-a03*a32)+a30*(a02*a13-a03*a12));out[7]=a00*(a12*a23-a13*a22)-a10*(a02*a23-a03*a22)+a20*(a02*a13-a03*a12);out[8]=a10*(a21*a33-a23*a31)-a20*(a11*a33-a13*a31)+a30*(a11*a23-a13*a21);out[9]=-(a00*(a21*a33-a23*a31)-a20*(a01*a33-a03*a31)+a30*(a01*a23-a03*a21));out[10]=a00*(a11*a33-a13*a31)-a10*(a01*a33-a03*a31)+a30*(a01*a13-a03*a11);out[11]=-(a00*(a11*a23-a13*a21)-a10*(a01*a23-a03*a21)+a20*(a01*a13-a03*a11));out[12]=-(a10*(a21*a32-a22*a31)-a20*(a11*a32-a12*a31)+a30*(a11*a22-a12*a21));out[13]=a00*(a21*a32-a22*a31)-a20*(a01*a32-a02*a31)+a30*(a01*a22-a02*a21);out[14]=-(a00*(a11*a32-a12*a31)-a10*(a01*a32-a02*a31)+a30*(a01*a12-a02*a11));out[15]=a00*(a11*a22-a12*a21)-a10*(a01*a22-a02*a21)+a20*(a01*a12-a02*a11);return out;}/**
   * Calculates the determinant of a mat4
   *
   * @param {ReadonlyMat4} a the source matrix
   * @returns {Number} determinant of a
   */function determinant(a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3];var a10=a[4],a11=a[5],a12=a[6],a13=a[7];var a20=a[8],a21=a[9],a22=a[10],a23=a[11];var a30=a[12],a31=a[13],a32=a[14],a33=a[15];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;// Calculate the determinant
  return b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;}/**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */function multiply(out,a,b){var a00=a[0],a01=a[1],a02=a[2],a03=a[3];var a10=a[4],a11=a[5],a12=a[6],a13=a[7];var a20=a[8],a21=a[9],a22=a[10],a23=a[11];var a30=a[12],a31=a[13],a32=a[14],a33=a[15];// Cache only the current line of the second matrix
  var b0=b[0],b1=b[1],b2=b[2],b3=b[3];out[0]=b0*a00+b1*a10+b2*a20+b3*a30;out[1]=b0*a01+b1*a11+b2*a21+b3*a31;out[2]=b0*a02+b1*a12+b2*a22+b3*a32;out[3]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[4];b1=b[5];b2=b[6];b3=b[7];out[4]=b0*a00+b1*a10+b2*a20+b3*a30;out[5]=b0*a01+b1*a11+b2*a21+b3*a31;out[6]=b0*a02+b1*a12+b2*a22+b3*a32;out[7]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[8];b1=b[9];b2=b[10];b3=b[11];out[8]=b0*a00+b1*a10+b2*a20+b3*a30;out[9]=b0*a01+b1*a11+b2*a21+b3*a31;out[10]=b0*a02+b1*a12+b2*a22+b3*a32;out[11]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[12];b1=b[13];b2=b[14];b3=b[15];out[12]=b0*a00+b1*a10+b2*a20+b3*a30;out[13]=b0*a01+b1*a11+b2*a21+b3*a31;out[14]=b0*a02+b1*a12+b2*a22+b3*a32;out[15]=b0*a03+b1*a13+b2*a23+b3*a33;return out;}/**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to translate
   * @param {ReadonlyVec3} v vector to translate by
   * @returns {mat4} out
   */function translate(out,a,v){var x=v[0],y=v[1],z=v[2];var a00,a01,a02,a03;var a10,a11,a12,a13;var a20,a21,a22,a23;if(a===out){out[12]=a[0]*x+a[4]*y+a[8]*z+a[12];out[13]=a[1]*x+a[5]*y+a[9]*z+a[13];out[14]=a[2]*x+a[6]*y+a[10]*z+a[14];out[15]=a[3]*x+a[7]*y+a[11]*z+a[15];}else {a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];out[0]=a00;out[1]=a01;out[2]=a02;out[3]=a03;out[4]=a10;out[5]=a11;out[6]=a12;out[7]=a13;out[8]=a20;out[9]=a21;out[10]=a22;out[11]=a23;out[12]=a00*x+a10*y+a20*z+a[12];out[13]=a01*x+a11*y+a21*z+a[13];out[14]=a02*x+a12*y+a22*z+a[14];out[15]=a03*x+a13*y+a23*z+a[15];}return out;}/**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {ReadonlyVec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/function scale(out,a,v){var x=v[0],y=v[1],z=v[2];out[0]=a[0]*x;out[1]=a[1]*x;out[2]=a[2]*x;out[3]=a[3]*x;out[4]=a[4]*y;out[5]=a[5]*y;out[6]=a[6]*y;out[7]=a[7]*y;out[8]=a[8]*z;out[9]=a[9]*z;out[10]=a[10]*z;out[11]=a[11]*z;out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return out;}/**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */function rotate(out,a,rad,axis){var x=axis[0],y=axis[1],z=axis[2];var len=Math.hypot(x,y,z);var s,c,t;var a00,a01,a02,a03;var a10,a11,a12,a13;var a20,a21,a22,a23;var b00,b01,b02;var b10,b11,b12;var b20,b21,b22;if(len<_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]){return null;}len=1/len;x*=len;y*=len;z*=len;s=Math.sin(rad);c=Math.cos(rad);t=1-c;a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];// Construct the elements of the rotation matrix
  b00=x*x*t+c;b01=y*x*t+z*s;b02=z*x*t-y*s;b10=x*y*t-z*s;b11=y*y*t+c;b12=z*y*t+x*s;b20=x*z*t+y*s;b21=y*z*t-x*s;b22=z*z*t+c;// Perform rotation-specific matrix multiplication
  out[0]=a00*b00+a10*b01+a20*b02;out[1]=a01*b00+a11*b01+a21*b02;out[2]=a02*b00+a12*b01+a22*b02;out[3]=a03*b00+a13*b01+a23*b02;out[4]=a00*b10+a10*b11+a20*b12;out[5]=a01*b10+a11*b11+a21*b12;out[6]=a02*b10+a12*b11+a22*b12;out[7]=a03*b10+a13*b11+a23*b12;out[8]=a00*b20+a10*b21+a20*b22;out[9]=a01*b20+a11*b21+a21*b22;out[10]=a02*b20+a12*b21+a22*b22;out[11]=a03*b20+a13*b21+a23*b22;if(a!==out){// If the source and destination differ, copy the unchanged last row
  out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}return out;}/**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */function rotateX(out,a,rad){var s=Math.sin(rad);var c=Math.cos(rad);var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];if(a!==out){// If the source and destination differ, copy the unchanged rows
  out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}// Perform axis-specific matrix multiplication
  out[4]=a10*c+a20*s;out[5]=a11*c+a21*s;out[6]=a12*c+a22*s;out[7]=a13*c+a23*s;out[8]=a20*c-a10*s;out[9]=a21*c-a11*s;out[10]=a22*c-a12*s;out[11]=a23*c-a13*s;return out;}/**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */function rotateY(out,a,rad){var s=Math.sin(rad);var c=Math.cos(rad);var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];if(a!==out){// If the source and destination differ, copy the unchanged rows
  out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}// Perform axis-specific matrix multiplication
  out[0]=a00*c-a20*s;out[1]=a01*c-a21*s;out[2]=a02*c-a22*s;out[3]=a03*c-a23*s;out[8]=a00*s+a20*c;out[9]=a01*s+a21*c;out[10]=a02*s+a22*c;out[11]=a03*s+a23*c;return out;}/**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */function rotateZ(out,a,rad){var s=Math.sin(rad);var c=Math.cos(rad);var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];if(a!==out){// If the source and destination differ, copy the unchanged last row
  out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}// Perform axis-specific matrix multiplication
  out[0]=a00*c+a10*s;out[1]=a01*c+a11*s;out[2]=a02*c+a12*s;out[3]=a03*c+a13*s;out[4]=a10*c-a00*s;out[5]=a11*c-a01*s;out[6]=a12*c-a02*s;out[7]=a13*c-a03*s;return out;}/**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */function fromTranslation(out,v){out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=1;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=1;out[11]=0;out[12]=v[0];out[13]=v[1];out[14]=v[2];out[15]=1;return out;}/**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Scaling vector
   * @returns {mat4} out
   */function fromScaling(out,v){out[0]=v[0];out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=v[1];out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=v[2];out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;}/**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */function fromRotation(out,rad,axis){var x=axis[0],y=axis[1],z=axis[2];var len=Math.hypot(x,y,z);var s,c,t;if(len<_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]){return null;}len=1/len;x*=len;y*=len;z*=len;s=Math.sin(rad);c=Math.cos(rad);t=1-c;// Perform rotation-specific matrix multiplication
  out[0]=x*x*t+c;out[1]=y*x*t+z*s;out[2]=z*x*t-y*s;out[3]=0;out[4]=x*y*t-z*s;out[5]=y*y*t+c;out[6]=z*y*t+x*s;out[7]=0;out[8]=x*z*t+y*s;out[9]=y*z*t-x*s;out[10]=z*z*t+c;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;}/**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */function fromXRotation(out,rad){var s=Math.sin(rad);var c=Math.cos(rad);// Perform axis-specific matrix multiplication
  out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=c;out[6]=s;out[7]=0;out[8]=0;out[9]=-s;out[10]=c;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;}/**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */function fromYRotation(out,rad){var s=Math.sin(rad);var c=Math.cos(rad);// Perform axis-specific matrix multiplication
  out[0]=c;out[1]=0;out[2]=-s;out[3]=0;out[4]=0;out[5]=1;out[6]=0;out[7]=0;out[8]=s;out[9]=0;out[10]=c;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;}/**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */function fromZRotation(out,rad){var s=Math.sin(rad);var c=Math.cos(rad);// Perform axis-specific matrix multiplication
  out[0]=c;out[1]=s;out[2]=0;out[3]=0;out[4]=-s;out[5]=c;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=1;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;}/**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */function fromRotationTranslation(out,q,v){// Quaternion math
  var x=q[0],y=q[1],z=q[2],w=q[3];var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;out[0]=1-(yy+zz);out[1]=xy+wz;out[2]=xz-wy;out[3]=0;out[4]=xy-wz;out[5]=1-(xx+zz);out[6]=yz+wx;out[7]=0;out[8]=xz+wy;out[9]=yz-wx;out[10]=1-(xx+yy);out[11]=0;out[12]=v[0];out[13]=v[1];out[14]=v[2];out[15]=1;return out;}/**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {ReadonlyQuat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */function fromQuat2(out,a){var translation=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);var bx=-a[0],by=-a[1],bz=-a[2],bw=a[3],ax=a[4],ay=a[5],az=a[6],aw=a[7];var magnitude=bx*bx+by*by+bz*bz+bw*bw;//Only scale if it makes sense
  if(magnitude>0){translation[0]=(ax*bw+aw*bx+ay*bz-az*by)*2/magnitude;translation[1]=(ay*bw+aw*by+az*bx-ax*bz)*2/magnitude;translation[2]=(az*bw+aw*bz+ax*by-ay*bx)*2/magnitude;}else {translation[0]=(ax*bw+aw*bx+ay*bz-az*by)*2;translation[1]=(ay*bw+aw*by+az*bx-ax*bz)*2;translation[2]=(az*bw+aw*bz+ax*by-ay*bx)*2;}fromRotationTranslation(out,a,translation);return out;}/**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */function getTranslation(out,mat){out[0]=mat[12];out[1]=mat[13];out[2]=mat[14];return out;}/**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */function getScaling(out,mat){var m11=mat[0];var m12=mat[1];var m13=mat[2];var m21=mat[4];var m22=mat[5];var m23=mat[6];var m31=mat[8];var m32=mat[9];var m33=mat[10];out[0]=Math.hypot(m11,m12,m13);out[1]=Math.hypot(m21,m22,m23);out[2]=Math.hypot(m31,m32,m33);return out;}/**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */function getRotation(out,mat){var scaling=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);getScaling(scaling,mat);var is1=1/scaling[0];var is2=1/scaling[1];var is3=1/scaling[2];var sm11=mat[0]*is1;var sm12=mat[1]*is2;var sm13=mat[2]*is3;var sm21=mat[4]*is1;var sm22=mat[5]*is2;var sm23=mat[6]*is3;var sm31=mat[8]*is1;var sm32=mat[9]*is2;var sm33=mat[10]*is3;var trace=sm11+sm22+sm33;var S=0;if(trace>0){S=Math.sqrt(trace+1.0)*2;out[3]=0.25*S;out[0]=(sm23-sm32)/S;out[1]=(sm31-sm13)/S;out[2]=(sm12-sm21)/S;}else if(sm11>sm22&&sm11>sm33){S=Math.sqrt(1.0+sm11-sm22-sm33)*2;out[3]=(sm23-sm32)/S;out[0]=0.25*S;out[1]=(sm12+sm21)/S;out[2]=(sm31+sm13)/S;}else if(sm22>sm33){S=Math.sqrt(1.0+sm22-sm11-sm33)*2;out[3]=(sm31-sm13)/S;out[0]=(sm12+sm21)/S;out[1]=0.25*S;out[2]=(sm23+sm32)/S;}else {S=Math.sqrt(1.0+sm33-sm11-sm22)*2;out[3]=(sm12-sm21)/S;out[0]=(sm31+sm13)/S;out[1]=(sm23+sm32)/S;out[2]=0.25*S;}return out;}/**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @returns {mat4} out
   */function fromRotationTranslationScale(out,q,v,s){// Quaternion math
  var x=q[0],y=q[1],z=q[2],w=q[3];var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;var sx=s[0];var sy=s[1];var sz=s[2];out[0]=(1-(yy+zz))*sx;out[1]=(xy+wz)*sx;out[2]=(xz-wy)*sx;out[3]=0;out[4]=(xy-wz)*sy;out[5]=(1-(xx+zz))*sy;out[6]=(yz+wx)*sy;out[7]=0;out[8]=(xz+wy)*sz;out[9]=(yz-wx)*sz;out[10]=(1-(xx+yy))*sz;out[11]=0;out[12]=v[0];out[13]=v[1];out[14]=v[2];out[15]=1;return out;}/**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */function fromRotationTranslationScaleOrigin(out,q,v,s,o){// Quaternion math
  var x=q[0],y=q[1],z=q[2],w=q[3];var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;var sx=s[0];var sy=s[1];var sz=s[2];var ox=o[0];var oy=o[1];var oz=o[2];var out0=(1-(yy+zz))*sx;var out1=(xy+wz)*sx;var out2=(xz-wy)*sx;var out4=(xy-wz)*sy;var out5=(1-(xx+zz))*sy;var out6=(yz+wx)*sy;var out8=(xz+wy)*sz;var out9=(yz-wx)*sz;var out10=(1-(xx+yy))*sz;out[0]=out0;out[1]=out1;out[2]=out2;out[3]=0;out[4]=out4;out[5]=out5;out[6]=out6;out[7]=0;out[8]=out8;out[9]=out9;out[10]=out10;out[11]=0;out[12]=v[0]+ox-(out0*ox+out4*oy+out8*oz);out[13]=v[1]+oy-(out1*ox+out5*oy+out9*oz);out[14]=v[2]+oz-(out2*ox+out6*oy+out10*oz);out[15]=1;return out;}/**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */function fromQuat(out,q){var x=q[0],y=q[1],z=q[2],w=q[3];var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var yx=y*x2;var yy=y*y2;var zx=z*x2;var zy=z*y2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;out[0]=1-yy-zz;out[1]=yx+wz;out[2]=zx-wy;out[3]=0;out[4]=yx-wz;out[5]=1-xx-zz;out[6]=zy+wx;out[7]=0;out[8]=zx+wy;out[9]=zy-wx;out[10]=1-xx-yy;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;}/**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */function frustum(out,left,right,bottom,top,near,far){var rl=1/(right-left);var tb=1/(top-bottom);var nf=1/(near-far);out[0]=near*2*rl;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=near*2*tb;out[6]=0;out[7]=0;out[8]=(right+left)*rl;out[9]=(top+bottom)*tb;out[10]=(far+near)*nf;out[11]=-1;out[12]=0;out[13]=0;out[14]=far*near*2*nf;out[15]=0;return out;}/**
   * Generates a perspective projection matrix with the given bounds.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */function perspective(out,fovy,aspect,near,far){var f=1.0/Math.tan(fovy/2),nf;out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[11]=-1;out[12]=0;out[13]=0;out[15]=0;if(far!=null&&far!==Infinity){nf=1/(near-far);out[10]=(far+near)*nf;out[14]=2*far*near*nf;}else {out[10]=-1;out[14]=-2*near;}return out;}/**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */function perspectiveFromFieldOfView(out,fov,near,far){var upTan=Math.tan(fov.upDegrees*Math.PI/180.0);var downTan=Math.tan(fov.downDegrees*Math.PI/180.0);var leftTan=Math.tan(fov.leftDegrees*Math.PI/180.0);var rightTan=Math.tan(fov.rightDegrees*Math.PI/180.0);var xScale=2.0/(leftTan+rightTan);var yScale=2.0/(upTan+downTan);out[0]=xScale;out[1]=0.0;out[2]=0.0;out[3]=0.0;out[4]=0.0;out[5]=yScale;out[6]=0.0;out[7]=0.0;out[8]=-((leftTan-rightTan)*xScale*0.5);out[9]=(upTan-downTan)*yScale*0.5;out[10]=far/(near-far);out[11]=-1.0;out[12]=0.0;out[13]=0.0;out[14]=far*near/(near-far);out[15]=0.0;return out;}/**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */function ortho(out,left,right,bottom,top,near,far){var lr=1/(left-right);var bt=1/(bottom-top);var nf=1/(near-far);out[0]=-2*lr;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=-2*bt;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=2*nf;out[11]=0;out[12]=(left+right)*lr;out[13]=(top+bottom)*bt;out[14]=(far+near)*nf;out[15]=1;return out;}/**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */function lookAt(out,eye,center,up){var x0,x1,x2,y0,y1,y2,z0,z1,z2,len;var eyex=eye[0];var eyey=eye[1];var eyez=eye[2];var upx=up[0];var upy=up[1];var upz=up[2];var centerx=center[0];var centery=center[1];var centerz=center[2];if(Math.abs(eyex-centerx)<_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]&&Math.abs(eyey-centery)<_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]&&Math.abs(eyez-centerz)<_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]){return identity(out);}z0=eyex-centerx;z1=eyey-centery;z2=eyez-centerz;len=1/Math.hypot(z0,z1,z2);z0*=len;z1*=len;z2*=len;x0=upy*z2-upz*z1;x1=upz*z0-upx*z2;x2=upx*z1-upy*z0;len=Math.hypot(x0,x1,x2);if(!len){x0=0;x1=0;x2=0;}else {len=1/len;x0*=len;x1*=len;x2*=len;}y0=z1*x2-z2*x1;y1=z2*x0-z0*x2;y2=z0*x1-z1*x0;len=Math.hypot(y0,y1,y2);if(!len){y0=0;y1=0;y2=0;}else {len=1/len;y0*=len;y1*=len;y2*=len;}out[0]=x0;out[1]=y0;out[2]=z0;out[3]=0;out[4]=x1;out[5]=y1;out[6]=z1;out[7]=0;out[8]=x2;out[9]=y2;out[10]=z2;out[11]=0;out[12]=-(x0*eyex+x1*eyey+x2*eyez);out[13]=-(y0*eyex+y1*eyey+y2*eyez);out[14]=-(z0*eyex+z1*eyey+z2*eyez);out[15]=1;return out;}/**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */function targetTo(out,eye,target,up){var eyex=eye[0],eyey=eye[1],eyez=eye[2],upx=up[0],upy=up[1],upz=up[2];var z0=eyex-target[0],z1=eyey-target[1],z2=eyez-target[2];var len=z0*z0+z1*z1+z2*z2;if(len>0){len=1/Math.sqrt(len);z0*=len;z1*=len;z2*=len;}var x0=upy*z2-upz*z1,x1=upz*z0-upx*z2,x2=upx*z1-upy*z0;len=x0*x0+x1*x1+x2*x2;if(len>0){len=1/Math.sqrt(len);x0*=len;x1*=len;x2*=len;}out[0]=x0;out[1]=x1;out[2]=x2;out[3]=0;out[4]=z1*x2-z2*x1;out[5]=z2*x0-z0*x2;out[6]=z0*x1-z1*x0;out[7]=0;out[8]=z0;out[9]=z1;out[10]=z2;out[11]=0;out[12]=eyex;out[13]=eyey;out[14]=eyez;out[15]=1;return out;}/**
   * Returns a string representation of a mat4
   *
   * @param {ReadonlyMat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */function str(a){return "mat4("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+")";}/**
   * Returns Frobenius norm of a mat4
   *
   * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */function frob(a){return Math.hypot(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]);}/**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];out[3]=a[3]+b[3];out[4]=a[4]+b[4];out[5]=a[5]+b[5];out[6]=a[6]+b[6];out[7]=a[7]+b[7];out[8]=a[8]+b[8];out[9]=a[9]+b[9];out[10]=a[10]+b[10];out[11]=a[11]+b[11];out[12]=a[12]+b[12];out[13]=a[13]+b[13];out[14]=a[14]+b[14];out[15]=a[15]+b[15];return out;}/**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];out[3]=a[3]-b[3];out[4]=a[4]-b[4];out[5]=a[5]-b[5];out[6]=a[6]-b[6];out[7]=a[7]-b[7];out[8]=a[8]-b[8];out[9]=a[9]-b[9];out[10]=a[10]-b[10];out[11]=a[11]-b[11];out[12]=a[12]-b[12];out[13]=a[13]-b[13];out[14]=a[14]-b[14];out[15]=a[15]-b[15];return out;}/**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */function multiplyScalar(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;out[3]=a[3]*b;out[4]=a[4]*b;out[5]=a[5]*b;out[6]=a[6]*b;out[7]=a[7]*b;out[8]=a[8]*b;out[9]=a[9]*b;out[10]=a[10]*b;out[11]=a[11]*b;out[12]=a[12]*b;out[13]=a[13]*b;out[14]=a[14]*b;out[15]=a[15]*b;return out;}/**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */function multiplyScalarAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;out[3]=a[3]+b[3]*scale;out[4]=a[4]+b[4]*scale;out[5]=a[5]+b[5]*scale;out[6]=a[6]+b[6]*scale;out[7]=a[7]+b[7]*scale;out[8]=a[8]+b[8]*scale;out[9]=a[9]+b[9]*scale;out[10]=a[10]+b[10]*scale;out[11]=a[11]+b[11]*scale;out[12]=a[12]+b[12]*scale;out[13]=a[13]+b[13]*scale;out[14]=a[14]+b[14]*scale;out[15]=a[15]+b[15]*scale;return out;}/**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&a[4]===b[4]&&a[5]===b[5]&&a[6]===b[6]&&a[7]===b[7]&&a[8]===b[8]&&a[9]===b[9]&&a[10]===b[10]&&a[11]===b[11]&&a[12]===b[12]&&a[13]===b[13]&&a[14]===b[14]&&a[15]===b[15];}/**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];var a4=a[4],a5=a[5],a6=a[6],a7=a[7];var a8=a[8],a9=a[9],a10=a[10],a11=a[11];var a12=a[12],a13=a[13],a14=a[14],a15=a[15];var b0=b[0],b1=b[1],b2=b[2],b3=b[3];var b4=b[4],b5=b[5],b6=b[6],b7=b[7];var b8=b[8],b9=b[9],b10=b[10],b11=b[11];var b12=b[12],b13=b[13],b14=b[14],b15=b[15];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a3),Math.abs(b3))&&Math.abs(a4-b4)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a4),Math.abs(b4))&&Math.abs(a5-b5)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a5),Math.abs(b5))&&Math.abs(a6-b6)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a6),Math.abs(b6))&&Math.abs(a7-b7)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a7),Math.abs(b7))&&Math.abs(a8-b8)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a8),Math.abs(b8))&&Math.abs(a9-b9)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a9),Math.abs(b9))&&Math.abs(a10-b10)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a10),Math.abs(b10))&&Math.abs(a11-b11)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a11),Math.abs(b11))&&Math.abs(a12-b12)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a12),Math.abs(b12))&&Math.abs(a13-b13)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a13),Math.abs(b13))&&Math.abs(a14-b14)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a14),Math.abs(b14))&&Math.abs(a15-b15)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a15),Math.abs(b15));}/**
   * Alias for {@link mat4.multiply}
   * @function
   */var mul=multiply;/**
   * Alias for {@link mat4.subtract}
   * @function
   */var sub=subtract;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"identity",function(){return identity;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"setAxisAngle",function(){return setAxisAngle;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getAxisAngle",function(){return getAxisAngle;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getAngle",function(){return getAngle;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateX",function(){return rotateX;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateY",function(){return rotateY;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateZ",function(){return rotateZ;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"calculateW",function(){return calculateW;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exp",function(){return exp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"ln",function(){return ln;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"pow",function(){return pow;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"slerp",function(){return slerp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"random",function(){return random;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"invert",function(){return invert;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"conjugate",function(){return conjugate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromMat3",function(){return fromMat3;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromEuler",function(){return fromEuler;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dot",function(){return dot;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"lerp",function(){return lerp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"length",function(){return length;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"len",function(){return len;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredLength",function(){return squaredLength;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrLen",function(){return sqrLen;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normalize",function(){return normalize;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotationTo",function(){return rotationTo;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqlerp",function(){return sqlerp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"setAxes",function(){return setAxes;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/* harmony import */var _mat3_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(5);/* harmony import */var _vec3_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(8);/* harmony import */var _vec4_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(9);/**
   * Quaternion
   * @module quat
   */ /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[0]=0;out[1]=0;out[2]=0;}out[3]=1;return out;}/**
   * Set a quat to the identity quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */function identity(out){out[0]=0;out[1]=0;out[2]=0;out[3]=1;return out;}/**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyVec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/function setAxisAngle(out,axis,rad){rad=rad*0.5;var s=Math.sin(rad);out[0]=s*axis[0];out[1]=s*axis[1];out[2]=s*axis[2];out[3]=Math.cos(rad);return out;}/**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {ReadonlyQuat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */function getAxisAngle(out_axis,q){var rad=Math.acos(q[3])*2.0;var s=Math.sin(rad/2.0);if(s>_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]){out_axis[0]=q[0]/s;out_axis[1]=q[1]/s;out_axis[2]=q[2]/s;}else {// If s is zero, return any axis (no rotation - axis does not matter)
  out_axis[0]=1;out_axis[1]=0;out_axis[2]=0;}return rad;}/**
   * Gets the angular distance between two unit quaternions
   *
   * @param  {ReadonlyQuat} a     Origin unit quaternion
   * @param  {ReadonlyQuat} b     Destination unit quaternion
   * @return {Number}     Angle, in radians, between the two quaternions
   */function getAngle(a,b){var dotproduct=dot(a,b);return Math.acos(2*dotproduct*dotproduct-1);}/**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {quat} out
   */function multiply(out,a,b){var ax=a[0],ay=a[1],az=a[2],aw=a[3];var bx=b[0],by=b[1],bz=b[2],bw=b[3];out[0]=ax*bw+aw*bx+ay*bz-az*by;out[1]=ay*bw+aw*by+az*bx-ax*bz;out[2]=az*bw+aw*bz+ax*by-ay*bx;out[3]=aw*bw-ax*bx-ay*by-az*bz;return out;}/**
   * Rotates a quaternion by the given angle about the X axis
   *
   * @param {quat} out quat receiving operation result
   * @param {ReadonlyQuat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */function rotateX(out,a,rad){rad*=0.5;var ax=a[0],ay=a[1],az=a[2],aw=a[3];var bx=Math.sin(rad),bw=Math.cos(rad);out[0]=ax*bw+aw*bx;out[1]=ay*bw+az*bx;out[2]=az*bw-ay*bx;out[3]=aw*bw-ax*bx;return out;}/**
   * Rotates a quaternion by the given angle about the Y axis
   *
   * @param {quat} out quat receiving operation result
   * @param {ReadonlyQuat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */function rotateY(out,a,rad){rad*=0.5;var ax=a[0],ay=a[1],az=a[2],aw=a[3];var by=Math.sin(rad),bw=Math.cos(rad);out[0]=ax*bw-az*by;out[1]=ay*bw+aw*by;out[2]=az*bw+ax*by;out[3]=aw*bw-ay*by;return out;}/**
   * Rotates a quaternion by the given angle about the Z axis
   *
   * @param {quat} out quat receiving operation result
   * @param {ReadonlyQuat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */function rotateZ(out,a,rad){rad*=0.5;var ax=a[0],ay=a[1],az=a[2],aw=a[3];var bz=Math.sin(rad),bw=Math.cos(rad);out[0]=ax*bw+ay*bz;out[1]=ay*bw-ax*bz;out[2]=az*bw+aw*bz;out[3]=aw*bw-az*bz;return out;}/**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate W component of
   * @returns {quat} out
   */function calculateW(out,a){var x=a[0],y=a[1],z=a[2];out[0]=x;out[1]=y;out[2]=z;out[3]=Math.sqrt(Math.abs(1.0-x*x-y*y-z*z));return out;}/**
   * Calculate the exponential of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate the exponential of
   * @returns {quat} out
   */function exp(out,a){var x=a[0],y=a[1],z=a[2],w=a[3];var r=Math.sqrt(x*x+y*y+z*z);var et=Math.exp(w);var s=r>0?et*Math.sin(r)/r:0;out[0]=x*s;out[1]=y*s;out[2]=z*s;out[3]=et*Math.cos(r);return out;}/**
   * Calculate the natural logarithm of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate the exponential of
   * @returns {quat} out
   */function ln(out,a){var x=a[0],y=a[1],z=a[2],w=a[3];var r=Math.sqrt(x*x+y*y+z*z);var t=r>0?Math.atan2(r,w)/r:0;out[0]=x*t;out[1]=y*t;out[2]=z*t;out[3]=0.5*Math.log(x*x+y*y+z*z+w*w);return out;}/**
   * Calculate the scalar power of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate the exponential of
   * @param {Number} b amount to scale the quaternion by
   * @returns {quat} out
   */function pow(out,a,b){ln(out,a);scale(out,out,b);exp(out,out);return out;}/**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */function slerp(out,a,b,t){// benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax=a[0],ay=a[1],az=a[2],aw=a[3];var bx=b[0],by=b[1],bz=b[2],bw=b[3];var omega,cosom,sinom,scale0,scale1;// calc cosine
  cosom=ax*bx+ay*by+az*bz+aw*bw;// adjust signs (if necessary)
  if(cosom<0.0){cosom=-cosom;bx=-bx;by=-by;bz=-bz;bw=-bw;}// calculate coefficients
  if(1.0-cosom>_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]){// standard case (slerp)
  omega=Math.acos(cosom);sinom=Math.sin(omega);scale0=Math.sin((1.0-t)*omega)/sinom;scale1=Math.sin(t*omega)/sinom;}else {// "from" and "to" quaternions are very close
  //  ... so we can do a linear interpolation
  scale0=1.0-t;scale1=t;}// calculate final values
  out[0]=scale0*ax+scale1*bx;out[1]=scale0*ay+scale1*by;out[2]=scale0*az+scale1*bz;out[3]=scale0*aw+scale1*bw;return out;}/**
   * Generates a random unit quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */function random(out){// Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();var u2=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();var u3=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();var sqrt1MinusU1=Math.sqrt(1-u1);var sqrtU1=Math.sqrt(u1);out[0]=sqrt1MinusU1*Math.sin(2.0*Math.PI*u2);out[1]=sqrt1MinusU1*Math.cos(2.0*Math.PI*u2);out[2]=sqrtU1*Math.sin(2.0*Math.PI*u3);out[3]=sqrtU1*Math.cos(2.0*Math.PI*u3);return out;}/**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate inverse of
   * @returns {quat} out
   */function invert(out,a){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];var dot=a0*a0+a1*a1+a2*a2+a3*a3;var invDot=dot?1.0/dot:0;// TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
  out[0]=-a0*invDot;out[1]=-a1*invDot;out[2]=-a2*invDot;out[3]=a3*invDot;return out;}/**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate conjugate of
   * @returns {quat} out
   */function conjugate(out,a){out[0]=-a[0];out[1]=-a[1];out[2]=-a[2];out[3]=a[3];return out;}/**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyMat3} m rotation matrix
   * @returns {quat} out
   * @function
   */function fromMat3(out,m){// Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace=m[0]+m[4]+m[8];var fRoot;if(fTrace>0.0){// |w| > 1/2, may as well choose w > 1/2
  fRoot=Math.sqrt(fTrace+1.0);// 2w
  out[3]=0.5*fRoot;fRoot=0.5/fRoot;// 1/(4w)
  out[0]=(m[5]-m[7])*fRoot;out[1]=(m[6]-m[2])*fRoot;out[2]=(m[1]-m[3])*fRoot;}else {// |w| <= 1/2
  var i=0;if(m[4]>m[0])i=1;if(m[8]>m[i*3+i])i=2;var j=(i+1)%3;var k=(i+2)%3;fRoot=Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k]+1.0);out[i]=0.5*fRoot;fRoot=0.5/fRoot;out[3]=(m[j*3+k]-m[k*3+j])*fRoot;out[j]=(m[j*3+i]+m[i*3+j])*fRoot;out[k]=(m[k*3+i]+m[i*3+k])*fRoot;}return out;}/**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */function fromEuler(out,x,y,z){var halfToRad=0.5*Math.PI/180.0;x*=halfToRad;y*=halfToRad;z*=halfToRad;var sx=Math.sin(x);var cx=Math.cos(x);var sy=Math.sin(y);var cy=Math.cos(y);var sz=Math.sin(z);var cz=Math.cos(z);out[0]=sx*cy*cz-cx*sy*sz;out[1]=cx*sy*cz+sx*cy*sz;out[2]=cx*cy*sz-sx*sy*cz;out[3]=cx*cy*cz+sx*sy*sz;return out;}/**
   * Returns a string representation of a quatenion
   *
   * @param {ReadonlyQuat} a vector to represent as a string
   * @returns {String} string representation of the vector
   */function str(a){return "quat("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")";}/**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {ReadonlyQuat} a quaternion to clone
   * @returns {quat} a new quaternion
   * @function
   */var clone=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];/**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */var fromValues=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];/**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the source quaternion
   * @returns {quat} out
   * @function
   */var copy=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];/**
   * Set the components of a quat to the given values
   *
   * @param {quat} out the receiving quaternion
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} out
   * @function
   */var set=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];/**
   * Adds two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {quat} out
   * @function
   */var add=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];/**
   * Alias for {@link quat.multiply}
   * @function
   */var mul=multiply;/**
   * Scales a quat by a scalar number
   *
   * @param {quat} out the receiving vector
   * @param {ReadonlyQuat} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {quat} out
   * @function
   */var scale=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];/**
   * Calculates the dot product of two quat's
   *
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */var dot=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];/**
   * Performs a linear interpolation between two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   * @function
   */var lerp=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];/**
   * Calculates the length of a quat
   *
   * @param {ReadonlyQuat} a vector to calculate length of
   * @returns {Number} length of a
   */var length=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];/**
   * Alias for {@link quat.length}
   * @function
   */var len=length;/**
   * Calculates the squared length of a quat
   *
   * @param {ReadonlyQuat} a vector to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */var squaredLength=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];/**
   * Alias for {@link quat.squaredLength}
   * @function
   */var sqrLen=squaredLength;/**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */var normalize=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];/**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyQuat} a The first quaternion.
   * @param {ReadonlyQuat} b The second quaternion.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */var exactEquals=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];/**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   *
   * @param {ReadonlyQuat} a The first vector.
   * @param {ReadonlyQuat} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */var equals=_vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];/**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {ReadonlyVec3} a the initial vector
   * @param {ReadonlyVec3} b the destination vector
   * @returns {quat} out
   */var rotationTo=function(){var tmpvec3=_vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();var xUnitVec3=_vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1,0,0);var yUnitVec3=_vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0,1,0);return function(out,a,b){var dot=_vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a,b);if(dot<-0.999999){_vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3,xUnitVec3,a);if(_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3)<0.000001)_vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3,yUnitVec3,a);_vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3,tmpvec3);setAxisAngle(out,tmpvec3,Math.PI);return out;}else if(dot>0.999999){out[0]=0;out[1]=0;out[2]=0;out[3]=1;return out;}else {_vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3,a,b);out[0]=tmpvec3[0];out[1]=tmpvec3[1];out[2]=tmpvec3[2];out[3]=1+dot;return normalize(out,out);}};}();/**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {ReadonlyQuat} c the third operand
   * @param {ReadonlyQuat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */var sqlerp=function(){var temp1=create();var temp2=create();return function(out,a,b,c,d,t){slerp(temp1,a,d,t);slerp(temp2,b,c,t);slerp(out,temp1,temp2,2*t*(1-t));return out;};}();/**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {ReadonlyVec3} view  the vector representing the viewing direction
   * @param {ReadonlyVec3} right the vector representing the local "right" direction
   * @param {ReadonlyVec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */var setAxes=function(){var matr=_mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();return function(out,view,right,up){matr[0]=right[0];matr[3]=right[1];matr[6]=right[2];matr[1]=up[0];matr[4]=up[1];matr[7]=up[2];matr[2]=-view[0];matr[5]=-view[1];matr[8]=-view[2];return normalize(out,fromMat3(out,matr));};}();/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"length",function(){return length;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"subtract",function(){return subtract;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"divide",function(){return divide;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"ceil",function(){return ceil;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"floor",function(){return floor;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"min",function(){return min;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"max",function(){return max;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"round",function(){return round;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scaleAndAdd",function(){return scaleAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"distance",function(){return distance;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredDistance",function(){return squaredDistance;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredLength",function(){return squaredLength;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"negate",function(){return negate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"inverse",function(){return inverse;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normalize",function(){return normalize;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dot",function(){return dot;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"cross",function(){return cross;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"lerp",function(){return lerp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"hermite",function(){return hermite;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"bezier",function(){return bezier;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"random",function(){return random;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformMat4",function(){return transformMat4;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformMat3",function(){return transformMat3;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformQuat",function(){return transformQuat;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateX",function(){return rotateX;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateY",function(){return rotateY;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateZ",function(){return rotateZ;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"angle",function(){return angle;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"zero",function(){return zero;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"div",function(){return div;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dist",function(){return dist;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrDist",function(){return sqrDist;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"len",function(){return len;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrLen",function(){return sqrLen;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"forEach",function(){return forEach;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/**
   * 3 Dimensional Vector
   * @module vec3
   */ /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[0]=0;out[1]=0;out[2]=0;}return out;}/**
   * Creates a new vec3 initialized with values from an existing vector
   *
   * @param {ReadonlyVec3} a vector to clone
   * @returns {vec3} a new 3D vector
   */function clone(a){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);out[0]=a[0];out[1]=a[1];out[2]=a[2];return out;}/**
   * Calculates the length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate length of
   * @returns {Number} length of a
   */function length(a){var x=a[0];var y=a[1];var z=a[2];return Math.hypot(x,y,z);}/**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */function fromValues(x,y,z){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);out[0]=x;out[1]=y;out[2]=z;return out;}/**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the source vector
   * @returns {vec3} out
   */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];return out;}/**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */function set(out,x,y,z){out[0]=x;out[1]=y;out[2]=z;return out;}/**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];return out;}/**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];return out;}/**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */function multiply(out,a,b){out[0]=a[0]*b[0];out[1]=a[1]*b[1];out[2]=a[2]*b[2];return out;}/**
   * Divides two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */function divide(out,a,b){out[0]=a[0]/b[0];out[1]=a[1]/b[1];out[2]=a[2]/b[2];return out;}/**
   * Math.ceil the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to ceil
   * @returns {vec3} out
   */function ceil(out,a){out[0]=Math.ceil(a[0]);out[1]=Math.ceil(a[1]);out[2]=Math.ceil(a[2]);return out;}/**
   * Math.floor the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to floor
   * @returns {vec3} out
   */function floor(out,a){out[0]=Math.floor(a[0]);out[1]=Math.floor(a[1]);out[2]=Math.floor(a[2]);return out;}/**
   * Returns the minimum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */function min(out,a,b){out[0]=Math.min(a[0],b[0]);out[1]=Math.min(a[1],b[1]);out[2]=Math.min(a[2],b[2]);return out;}/**
   * Returns the maximum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */function max(out,a,b){out[0]=Math.max(a[0],b[0]);out[1]=Math.max(a[1],b[1]);out[2]=Math.max(a[2],b[2]);return out;}/**
   * Math.round the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to round
   * @returns {vec3} out
   */function round(out,a){out[0]=Math.round(a[0]);out[1]=Math.round(a[1]);out[2]=Math.round(a[2]);return out;}/**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */function scale(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;return out;}/**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */function scaleAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;return out;}/**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} distance between a and b
   */function distance(a,b){var x=b[0]-a[0];var y=b[1]-a[1];var z=b[2]-a[2];return Math.hypot(x,y,z);}/**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} squared distance between a and b
   */function squaredDistance(a,b){var x=b[0]-a[0];var y=b[1]-a[1];var z=b[2]-a[2];return x*x+y*y+z*z;}/**
   * Calculates the squared length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */function squaredLength(a){var x=a[0];var y=a[1];var z=a[2];return x*x+y*y+z*z;}/**
   * Negates the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to negate
   * @returns {vec3} out
   */function negate(out,a){out[0]=-a[0];out[1]=-a[1];out[2]=-a[2];return out;}/**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to invert
   * @returns {vec3} out
   */function inverse(out,a){out[0]=1.0/a[0];out[1]=1.0/a[1];out[2]=1.0/a[2];return out;}/**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to normalize
   * @returns {vec3} out
   */function normalize(out,a){var x=a[0];var y=a[1];var z=a[2];var len=x*x+y*y+z*z;if(len>0){//TODO: evaluate use of glm_invsqrt here?
  len=1/Math.sqrt(len);}out[0]=a[0]*len;out[1]=a[1]*len;out[2]=a[2]*len;return out;}/**
   * Calculates the dot product of two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} dot product of a and b
   */function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}/**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */function cross(out,a,b){var ax=a[0],ay=a[1],az=a[2];var bx=b[0],by=b[1],bz=b[2];out[0]=ay*bz-az*by;out[1]=az*bx-ax*bz;out[2]=ax*by-ay*bx;return out;}/**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */function lerp(out,a,b,t){var ax=a[0];var ay=a[1];var az=a[2];out[0]=ax+t*(b[0]-ax);out[1]=ay+t*(b[1]-ay);out[2]=az+t*(b[2]-az);return out;}/**
   * Performs a hermite interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {ReadonlyVec3} c the third operand
   * @param {ReadonlyVec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */function hermite(out,a,b,c,d,t){var factorTimes2=t*t;var factor1=factorTimes2*(2*t-3)+1;var factor2=factorTimes2*(t-2)+t;var factor3=factorTimes2*(t-1);var factor4=factorTimes2*(3-2*t);out[0]=a[0]*factor1+b[0]*factor2+c[0]*factor3+d[0]*factor4;out[1]=a[1]*factor1+b[1]*factor2+c[1]*factor3+d[1]*factor4;out[2]=a[2]*factor1+b[2]*factor2+c[2]*factor3+d[2]*factor4;return out;}/**
   * Performs a bezier interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {ReadonlyVec3} c the third operand
   * @param {ReadonlyVec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */function bezier(out,a,b,c,d,t){var inverseFactor=1-t;var inverseFactorTimesTwo=inverseFactor*inverseFactor;var factorTimes2=t*t;var factor1=inverseFactorTimesTwo*inverseFactor;var factor2=3*t*inverseFactorTimesTwo;var factor3=3*factorTimes2*inverseFactor;var factor4=factorTimes2*t;out[0]=a[0]*factor1+b[0]*factor2+c[0]*factor3+d[0]*factor4;out[1]=a[1]*factor1+b[1]*factor2+c[1]*factor3+d[1]*factor4;out[2]=a[2]*factor1+b[2]*factor2+c[2]*factor3+d[2]*factor4;return out;}/**
   * Generates a random vector with the given scale
   *
   * @param {vec3} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec3} out
   */function random(out,scale){scale=scale||1.0;var r=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]()*2.0*Math.PI;var z=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]()*2.0-1.0;var zScale=Math.sqrt(1.0-z*z)*scale;out[0]=Math.cos(r)*zScale;out[1]=Math.sin(r)*zScale;out[2]=z*scale;return out;}/**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec3} out
   */function transformMat4(out,a,m){var x=a[0],y=a[1],z=a[2];var w=m[3]*x+m[7]*y+m[11]*z+m[15];w=w||1.0;out[0]=(m[0]*x+m[4]*y+m[8]*z+m[12])/w;out[1]=(m[1]*x+m[5]*y+m[9]*z+m[13])/w;out[2]=(m[2]*x+m[6]*y+m[10]*z+m[14])/w;return out;}/**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */function transformMat3(out,a,m){var x=a[0],y=a[1],z=a[2];out[0]=x*m[0]+y*m[3]+z*m[6];out[1]=x*m[1]+y*m[4]+z*m[7];out[2]=x*m[2]+y*m[5]+z*m[8];return out;}/**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyQuat} q quaternion to transform with
   * @returns {vec3} out
   */function transformQuat(out,a,q){// benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx=q[0],qy=q[1],qz=q[2],qw=q[3];var x=a[0],y=a[1],z=a[2];// var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);
  var uvx=qy*z-qz*y,uvy=qz*x-qx*z,uvz=qx*y-qy*x;// var uuv = vec3.cross([], qvec, uv);
  var uuvx=qy*uvz-qz*uvy,uuvy=qz*uvx-qx*uvz,uuvz=qx*uvy-qy*uvx;// vec3.scale(uv, uv, 2 * w);
  var w2=qw*2;uvx*=w2;uvy*=w2;uvz*=w2;// vec3.scale(uuv, uuv, 2);
  uuvx*=2;uuvy*=2;uuvz*=2;// return vec3.add(out, a, vec3.add(out, uv, uuv));
  out[0]=x+uvx+uuvx;out[1]=y+uvy+uuvy;out[2]=z+uvz+uuvz;return out;}/**
   * Rotate a 3D vector around the x-axis
   * @param {vec3} out The receiving vec3
   * @param {ReadonlyVec3} a The vec3 point to rotate
   * @param {ReadonlyVec3} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec3} out
   */function rotateX(out,a,b,rad){var p=[],r=[];//Translate point to the origin
  p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];//perform rotation
  r[0]=p[0];r[1]=p[1]*Math.cos(rad)-p[2]*Math.sin(rad);r[2]=p[1]*Math.sin(rad)+p[2]*Math.cos(rad);//translate to correct position
  out[0]=r[0]+b[0];out[1]=r[1]+b[1];out[2]=r[2]+b[2];return out;}/**
   * Rotate a 3D vector around the y-axis
   * @param {vec3} out The receiving vec3
   * @param {ReadonlyVec3} a The vec3 point to rotate
   * @param {ReadonlyVec3} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec3} out
   */function rotateY(out,a,b,rad){var p=[],r=[];//Translate point to the origin
  p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];//perform rotation
  r[0]=p[2]*Math.sin(rad)+p[0]*Math.cos(rad);r[1]=p[1];r[2]=p[2]*Math.cos(rad)-p[0]*Math.sin(rad);//translate to correct position
  out[0]=r[0]+b[0];out[1]=r[1]+b[1];out[2]=r[2]+b[2];return out;}/**
   * Rotate a 3D vector around the z-axis
   * @param {vec3} out The receiving vec3
   * @param {ReadonlyVec3} a The vec3 point to rotate
   * @param {ReadonlyVec3} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec3} out
   */function rotateZ(out,a,b,rad){var p=[],r=[];//Translate point to the origin
  p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];//perform rotation
  r[0]=p[0]*Math.cos(rad)-p[1]*Math.sin(rad);r[1]=p[0]*Math.sin(rad)+p[1]*Math.cos(rad);r[2]=p[2];//translate to correct position
  out[0]=r[0]+b[0];out[1]=r[1]+b[1];out[2]=r[2]+b[2];return out;}/**
   * Get the angle between two 3D vectors
   * @param {ReadonlyVec3} a The first operand
   * @param {ReadonlyVec3} b The second operand
   * @returns {Number} The angle in radians
   */function angle(a,b){var ax=a[0],ay=a[1],az=a[2],bx=b[0],by=b[1],bz=b[2],mag1=Math.sqrt(ax*ax+ay*ay+az*az),mag2=Math.sqrt(bx*bx+by*by+bz*bz),mag=mag1*mag2,cosine=mag&&dot(a,b)/mag;return Math.acos(Math.min(Math.max(cosine,-1),1));}/**
   * Set the components of a vec3 to zero
   *
   * @param {vec3} out the receiving vector
   * @returns {vec3} out
   */function zero(out){out[0]=0.0;out[1]=0.0;out[2]=0.0;return out;}/**
   * Returns a string representation of a vector
   *
   * @param {ReadonlyVec3} a vector to represent as a string
   * @returns {String} string representation of the vector
   */function str(a){return "vec3("+a[0]+", "+a[1]+", "+a[2]+")";}/**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2];}/**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1],a2=a[2];var b0=b[0],b1=b[1],b2=b[2];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a2),Math.abs(b2));}/**
   * Alias for {@link vec3.subtract}
   * @function
   */var sub=subtract;/**
   * Alias for {@link vec3.multiply}
   * @function
   */var mul=multiply;/**
   * Alias for {@link vec3.divide}
   * @function
   */var div=divide;/**
   * Alias for {@link vec3.distance}
   * @function
   */var dist=distance;/**
   * Alias for {@link vec3.squaredDistance}
   * @function
   */var sqrDist=squaredDistance;/**
   * Alias for {@link vec3.length}
   * @function
   */var len=length;/**
   * Alias for {@link vec3.squaredLength}
   * @function
   */var sqrLen=squaredLength;/**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */var forEach=function(){var vec=create();return function(a,stride,offset,count,fn,arg){var i,l;if(!stride){stride=3;}if(!offset){offset=0;}if(count){l=Math.min(count*stride+offset,a.length);}else {l=a.length;}for(i=offset;i<l;i+=stride){vec[0]=a[i];vec[1]=a[i+1];vec[2]=a[i+2];fn(vec,vec,arg);a[i]=vec[0];a[i+1]=vec[1];a[i+2]=vec[2];}return a;};}();/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"subtract",function(){return subtract;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"divide",function(){return divide;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"ceil",function(){return ceil;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"floor",function(){return floor;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"min",function(){return min;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"max",function(){return max;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"round",function(){return round;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scaleAndAdd",function(){return scaleAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"distance",function(){return distance;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredDistance",function(){return squaredDistance;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"length",function(){return length;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredLength",function(){return squaredLength;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"negate",function(){return negate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"inverse",function(){return inverse;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normalize",function(){return normalize;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dot",function(){return dot;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"cross",function(){return cross;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"lerp",function(){return lerp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"random",function(){return random;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformMat4",function(){return transformMat4;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformQuat",function(){return transformQuat;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"zero",function(){return zero;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"div",function(){return div;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dist",function(){return dist;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrDist",function(){return sqrDist;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"len",function(){return len;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrLen",function(){return sqrLen;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"forEach",function(){return forEach;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/**
   * 4 Dimensional Vector
   * @module vec4
   */ /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[0]=0;out[1]=0;out[2]=0;out[3]=0;}return out;}/**
   * Creates a new vec4 initialized with values from an existing vector
   *
   * @param {ReadonlyVec4} a vector to clone
   * @returns {vec4} a new 4D vector
   */function clone(a){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];return out;}/**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */function fromValues(x,y,z,w){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);out[0]=x;out[1]=y;out[2]=z;out[3]=w;return out;}/**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the source vector
   * @returns {vec4} out
   */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];return out;}/**
   * Set the components of a vec4 to the given values
   *
   * @param {vec4} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} out
   */function set(out,x,y,z,w){out[0]=x;out[1]=y;out[2]=z;out[3]=w;return out;}/**
   * Adds two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];out[3]=a[3]+b[3];return out;}/**
   * Subtracts vector b from vector a
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];out[3]=a[3]-b[3];return out;}/**
   * Multiplies two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */function multiply(out,a,b){out[0]=a[0]*b[0];out[1]=a[1]*b[1];out[2]=a[2]*b[2];out[3]=a[3]*b[3];return out;}/**
   * Divides two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */function divide(out,a,b){out[0]=a[0]/b[0];out[1]=a[1]/b[1];out[2]=a[2]/b[2];out[3]=a[3]/b[3];return out;}/**
   * Math.ceil the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to ceil
   * @returns {vec4} out
   */function ceil(out,a){out[0]=Math.ceil(a[0]);out[1]=Math.ceil(a[1]);out[2]=Math.ceil(a[2]);out[3]=Math.ceil(a[3]);return out;}/**
   * Math.floor the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to floor
   * @returns {vec4} out
   */function floor(out,a){out[0]=Math.floor(a[0]);out[1]=Math.floor(a[1]);out[2]=Math.floor(a[2]);out[3]=Math.floor(a[3]);return out;}/**
   * Returns the minimum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */function min(out,a,b){out[0]=Math.min(a[0],b[0]);out[1]=Math.min(a[1],b[1]);out[2]=Math.min(a[2],b[2]);out[3]=Math.min(a[3],b[3]);return out;}/**
   * Returns the maximum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */function max(out,a,b){out[0]=Math.max(a[0],b[0]);out[1]=Math.max(a[1],b[1]);out[2]=Math.max(a[2],b[2]);out[3]=Math.max(a[3],b[3]);return out;}/**
   * Math.round the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to round
   * @returns {vec4} out
   */function round(out,a){out[0]=Math.round(a[0]);out[1]=Math.round(a[1]);out[2]=Math.round(a[2]);out[3]=Math.round(a[3]);return out;}/**
   * Scales a vec4 by a scalar number
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec4} out
   */function scale(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;out[3]=a[3]*b;return out;}/**
   * Adds two vec4's after scaling the second operand by a scalar value
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec4} out
   */function scaleAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;out[3]=a[3]+b[3]*scale;return out;}/**
   * Calculates the euclidian distance between two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} distance between a and b
   */function distance(a,b){var x=b[0]-a[0];var y=b[1]-a[1];var z=b[2]-a[2];var w=b[3]-a[3];return Math.hypot(x,y,z,w);}/**
   * Calculates the squared euclidian distance between two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} squared distance between a and b
   */function squaredDistance(a,b){var x=b[0]-a[0];var y=b[1]-a[1];var z=b[2]-a[2];var w=b[3]-a[3];return x*x+y*y+z*z+w*w;}/**
   * Calculates the length of a vec4
   *
   * @param {ReadonlyVec4} a vector to calculate length of
   * @returns {Number} length of a
   */function length(a){var x=a[0];var y=a[1];var z=a[2];var w=a[3];return Math.hypot(x,y,z,w);}/**
   * Calculates the squared length of a vec4
   *
   * @param {ReadonlyVec4} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */function squaredLength(a){var x=a[0];var y=a[1];var z=a[2];var w=a[3];return x*x+y*y+z*z+w*w;}/**
   * Negates the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to negate
   * @returns {vec4} out
   */function negate(out,a){out[0]=-a[0];out[1]=-a[1];out[2]=-a[2];out[3]=-a[3];return out;}/**
   * Returns the inverse of the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to invert
   * @returns {vec4} out
   */function inverse(out,a){out[0]=1.0/a[0];out[1]=1.0/a[1];out[2]=1.0/a[2];out[3]=1.0/a[3];return out;}/**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to normalize
   * @returns {vec4} out
   */function normalize(out,a){var x=a[0];var y=a[1];var z=a[2];var w=a[3];var len=x*x+y*y+z*z+w*w;if(len>0){len=1/Math.sqrt(len);}out[0]=x*len;out[1]=y*len;out[2]=z*len;out[3]=w*len;return out;}/**
   * Calculates the dot product of two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} dot product of a and b
   */function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3];}/**
   * Returns the cross-product of three vectors in a 4-dimensional space
   *
   * @param {ReadonlyVec4} result the receiving vector
   * @param {ReadonlyVec4} U the first vector
   * @param {ReadonlyVec4} V the second vector
   * @param {ReadonlyVec4} W the third vector
   * @returns {vec4} result
   */function cross(out,u,v,w){var A=v[0]*w[1]-v[1]*w[0],B=v[0]*w[2]-v[2]*w[0],C=v[0]*w[3]-v[3]*w[0],D=v[1]*w[2]-v[2]*w[1],E=v[1]*w[3]-v[3]*w[1],F=v[2]*w[3]-v[3]*w[2];var G=u[0];var H=u[1];var I=u[2];var J=u[3];out[0]=H*F-I*E+J*D;out[1]=-(G*F)+I*C-J*B;out[2]=G*E-H*C+J*A;out[3]=-(G*D)+H*B-I*A;return out;}/**
   * Performs a linear interpolation between two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec4} out
   */function lerp(out,a,b,t){var ax=a[0];var ay=a[1];var az=a[2];var aw=a[3];out[0]=ax+t*(b[0]-ax);out[1]=ay+t*(b[1]-ay);out[2]=az+t*(b[2]-az);out[3]=aw+t*(b[3]-aw);return out;}/**
   * Generates a random vector with the given scale
   *
   * @param {vec4} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec4} out
   */function random(out,scale){scale=scale||1.0;// Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;
  var v1,v2,v3,v4;var s1,s2;do{v1=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]()*2-1;v2=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]()*2-1;s1=v1*v1+v2*v2;}while(s1>=1);do{v3=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]()*2-1;v4=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]()*2-1;s2=v3*v3+v4*v4;}while(s2>=1);var d=Math.sqrt((1-s1)/s2);out[0]=scale*v1;out[1]=scale*v2;out[2]=scale*v3*d;out[3]=scale*v4*d;return out;}/**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec4} out
   */function transformMat4(out,a,m){var x=a[0],y=a[1],z=a[2],w=a[3];out[0]=m[0]*x+m[4]*y+m[8]*z+m[12]*w;out[1]=m[1]*x+m[5]*y+m[9]*z+m[13]*w;out[2]=m[2]*x+m[6]*y+m[10]*z+m[14]*w;out[3]=m[3]*x+m[7]*y+m[11]*z+m[15]*w;return out;}/**
   * Transforms the vec4 with a quat
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyQuat} q quaternion to transform with
   * @returns {vec4} out
   */function transformQuat(out,a,q){var x=a[0],y=a[1],z=a[2];var qx=q[0],qy=q[1],qz=q[2],qw=q[3];// calculate quat * vec
  var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
  out[0]=ix*qw+iw*-qx+iy*-qz-iz*-qy;out[1]=iy*qw+iw*-qy+iz*-qx-ix*-qz;out[2]=iz*qw+iw*-qz+ix*-qy-iy*-qx;out[3]=a[3];return out;}/**
   * Set the components of a vec4 to zero
   *
   * @param {vec4} out the receiving vector
   * @returns {vec4} out
   */function zero(out){out[0]=0.0;out[1]=0.0;out[2]=0.0;out[3]=0.0;return out;}/**
   * Returns a string representation of a vector
   *
   * @param {ReadonlyVec4} a vector to represent as a string
   * @returns {String} string representation of the vector
   */function str(a){return "vec4("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")";}/**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec4} a The first vector.
   * @param {ReadonlyVec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3];}/**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec4} a The first vector.
   * @param {ReadonlyVec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3];var b0=b[0],b1=b[1],b2=b[2],b3=b[3];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a3),Math.abs(b3));}/**
   * Alias for {@link vec4.subtract}
   * @function
   */var sub=subtract;/**
   * Alias for {@link vec4.multiply}
   * @function
   */var mul=multiply;/**
   * Alias for {@link vec4.divide}
   * @function
   */var div=divide;/**
   * Alias for {@link vec4.distance}
   * @function
   */var dist=distance;/**
   * Alias for {@link vec4.squaredDistance}
   * @function
   */var sqrDist=squaredDistance;/**
   * Alias for {@link vec4.length}
   * @function
   */var len=length;/**
   * Alias for {@link vec4.squaredLength}
   * @function
   */var sqrLen=squaredLength;/**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */var forEach=function(){var vec=create();return function(a,stride,offset,count,fn,arg){var i,l;if(!stride){stride=4;}if(!offset){offset=0;}if(count){l=Math.min(count*stride+offset,a.length);}else {l=a.length;}for(i=offset;i<l;i+=stride){vec[0]=a[i];vec[1]=a[i+1];vec[2]=a[i+2];vec[3]=a[i+3];fn(vec,vec,arg);a[i]=vec[0];a[i+1]=vec[1];a[i+2]=vec[2];a[i+3]=vec[3];}return a;};}();/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotationTranslationValues",function(){return fromRotationTranslationValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotationTranslation",function(){return fromRotationTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromTranslation",function(){return fromTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromRotation",function(){return fromRotation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromMat4",function(){return fromMat4;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"identity",function(){return identity;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getReal",function(){return getReal;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getDual",function(){return getDual;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"setReal",function(){return setReal;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"setDual",function(){return setDual;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getTranslation",function(){return getTranslation;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"translate",function(){return translate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateX",function(){return rotateX;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateY",function(){return rotateY;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateZ",function(){return rotateZ;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateByQuatAppend",function(){return rotateByQuatAppend;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateByQuatPrepend",function(){return rotateByQuatPrepend;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotateAroundAxis",function(){return rotateAroundAxis;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dot",function(){return dot;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"lerp",function(){return lerp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"invert",function(){return invert;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"conjugate",function(){return conjugate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"length",function(){return length;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"len",function(){return len;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredLength",function(){return squaredLength;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrLen",function(){return sqrLen;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normalize",function(){return normalize;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/* harmony import */var _quat_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(7);/* harmony import */var _mat4_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(6);/**
   * Dual Quaternion<br>
   * Format: [real, dual]<br>
   * Quaternion format: XYZW<br>
   * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
   * @module quat2
   */ /**
   * Creates a new identity dual quat
   *
   * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
   */function create(){var dq=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){dq[0]=0;dq[1]=0;dq[2]=0;dq[4]=0;dq[5]=0;dq[6]=0;dq[7]=0;}dq[3]=1;return dq;}/**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {ReadonlyQuat2} a dual quaternion to clone
   * @returns {quat2} new dual quaternion
   * @function
   */function clone(a){var dq=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);dq[0]=a[0];dq[1]=a[1];dq[2]=a[2];dq[3]=a[3];dq[4]=a[4];dq[5]=a[5];dq[6]=a[6];dq[7]=a[7];return dq;}/**
   * Creates a new dual quat initialized with the given values
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} new dual quaternion
   * @function
   */function fromValues(x1,y1,z1,w1,x2,y2,z2,w2){var dq=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);dq[0]=x1;dq[1]=y1;dq[2]=z1;dq[3]=w1;dq[4]=x2;dq[5]=y2;dq[6]=z2;dq[7]=w2;return dq;}/**
   * Creates a new dual quat from the given values (quat and translation)
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component (translation)
   * @param {Number} y2 Y component (translation)
   * @param {Number} z2 Z component (translation)
   * @returns {quat2} new dual quaternion
   * @function
   */function fromRotationTranslationValues(x1,y1,z1,w1,x2,y2,z2){var dq=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);dq[0]=x1;dq[1]=y1;dq[2]=z1;dq[3]=w1;var ax=x2*0.5,ay=y2*0.5,az=z2*0.5;dq[4]=ax*w1+ay*z1-az*y1;dq[5]=ay*w1+az*x1-ax*z1;dq[6]=az*w1+ax*y1-ay*x1;dq[7]=-ax*x1-ay*y1-az*z1;return dq;}/**
   * Creates a dual quat from a quaternion and a translation
   *
   * @param {ReadonlyQuat2} dual quaternion receiving operation result
   * @param {ReadonlyQuat} q a normalized quaternion
   * @param {ReadonlyVec3} t tranlation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */function fromRotationTranslation(out,q,t){var ax=t[0]*0.5,ay=t[1]*0.5,az=t[2]*0.5,bx=q[0],by=q[1],bz=q[2],bw=q[3];out[0]=bx;out[1]=by;out[2]=bz;out[3]=bw;out[4]=ax*bw+ay*bz-az*by;out[5]=ay*bw+az*bx-ax*bz;out[6]=az*bw+ax*by-ay*bx;out[7]=-ax*bx-ay*by-az*bz;return out;}/**
   * Creates a dual quat from a translation
   *
   * @param {ReadonlyQuat2} dual quaternion receiving operation result
   * @param {ReadonlyVec3} t translation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */function fromTranslation(out,t){out[0]=0;out[1]=0;out[2]=0;out[3]=1;out[4]=t[0]*0.5;out[5]=t[1]*0.5;out[6]=t[2]*0.5;out[7]=0;return out;}/**
   * Creates a dual quat from a quaternion
   *
   * @param {ReadonlyQuat2} dual quaternion receiving operation result
   * @param {ReadonlyQuat} q the quaternion
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */function fromRotation(out,q){out[0]=q[0];out[1]=q[1];out[2]=q[2];out[3]=q[3];out[4]=0;out[5]=0;out[6]=0;out[7]=0;return out;}/**
   * Creates a new dual quat from a matrix (4x4)
   *
   * @param {quat2} out the dual quaternion
   * @param {ReadonlyMat4} a the matrix
   * @returns {quat2} dual quat receiving operation result
   * @function
   */function fromMat4(out,a){//TODO Optimize this
  var outer=_quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();_mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer,a);var t=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);_mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t,a);fromRotationTranslation(out,outer,t);return out;}/**
   * Copy the values from one dual quat to another
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the source dual quaternion
   * @returns {quat2} out
   * @function
   */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];return out;}/**
   * Set a dual quat to the identity dual quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @returns {quat2} out
   */function identity(out){out[0]=0;out[1]=0;out[2]=0;out[3]=1;out[4]=0;out[5]=0;out[6]=0;out[7]=0;return out;}/**
   * Set the components of a dual quat to the given values
   *
   * @param {quat2} out the receiving quaternion
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} out
   * @function
   */function set(out,x1,y1,z1,w1,x2,y2,z2,w2){out[0]=x1;out[1]=y1;out[2]=z1;out[3]=w1;out[4]=x2;out[5]=y2;out[6]=z2;out[7]=w2;return out;}/**
   * Gets the real part of a dual quat
   * @param  {quat} out real part
   * @param  {ReadonlyQuat2} a Dual Quaternion
   * @return {quat} real part
   */var getReal=_quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];/**
   * Gets the dual part of a dual quat
   * @param  {quat} out dual part
   * @param  {ReadonlyQuat2} a Dual Quaternion
   * @return {quat} dual part
   */function getDual(out,a){out[0]=a[4];out[1]=a[5];out[2]=a[6];out[3]=a[7];return out;}/**
   * Set the real component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {ReadonlyQuat} q a quaternion representing the real part
   * @returns {quat2} out
   * @function
   */var setReal=_quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];/**
   * Set the dual component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {ReadonlyQuat} q a quaternion representing the dual part
   * @returns {quat2} out
   * @function
   */function setDual(out,q){out[4]=q[0];out[5]=q[1];out[6]=q[2];out[7]=q[3];return out;}/**
   * Gets the translation of a normalized dual quat
   * @param  {vec3} out translation
   * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
   * @return {vec3} translation
   */function getTranslation(out,a){var ax=a[4],ay=a[5],az=a[6],aw=a[7],bx=-a[0],by=-a[1],bz=-a[2],bw=a[3];out[0]=(ax*bw+aw*bx+ay*bz-az*by)*2;out[1]=(ay*bw+aw*by+az*bx-ax*bz)*2;out[2]=(az*bw+aw*bz+ax*by-ay*bx)*2;return out;}/**
   * Translates a dual quat by the given vector
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to translate
   * @param {ReadonlyVec3} v vector to translate by
   * @returns {quat2} out
   */function translate(out,a,v){var ax1=a[0],ay1=a[1],az1=a[2],aw1=a[3],bx1=v[0]*0.5,by1=v[1]*0.5,bz1=v[2]*0.5,ax2=a[4],ay2=a[5],az2=a[6],aw2=a[7];out[0]=ax1;out[1]=ay1;out[2]=az1;out[3]=aw1;out[4]=aw1*bx1+ay1*bz1-az1*by1+ax2;out[5]=aw1*by1+az1*bx1-ax1*bz1+ay2;out[6]=aw1*bz1+ax1*by1-ay1*bx1+az2;out[7]=-ax1*bx1-ay1*by1-az1*bz1+aw2;return out;}/**
   * Rotates a dual quat around the X axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */function rotateX(out,a,rad){var bx=-a[0],by=-a[1],bz=-a[2],bw=a[3],ax=a[4],ay=a[5],az=a[6],aw=a[7],ax1=ax*bw+aw*bx+ay*bz-az*by,ay1=ay*bw+aw*by+az*bx-ax*bz,az1=az*bw+aw*bz+ax*by-ay*bx,aw1=aw*bw-ax*bx-ay*by-az*bz;_quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out,a,rad);bx=out[0];by=out[1];bz=out[2];bw=out[3];out[4]=ax1*bw+aw1*bx+ay1*bz-az1*by;out[5]=ay1*bw+aw1*by+az1*bx-ax1*bz;out[6]=az1*bw+aw1*bz+ax1*by-ay1*bx;out[7]=aw1*bw-ax1*bx-ay1*by-az1*bz;return out;}/**
   * Rotates a dual quat around the Y axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */function rotateY(out,a,rad){var bx=-a[0],by=-a[1],bz=-a[2],bw=a[3],ax=a[4],ay=a[5],az=a[6],aw=a[7],ax1=ax*bw+aw*bx+ay*bz-az*by,ay1=ay*bw+aw*by+az*bx-ax*bz,az1=az*bw+aw*bz+ax*by-ay*bx,aw1=aw*bw-ax*bx-ay*by-az*bz;_quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out,a,rad);bx=out[0];by=out[1];bz=out[2];bw=out[3];out[4]=ax1*bw+aw1*bx+ay1*bz-az1*by;out[5]=ay1*bw+aw1*by+az1*bx-ax1*bz;out[6]=az1*bw+aw1*bz+ax1*by-ay1*bx;out[7]=aw1*bw-ax1*bx-ay1*by-az1*bz;return out;}/**
   * Rotates a dual quat around the Z axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */function rotateZ(out,a,rad){var bx=-a[0],by=-a[1],bz=-a[2],bw=a[3],ax=a[4],ay=a[5],az=a[6],aw=a[7],ax1=ax*bw+aw*bx+ay*bz-az*by,ay1=ay*bw+aw*by+az*bx-ax*bz,az1=az*bw+aw*bz+ax*by-ay*bx,aw1=aw*bw-ax*bx-ay*by-az*bz;_quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out,a,rad);bx=out[0];by=out[1];bz=out[2];bw=out[3];out[4]=ax1*bw+aw1*bx+ay1*bz-az1*by;out[5]=ay1*bw+aw1*by+az1*bx-ax1*bz;out[6]=az1*bw+aw1*bz+ax1*by-ay1*bx;out[7]=aw1*bw-ax1*bx-ay1*by-az1*bz;return out;}/**
   * Rotates a dual quat by a given quaternion (a * q)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {ReadonlyQuat} q quaternion to rotate by
   * @returns {quat2} out
   */function rotateByQuatAppend(out,a,q){var qx=q[0],qy=q[1],qz=q[2],qw=q[3],ax=a[0],ay=a[1],az=a[2],aw=a[3];out[0]=ax*qw+aw*qx+ay*qz-az*qy;out[1]=ay*qw+aw*qy+az*qx-ax*qz;out[2]=az*qw+aw*qz+ax*qy-ay*qx;out[3]=aw*qw-ax*qx-ay*qy-az*qz;ax=a[4];ay=a[5];az=a[6];aw=a[7];out[4]=ax*qw+aw*qx+ay*qz-az*qy;out[5]=ay*qw+aw*qy+az*qx-ax*qz;out[6]=az*qw+aw*qz+ax*qy-ay*qx;out[7]=aw*qw-ax*qx-ay*qy-az*qz;return out;}/**
   * Rotates a dual quat by a given quaternion (q * a)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat} q quaternion to rotate by
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @returns {quat2} out
   */function rotateByQuatPrepend(out,q,a){var qx=q[0],qy=q[1],qz=q[2],qw=q[3],bx=a[0],by=a[1],bz=a[2],bw=a[3];out[0]=qx*bw+qw*bx+qy*bz-qz*by;out[1]=qy*bw+qw*by+qz*bx-qx*bz;out[2]=qz*bw+qw*bz+qx*by-qy*bx;out[3]=qw*bw-qx*bx-qy*by-qz*bz;bx=a[4];by=a[5];bz=a[6];bw=a[7];out[4]=qx*bw+qw*bx+qy*bz-qz*by;out[5]=qy*bw+qw*by+qz*bx-qx*bz;out[6]=qz*bw+qw*bz+qx*by-qy*bx;out[7]=qw*bw-qx*bx-qy*by-qz*bz;return out;}/**
   * Rotates a dual quat around a given axis. Does the normalisation automatically
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @param {Number} rad how far the rotation should be
   * @returns {quat2} out
   */function rotateAroundAxis(out,a,axis,rad){//Special case for rad = 0
  if(Math.abs(rad)<_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]){return copy(out,a);}var axisLength=Math.hypot(axis[0],axis[1],axis[2]);rad=rad*0.5;var s=Math.sin(rad);var bx=s*axis[0]/axisLength;var by=s*axis[1]/axisLength;var bz=s*axis[2]/axisLength;var bw=Math.cos(rad);var ax1=a[0],ay1=a[1],az1=a[2],aw1=a[3];out[0]=ax1*bw+aw1*bx+ay1*bz-az1*by;out[1]=ay1*bw+aw1*by+az1*bx-ax1*bz;out[2]=az1*bw+aw1*bz+ax1*by-ay1*bx;out[3]=aw1*bw-ax1*bx-ay1*by-az1*bz;var ax=a[4],ay=a[5],az=a[6],aw=a[7];out[4]=ax*bw+aw*bx+ay*bz-az*by;out[5]=ay*bw+aw*by+az*bx-ax*bz;out[6]=az*bw+aw*bz+ax*by-ay*bx;out[7]=aw*bw-ax*bx-ay*by-az*bz;return out;}/**
   * Adds two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @returns {quat2} out
   * @function
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];out[3]=a[3]+b[3];out[4]=a[4]+b[4];out[5]=a[5]+b[5];out[6]=a[6]+b[6];out[7]=a[7]+b[7];return out;}/**
   * Multiplies two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @returns {quat2} out
   */function multiply(out,a,b){var ax0=a[0],ay0=a[1],az0=a[2],aw0=a[3],bx1=b[4],by1=b[5],bz1=b[6],bw1=b[7],ax1=a[4],ay1=a[5],az1=a[6],aw1=a[7],bx0=b[0],by0=b[1],bz0=b[2],bw0=b[3];out[0]=ax0*bw0+aw0*bx0+ay0*bz0-az0*by0;out[1]=ay0*bw0+aw0*by0+az0*bx0-ax0*bz0;out[2]=az0*bw0+aw0*bz0+ax0*by0-ay0*bx0;out[3]=aw0*bw0-ax0*bx0-ay0*by0-az0*bz0;out[4]=ax0*bw1+aw0*bx1+ay0*bz1-az0*by1+ax1*bw0+aw1*bx0+ay1*bz0-az1*by0;out[5]=ay0*bw1+aw0*by1+az0*bx1-ax0*bz1+ay1*bw0+aw1*by0+az1*bx0-ax1*bz0;out[6]=az0*bw1+aw0*bz1+ax0*by1-ay0*bx1+az1*bw0+aw1*bz0+ax1*by0-ay1*bx0;out[7]=aw0*bw1-ax0*bx1-ay0*by1-az0*bz1+aw1*bw0-ax1*bx0-ay1*by0-az1*bz0;return out;}/**
   * Alias for {@link quat2.multiply}
   * @function
   */var mul=multiply;/**
   * Scales a dual quat by a scalar number
   *
   * @param {quat2} out the receiving dual quat
   * @param {ReadonlyQuat2} a the dual quat to scale
   * @param {Number} b amount to scale the dual quat by
   * @returns {quat2} out
   * @function
   */function scale(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;out[3]=a[3]*b;out[4]=a[4]*b;out[5]=a[5]*b;out[6]=a[6]*b;out[7]=a[7]*b;return out;}/**
   * Calculates the dot product of two dual quat's (The dot product of the real parts)
   *
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */var dot=_quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];/**
   * Performs a linear interpolation between two dual quats's
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
   *
   * @param {quat2} out the receiving dual quat
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat2} out
   */function lerp(out,a,b,t){var mt=1-t;if(dot(a,b)<0)t=-t;out[0]=a[0]*mt+b[0]*t;out[1]=a[1]*mt+b[1]*t;out[2]=a[2]*mt+b[2]*t;out[3]=a[3]*mt+b[3]*t;out[4]=a[4]*mt+b[4]*t;out[5]=a[5]*mt+b[5]*t;out[6]=a[6]*mt+b[6]*t;out[7]=a[7]*mt+b[7]*t;return out;}/**
   * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a dual quat to calculate inverse of
   * @returns {quat2} out
   */function invert(out,a){var sqlen=squaredLength(a);out[0]=-a[0]/sqlen;out[1]=-a[1]/sqlen;out[2]=-a[2]/sqlen;out[3]=a[3]/sqlen;out[4]=-a[4]/sqlen;out[5]=-a[5]/sqlen;out[6]=-a[6]/sqlen;out[7]=a[7]/sqlen;return out;}/**
   * Calculates the conjugate of a dual quat
   * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
   *
   * @param {quat2} out the receiving quaternion
   * @param {ReadonlyQuat2} a quat to calculate conjugate of
   * @returns {quat2} out
   */function conjugate(out,a){out[0]=-a[0];out[1]=-a[1];out[2]=-a[2];out[3]=a[3];out[4]=-a[4];out[5]=-a[5];out[6]=-a[6];out[7]=a[7];return out;}/**
   * Calculates the length of a dual quat
   *
   * @param {ReadonlyQuat2} a dual quat to calculate length of
   * @returns {Number} length of a
   * @function
   */var length=_quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];/**
   * Alias for {@link quat2.length}
   * @function
   */var len=length;/**
   * Calculates the squared length of a dual quat
   *
   * @param {ReadonlyQuat2} a dual quat to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */var squaredLength=_quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];/**
   * Alias for {@link quat2.squaredLength}
   * @function
   */var sqrLen=squaredLength;/**
   * Normalize a dual quat
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a dual quaternion to normalize
   * @returns {quat2} out
   * @function
   */function normalize(out,a){var magnitude=squaredLength(a);if(magnitude>0){magnitude=Math.sqrt(magnitude);var a0=a[0]/magnitude;var a1=a[1]/magnitude;var a2=a[2]/magnitude;var a3=a[3]/magnitude;var b0=a[4];var b1=a[5];var b2=a[6];var b3=a[7];var a_dot_b=a0*b0+a1*b1+a2*b2+a3*b3;out[0]=a0;out[1]=a1;out[2]=a2;out[3]=a3;out[4]=(b0-a0*a_dot_b)/magnitude;out[5]=(b1-a1*a_dot_b)/magnitude;out[6]=(b2-a2*a_dot_b)/magnitude;out[7]=(b3-a3*a_dot_b)/magnitude;}return out;}/**
   * Returns a string representation of a dual quatenion
   *
   * @param {ReadonlyQuat2} a dual quaternion to represent as a string
   * @returns {String} string representation of the dual quat
   */function str(a){return "quat2("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+")";}/**
   * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyQuat2} a the first dual quaternion.
   * @param {ReadonlyQuat2} b the second dual quaternion.
   * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&a[4]===b[4]&&a[5]===b[5]&&a[6]===b[6]&&a[7]===b[7];}/**
   * Returns whether or not the dual quaternions have approximately the same elements in the same position.
   *
   * @param {ReadonlyQuat2} a the first dual quat.
   * @param {ReadonlyQuat2} b the second dual quat.
   * @returns {Boolean} true if the dual quats are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],a6=a[6],a7=a[7];var b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5],b6=b[6],b7=b[7];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a3),Math.abs(b3))&&Math.abs(a4-b4)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a4),Math.abs(b4))&&Math.abs(a5-b5)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a5),Math.abs(b5))&&Math.abs(a6-b6)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a6),Math.abs(b6))&&Math.abs(a7-b7)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a7),Math.abs(b7));}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fromValues",function(){return fromValues;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"set",function(){return set;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"subtract",function(){return subtract;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"divide",function(){return divide;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"ceil",function(){return ceil;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"floor",function(){return floor;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"min",function(){return min;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"max",function(){return max;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"round",function(){return round;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scale",function(){return scale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scaleAndAdd",function(){return scaleAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"distance",function(){return distance;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredDistance",function(){return squaredDistance;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"length",function(){return length;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"squaredLength",function(){return squaredLength;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"negate",function(){return negate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"inverse",function(){return inverse;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normalize",function(){return normalize;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dot",function(){return dot;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"cross",function(){return cross;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"lerp",function(){return lerp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"random",function(){return random;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformMat2",function(){return transformMat2;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformMat2d",function(){return transformMat2d;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformMat3",function(){return transformMat3;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformMat4",function(){return transformMat4;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotate",function(){return rotate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"angle",function(){return angle;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"zero",function(){return zero;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"str",function(){return str;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"exactEquals",function(){return exactEquals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"equals",function(){return equals;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"len",function(){return len;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mul",function(){return mul;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"div",function(){return div;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dist",function(){return dist;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrDist",function(){return sqrDist;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sqrLen",function(){return sqrLen;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"forEach",function(){return forEach;});/* harmony import */var _common_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2);/**
   * 2 Dimensional Vector
   * @module vec2
   */ /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */function create(){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);if(_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"]!=Float32Array){out[0]=0;out[1]=0;}return out;}/**
   * Creates a new vec2 initialized with values from an existing vector
   *
   * @param {ReadonlyVec2} a vector to clone
   * @returns {vec2} a new 2D vector
   */function clone(a){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);out[0]=a[0];out[1]=a[1];return out;}/**
   * Creates a new vec2 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} a new 2D vector
   */function fromValues(x,y){var out=new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);out[0]=x;out[1]=y;return out;}/**
   * Copy the values from one vec2 to another
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the source vector
   * @returns {vec2} out
   */function copy(out,a){out[0]=a[0];out[1]=a[1];return out;}/**
   * Set the components of a vec2 to the given values
   *
   * @param {vec2} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} out
   */function set(out,x,y){out[0]=x;out[1]=y;return out;}/**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];return out;}/**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];return out;}/**
   * Multiplies two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */function multiply(out,a,b){out[0]=a[0]*b[0];out[1]=a[1]*b[1];return out;}/**
   * Divides two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */function divide(out,a,b){out[0]=a[0]/b[0];out[1]=a[1]/b[1];return out;}/**
   * Math.ceil the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to ceil
   * @returns {vec2} out
   */function ceil(out,a){out[0]=Math.ceil(a[0]);out[1]=Math.ceil(a[1]);return out;}/**
   * Math.floor the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to floor
   * @returns {vec2} out
   */function floor(out,a){out[0]=Math.floor(a[0]);out[1]=Math.floor(a[1]);return out;}/**
   * Returns the minimum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */function min(out,a,b){out[0]=Math.min(a[0],b[0]);out[1]=Math.min(a[1],b[1]);return out;}/**
   * Returns the maximum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */function max(out,a,b){out[0]=Math.max(a[0],b[0]);out[1]=Math.max(a[1],b[1]);return out;}/**
   * Math.round the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to round
   * @returns {vec2} out
   */function round(out,a){out[0]=Math.round(a[0]);out[1]=Math.round(a[1]);return out;}/**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */function scale(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;return out;}/**
   * Adds two vec2's after scaling the second operand by a scalar value
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec2} out
   */function scaleAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;return out;}/**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} distance between a and b
   */function distance(a,b){var x=b[0]-a[0],y=b[1]-a[1];return Math.hypot(x,y);}/**
   * Calculates the squared euclidian distance between two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} squared distance between a and b
   */function squaredDistance(a,b){var x=b[0]-a[0],y=b[1]-a[1];return x*x+y*y;}/**
   * Calculates the length of a vec2
   *
   * @param {ReadonlyVec2} a vector to calculate length of
   * @returns {Number} length of a
   */function length(a){var x=a[0],y=a[1];return Math.hypot(x,y);}/**
   * Calculates the squared length of a vec2
   *
   * @param {ReadonlyVec2} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */function squaredLength(a){var x=a[0],y=a[1];return x*x+y*y;}/**
   * Negates the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to negate
   * @returns {vec2} out
   */function negate(out,a){out[0]=-a[0];out[1]=-a[1];return out;}/**
   * Returns the inverse of the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to invert
   * @returns {vec2} out
   */function inverse(out,a){out[0]=1.0/a[0];out[1]=1.0/a[1];return out;}/**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to normalize
   * @returns {vec2} out
   */function normalize(out,a){var x=a[0],y=a[1];var len=x*x+y*y;if(len>0){//TODO: evaluate use of glm_invsqrt here?
  len=1/Math.sqrt(len);}out[0]=a[0]*len;out[1]=a[1]*len;return out;}/**
   * Calculates the dot product of two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} dot product of a and b
   */function dot(a,b){return a[0]*b[0]+a[1]*b[1];}/**
   * Computes the cross product of two vec2's
   * Note that the cross product must by definition produce a 3D vector
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec3} out
   */function cross(out,a,b){var z=a[0]*b[1]-a[1]*b[0];out[0]=out[1]=0;out[2]=z;return out;}/**
   * Performs a linear interpolation between two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec2} out
   */function lerp(out,a,b,t){var ax=a[0],ay=a[1];out[0]=ax+t*(b[0]-ax);out[1]=ay+t*(b[1]-ay);return out;}/**
   * Generates a random vector with the given scale
   *
   * @param {vec2} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec2} out
   */function random(out,scale){scale=scale||1.0;var r=_common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]()*2.0*Math.PI;out[0]=Math.cos(r)*scale;out[1]=Math.sin(r)*scale;return out;}/**
   * Transforms the vec2 with a mat2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat2} m matrix to transform with
   * @returns {vec2} out
   */function transformMat2(out,a,m){var x=a[0],y=a[1];out[0]=m[0]*x+m[2]*y;out[1]=m[1]*x+m[3]*y;return out;}/**
   * Transforms the vec2 with a mat2d
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat2d} m matrix to transform with
   * @returns {vec2} out
   */function transformMat2d(out,a,m){var x=a[0],y=a[1];out[0]=m[0]*x+m[2]*y+m[4];out[1]=m[1]*x+m[3]*y+m[5];return out;}/**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat3} m matrix to transform with
   * @returns {vec2} out
   */function transformMat3(out,a,m){var x=a[0],y=a[1];out[0]=m[0]*x+m[3]*y+m[6];out[1]=m[1]*x+m[4]*y+m[7];return out;}/**
   * Transforms the vec2 with a mat4
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec2} out
   */function transformMat4(out,a,m){var x=a[0];var y=a[1];out[0]=m[0]*x+m[4]*y+m[12];out[1]=m[1]*x+m[5]*y+m[13];return out;}/**
   * Rotate a 2D vector
   * @param {vec2} out The receiving vec2
   * @param {ReadonlyVec2} a The vec2 point to rotate
   * @param {ReadonlyVec2} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec2} out
   */function rotate(out,a,b,rad){//Translate point to the origin
  var p0=a[0]-b[0],p1=a[1]-b[1],sinC=Math.sin(rad),cosC=Math.cos(rad);//perform rotation and translate to correct position
  out[0]=p0*cosC-p1*sinC+b[0];out[1]=p0*sinC+p1*cosC+b[1];return out;}/**
   * Get the angle between two 2D vectors
   * @param {ReadonlyVec2} a The first operand
   * @param {ReadonlyVec2} b The second operand
   * @returns {Number} The angle in radians
   */function angle(a,b){var x1=a[0],y1=a[1],x2=b[0],y2=b[1],// mag is the product of the magnitudes of a and b
  mag=Math.sqrt(x1*x1+y1*y1)*Math.sqrt(x2*x2+y2*y2),// mag &&.. short circuits if mag == 0
  cosine=mag&&(x1*x2+y1*y2)/mag;// Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1
  return Math.acos(Math.min(Math.max(cosine,-1),1));}/**
   * Set the components of a vec2 to zero
   *
   * @param {vec2} out the receiving vector
   * @returns {vec2} out
   */function zero(out){out[0]=0.0;out[1]=0.0;return out;}/**
   * Returns a string representation of a vector
   *
   * @param {ReadonlyVec2} a vector to represent as a string
   * @returns {String} string representation of the vector
   */function str(a){return "vec2("+a[0]+", "+a[1]+")";}/**
   * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec2} a The first vector.
   * @param {ReadonlyVec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1];}/**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec2} a The first vector.
   * @param {ReadonlyVec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */function equals(a,b){var a0=a[0],a1=a[1];var b0=b[0],b1=b[1];return Math.abs(a0-b0)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=_common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]*Math.max(1.0,Math.abs(a1),Math.abs(b1));}/**
   * Alias for {@link vec2.length}
   * @function
   */var len=length;/**
   * Alias for {@link vec2.subtract}
   * @function
   */var sub=subtract;/**
   * Alias for {@link vec2.multiply}
   * @function
   */var mul=multiply;/**
   * Alias for {@link vec2.divide}
   * @function
   */var div=divide;/**
   * Alias for {@link vec2.distance}
   * @function
   */var dist=distance;/**
   * Alias for {@link vec2.squaredDistance}
   * @function
   */var sqrDist=squaredDistance;/**
   * Alias for {@link vec2.squaredLength}
   * @function
   */var sqrLen=squaredLength;/**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */var forEach=function(){var vec=create();return function(a,stride,offset,count,fn,arg){var i,l;if(!stride){stride=2;}if(!offset){offset=0;}if(count){l=Math.min(count*stride+offset,a.length);}else {l=a.length;}for(i=offset;i<l;i+=stride){vec[0]=a[i];vec[1]=a[i+1];fn(vec,vec,arg);a[i]=vec[0];a[i+1]=vec[1];}return a;};}();/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return Renderer;});/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(23);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(24);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);/* harmony import */var gl_renderer__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(25);/* harmony import */var gl_matrix__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(1);/* harmony import */var _canvas_renderer__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(36);/* harmony import */var _utils_compress__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(43);/* harmony import */var _utils_canvas__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(41);/* harmony import */var _figure2d__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(56);/* harmony import */var _mesh2d__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(73);/* harmony import */var _mesh_cloud__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(45);/* harmony import */var _utils_transform__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(78);/* harmony import */var _utils_env__WEBPACK_IMPORTED_MODULE_13__=__webpack_require__(37);/* harmony import */var _utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__=__webpack_require__(82);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function _createForOfIteratorHelper(o,allowArrayLike){var it;if(typeof Symbol==="undefined"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return {s:F,n:function n(){if(i>=o.length)return {done:true};return {done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return {s:function s(){it=o[Symbol.iterator]();},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var defaultOpts={autoUpdate:false,// premultipliedAlpha: true,
  preserveDrawingBuffer:false,// depth: false,
  // antialias: false,
  bufferSize:1500};var defaultPassVertex="attribute vec3 a_vertexPosition;\nattribute vec3 a_vertexTextureCoord;\nvarying vec3 vTextureCoord;\nuniform mat3 viewMatrix;\nuniform mat3 projectionMatrix;\n\nvoid main() {\n  gl_PointSize = 1.0;\n  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);\n  gl_Position = vec4(pos.xy, 1.0, 1.0);    \n  vTextureCoord = a_vertexTextureCoord;              \n}\n";var defaultPassFragment="precision mediump float;\nvarying vec3 vTextureCoord;\nuniform sampler2D u_texSampler;\nvoid main() {\n  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);\n}\n";var _glRenderer=Symbol('glRenderer');var _canvasRenderer=Symbol('canvasRenderer');var _options=Symbol('options');var _globalTransform=Symbol('globalTransform');var _applyGlobalTransform=Symbol('applyGlobalTransform');var _canvas=Symbol('canvas');function draw(renderer){var gl=renderer.gl;var fbo=renderer.fbo;if(fbo){gl.bindFramebuffer(gl.FRAMEBUFFER,fbo);}renderer._draw();if(fbo){gl.bindFramebuffer(gl.FRAMEBUFFER,null);}}function drawFilterContext(renderer,filterContext,width,height){var filterTexture=renderer.createTexture(filterContext.canvas);var contours=[[[0,0],[width,0],[width,height],[0,height],[0,0]]];contours.closed=true;var filterMesh=new _mesh2d__WEBPACK_IMPORTED_MODULE_10__["default"]({contours:contours});filterMesh.setTexture(filterTexture);renderer.setMeshData([filterMesh.meshData]);draw(renderer);filterTexture.delete();filterContext.clearRect(0,0,width,height);delete filterContext._filter;}var Renderer=/*#__PURE__*/function(){function Renderer(canvas){var opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this,Renderer);var contextType=opts.contextType;if(!contextType){if(typeof WebGL2RenderingContext==='function'){contextType='webgl2';}else if(typeof WebGLRenderingContext==='function'){contextType='webgl';}else {contextType='2d';}}if(!canvas.getContext){// 小程序
  var context=canvas;canvas={getContext:function getContext(){return context;},width:opts.width,height:opts.height};context.canvas=canvas;contextType='2d';}this[_canvas]=canvas;if(contextType!=='webgl'&&contextType!=='webgl2'&&contextType!=='2d'){throw new Error("Unknown context type ".concat(contextType));}opts.contextType=contextType;this[_options]=Object.assign({},defaultOpts,opts);if(contextType==='webgl'||contextType==='webgl2'){if(contextType==='webgl2')this[_options].webgl2=true;var renderer=new gl_renderer__WEBPACK_IMPORTED_MODULE_4__["default"](canvas,this[_options]);if(contextType==='webgl2'&&!renderer.isWebGL2){// webgl2 may disabled by browser settings
  opts.contextType='webgl';}Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["createShaders"])(renderer);Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyShader"])(renderer);Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["createCloudShaders"])(renderer);var gl=renderer.gl;// gl.clearColor(1.0, 1.0, 1.0, 1.0);
  // gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
  gl.clearColor(0.0,0.0,0.0,0.0);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);this[_glRenderer]=renderer;}else {this[_canvasRenderer]=new _canvas_renderer__WEBPACK_IMPORTED_MODULE_6__["default"](canvas,this[_options]);}this[_globalTransform]=[1,0,0,0,1,0,0,0,1];this.updateResolution();}_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(Renderer,[{key:_applyGlobalTransform,value:function value(){var renderer=this[_glRenderer]||this[_canvasRenderer];if(this[_glRenderer]){var _this$canvas=this.canvas,width=_this$canvas.width,height=_this$canvas.height;renderer.uniforms.viewMatrix=this.viewMatrix;renderer.uniforms.projectionMatrix=this.projectionMatrix;renderer.uniforms.u_resolution=[width,height];}}},{key:"updateResolution",value:function updateResolution(){var _this$canvas2=this.canvas,width=_this$canvas2.width,height=_this$canvas2.height;var m1=[// translation
  1,0,0,0,1,0,-width/2,-height/2,1];var m2=[// scale
  2/width,0,0,0,-2/height,0,0,0,1];var m3=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0,0,0,0,0,0,0,0,0),m2,m1);this.projectionMatrix=m3;if(this[_glRenderer]){this[_glRenderer].gl.viewport(0,0,width,height);}}},{key:"createTexture",value:function createTexture(img,opts){var renderer=this[_glRenderer]||this[_canvasRenderer];return renderer.createTexture(img,opts);}/* async */},{key:"loadTexture",value:function loadTexture(textureURL){var _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref$useImageBitmap=_ref.useImageBitmap,useImageBitmap=_ref$useImageBitmap===void 0?false:_ref$useImageBitmap;var renderer=this[_glRenderer]||this[_canvasRenderer];return renderer.loadTexture(textureURL,{useImageBitmap:useImageBitmap});}},{key:"createText",value:function createText(text){var _ref2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref2$font=_ref2.font,font=_ref2$font===void 0?'16px arial':_ref2$font,_ref2$fillColor=_ref2.fillColor,fillColor=_ref2$fillColor===void 0?null:_ref2$fillColor,_ref2$strokeColor=_ref2.strokeColor,strokeColor=_ref2$strokeColor===void 0?null:_ref2$strokeColor,_ref2$strokeWidth=_ref2.strokeWidth,strokeWidth=_ref2$strokeWidth===void 0?1:_ref2$strokeWidth;if(this[_glRenderer]){var img=_utils_env__WEBPACK_IMPORTED_MODULE_13__["default"].createText(text,{font:font,fillColor:fillColor,strokeColor:strokeColor,strokeWidth:strokeWidth});return {image:this.createTexture(img.image),rect:img.rect};}return {_img:{font:font,fillColor:fillColor,strokeColor:strokeColor,strokeWidth:strokeWidth,text:text}};}},{key:"createProgram",value:function createProgram(){var _ref3=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},vertex=_ref3.vertex,fragment=_ref3.fragment,options=_ref3.options;if(this[_glRenderer]){var program=this[_glRenderer].compileSync(fragment,vertex);program._attribOpts=options;return program;}throw new Error('Context 2D cannot create webgl program.');}},{key:"createPassProgram",value:function createPassProgram(){var _ref4=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref4$vertex=_ref4.vertex,vertex=_ref4$vertex===void 0?defaultPassVertex:_ref4$vertex,_ref4$fragment=_ref4.fragment,fragment=_ref4$fragment===void 0?defaultPassFragment:_ref4$fragment,options=_ref4.options;return this.createProgram({vertex:vertex,fragment:fragment,options:options});}},{key:"useProgram",value:function useProgram(program){var attributeOptions=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(this[_glRenderer]){var attrOpts=Object.assign({},program._attribOpts,attributeOptions);return this[_glRenderer].useProgram(program,attrOpts);}throw new Error('Context 2D cannot use webgl program.');}},{key:"deleteTexture",value:function deleteTexture(texture){var renderer=this[_glRenderer]||this[_canvasRenderer];return renderer.deleteTexture(texture);}},{key:"clear",value:function clear(){if(this[_glRenderer]){var gl=this[_glRenderer].gl;gl.clear(gl.COLOR_BUFFER_BIT);}else {var _this$_canvasRenderer;(_this$_canvasRenderer=this[_canvasRenderer]).clear.apply(_this$_canvasRenderer,arguments);}}},{key:"drawMeshCloud",value:function drawMeshCloud(cloud){var _ref5=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref5$clear=_ref5.clear,clear=_ref5$clear===void 0?false:_ref5$clear,_ref5$program=_ref5.program,drawProgram=_ref5$program===void 0?null:_ref5$program;var renderer=this[_glRenderer]||this[_canvasRenderer];// if(!this.isWebGL2) throw new Error('Only webgl2 context support drawMeshCloud.');
  var program=drawProgram||cloud.program;if(this[_glRenderer]){var gl=renderer.gl;if(clear)gl.clear(gl.COLOR_BUFFER_BIT);if(!program){var mesh=cloud.mesh.meshData;var hasTexture=!!mesh.uniforms.u_texSampler;var hasFilter=!!mesh.uniforms.u_filterFlag;var hasGradient=!!mesh.uniforms.u_radialGradientVector;var hasCloudColor=cloud.hasCloudColor;var hasCloudFilter=cloud.hasCloudFilter;var hasClipPath=!!mesh.uniforms.u_clipSampler;Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyCloudShader"])(renderer,{hasTexture:hasTexture,hasFilter:hasFilter,hasGradient:hasGradient,hasCloudColor:hasCloudColor,hasCloudFilter:hasCloudFilter,hasClipPath:hasClipPath});}else if(renderer.program!==program){this.useProgram(program,{a_color:{type:'UNSIGNED_BYTE',normalize:true},a_fillCloudColor:{type:'UNSIGNED_BYTE',normalize:true},a_strokeCloudColor:{type:'UNSIGNED_BYTE',normalize:true},a_frameIndex:{type:'UNSIGNED_BYTE',normalize:false}});}this[_applyGlobalTransform]();renderer.setMeshData([cloud.meshData]);if(cloud.beforeRender)cloud.beforeRender(gl,cloud);draw(renderer);if(cloud.afterRender)cloud.afterRender(gl,cloud);}else {renderer.setTransform(this.globalTransformMatrix);renderer.drawMeshCloud(cloud,{clear:clear,hook:false});}}},{key:"drawMeshes",value:function drawMeshes(meshes){var _this=this;var _ref6=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref6$clear=_ref6.clear,clear=_ref6$clear===void 0?false:_ref6$clear,_ref6$program=_ref6.program,drawProgram=_ref6$program===void 0?null:_ref6$program;// eslint-disable-line complexity
  var renderer=this[_glRenderer]||this[_canvasRenderer];if(this[_glRenderer]){(function(){var oldFBO=renderer.fbo;var meshData=Object(_utils_compress__WEBPACK_IMPORTED_MODULE_7__["default"])(_this,meshes,drawProgram==null);var gl=renderer.gl;if(clear)gl.clear(gl.COLOR_BUFFER_BIT);var hasGlobalTransform=!Object(_utils_transform__WEBPACK_IMPORTED_MODULE_12__["isUnitTransform"])(_this.globalTransformMatrix);_this._drawCalls=0;var _iterator=_createForOfIteratorHelper(meshData),_step;try{var _loop=function _loop(){var mesh=_step.value;// eslint-disable-line no-restricted-syntax
  _this._drawCalls++;var program=drawProgram||mesh.program;if(mesh instanceof _mesh_cloud__WEBPACK_IMPORTED_MODULE_11__["default"]){_this.drawMeshCloud(mesh,{clear:clear,program:program});// continue; // eslint-disable-line no-continue
  }else {var _this$canvas3=_this.canvas,width=_this$canvas3.width,height=_this$canvas3.height;if(mesh.beforeRender)mesh.beforeRender(gl,mesh);if(mesh.pass.length){if(!_this.fbo||_this.fbo.width!==width||_this.fbo.height!==height){_this.fbo={width:width,height:height,target:renderer.createFBO(),buffer:renderer.createFBO(),swap:function swap(){var _ref7=[this.buffer,this.target];this.target=_ref7[0];this.buffer=_ref7[1];}};}renderer.bindFBO(_this.fbo.target);}if(!program&&mesh.filterCanvas){// 有一些滤镜用shader不好实现：blur、drop-shadow、url
  Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyShader"])(renderer,{hasTexture:true});var filterContext=_this.filterContext;if(!filterContext){var canvas=_utils_env__WEBPACK_IMPORTED_MODULE_13__["default"].createCanvas(width,height);filterContext=canvas.getContext('2d');_this.filterContext=filterContext;}var originalMesh=meshes[mesh.packIndex];var currentFilter=originalMesh.filter;var nextMesh=meshes[mesh.packIndex+1];var previousMesh=meshes[mesh.packIndex-1];if((!previousMesh||!previousMesh.filterCanvas||previousMesh.filter!==currentFilter)&&(!nextMesh||!nextMesh.filterCanvas||nextMesh.filter!==currentFilter)){if(hasGlobalTransform){filterContext.save();// filterContext.transform(...this.globalTransformMatrix);
  Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["drawMesh2D"])(originalMesh,filterContext,false);filterContext.restore();Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["applyFilter"])(filterContext,currentFilter);}else {Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["drawMesh2D"])(originalMesh,filterContext,true);}_this[_applyGlobalTransform]();drawFilterContext(renderer,filterContext,width,height);}else {if(hasGlobalTransform){filterContext.save();// filterContext.transform(...this.globalTransformMatrix);
  }Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["drawMesh2D"])(originalMesh,filterContext,false);if(hasGlobalTransform){filterContext.restore();}if(!nextMesh||!nextMesh.filterCanvas||originalMesh.filter!==nextMesh.filter){Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["applyFilter"])(filterContext,currentFilter);_this[_applyGlobalTransform]();drawFilterContext(renderer,filterContext,width,height);}}}else {if(!program){var hasTexture=!!mesh.uniforms.u_texSampler;var hasFilter=!!mesh.uniforms.u_filterFlag;var hasGradient=!!mesh.uniforms.u_radialGradientVector;var hasClipPath=!!mesh.uniforms.u_clipSampler;Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyShader"])(renderer,{hasTexture:hasTexture,hasFilter:hasFilter,hasGradient:hasGradient,hasClipPath:hasClipPath});}else if(renderer.program!==program){_this.useProgram(program,{a_color:{type:'UNSIGNED_BYTE',normalize:true}});}if(mesh.filterCanvas){console.warn('User program ignored some filter effects.');}_this[_applyGlobalTransform]();renderer.setMeshData([mesh]);draw(renderer);}if(mesh.pass.length){var len=mesh.pass.length;mesh.pass.forEach(function(pass,idx){pass.blend=mesh.enableBlend;pass.setTexture(renderer.fbo.texture);if(idx===len-1)renderer.bindFBO(oldFBO);else {_this.fbo.swap();renderer.bindFBO(_this.fbo.target);}if(pass.program)renderer.useProgram(pass.program);else {_this.defaultPassProgram=_this.defaultPassProgram||_this.createPassProgram();renderer.useProgram(_this.defaultPassProgram);}renderer.setMeshData([pass.meshData]);gl.clear(gl.COLOR_BUFFER_BIT);draw(renderer);});}if(mesh.afterRender)mesh.afterRender(gl,mesh);}};for(_iterator.s();!(_step=_iterator.n()).done;){_loop();}}catch(err){_iterator.e(err);}finally{_iterator.f();}})();}else {renderer.setTransform(this.globalTransformMatrix);renderer.drawMeshes(meshes,{clear:clear});}}},{key:"drawImage",value:function drawImage(image){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argLength=args.length;if(argLength<2){throw new TypeError("Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ".concat(args.length+1," present."));}if(argLength!==2&&argLength!==4&&argLength!==8){throw new TypeError("Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ".concat(args.length+1," arguments provided."));}var rect=null;var srcRect=null;if(argLength===2){// drawImage(image, dx, dy)
  rect=[args[0],args[1],image.width,image.height];}else if(argLength===4){// drawImage(image, dx, dy, dWidth, dHeight)
  rect=args;}else if(argLength===8){// drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
  srcRect=args.slice(0,4);rect=args.slice(4);}var texture=this.createTexture(image);var _this$canvas4=this.canvas,width=_this$canvas4.width,height=_this$canvas4.height;var figure=new _figure2d__WEBPACK_IMPORTED_MODULE_9__["default"]();figure.rect(rect[0],rect[1],width,height);var mesh=new _mesh2d__WEBPACK_IMPORTED_MODULE_10__["default"](figure,{width:width,height:height});mesh.setTexture(texture,{rect:rect,srcRect:srcRect});this.drawMeshes([mesh]);this.deleteTexture(texture);}},{key:"setGlobalTransform",value:function setGlobalTransform(){this[_globalTransform]=[arguments.length<=0?undefined:arguments[0],arguments.length<=1?undefined:arguments[1],0,arguments.length<=2?undefined:arguments[2],arguments.length<=3?undefined:arguments[3],0,arguments.length<=4?undefined:arguments[4],arguments.length<=5?undefined:arguments[5],1];return this;}},{key:"globalTransform",value:function globalTransform(){var transform=this[_globalTransform];for(var _len2=arguments.length,m=new Array(_len2),_key2=0;_key2<_len2;_key2++){m[_key2]=arguments[_key2];}this[_globalTransform]=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0,0,0,0,0,0,0,0,0),transform,m);return this;}},{key:"globalTranslate",value:function globalTranslate(x,y){var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0,0,0,0,0,0,0,0,0),m,[x,y]);return this.globalTransform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"globalRotate",value:function globalRotate(rad){var _ref8=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[0,0],_ref9=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref8,2),ox=_ref9[0],oy=_ref9[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0,0,0,0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].rotate(Array.of(0,0,0,0,0,0,0,0,0),m,rad);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0,0,0,0,0,0,0,0,0),m,[-ox,-oy]);return this.globalTransform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"globalScale",value:function globalScale(x){var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:x;var _ref10=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[0,0],_ref11=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref10,2),ox=_ref11[0],oy=_ref11[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0,0,0,0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].scale(Array.of(0,0,0,0,0,0,0,0,0),m,[x,y]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0,0,0,0,0,0,0,0,0),m,[-ox,-oy]);return this.globalTransform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"globalSkew",value:function globalSkew(x){var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:x;var _ref12=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[0,0],_ref13=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref12,2),ox=_ref13[0],oy=_ref13[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0,0,0,0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0,0,0,0,0,0,0,0,0),m,gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].fromValues(1,Math.tan(y),Math.tan(x),1,0,0));m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0,0,0,0,0,0,0,0,0),m,[-ox,-oy]);return this.globalTransform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"transformPoint",value:function transformPoint(x,y,matrix){var m=this.globalTransformMatrix;if(matrix)m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0,0,0,0,0,0,0,0,0),m,matrix);var newX=x*m[0]+y*m[2]+m[4];var newY=x*m[1]+y*m[3]+m[5];return [newX,newY];}},{key:"canvas",get:function get(){return this[_canvas];}},{key:"canvasRenderer",get:function get(){return this[_canvasRenderer];}},{key:"glRenderer",get:function get(){return this[_glRenderer];}},{key:"isWebGL2",get:function get(){return this[_glRenderer]&&this[_glRenderer].isWebGL2;}},{key:"options",get:function get(){return this[_options];}},{key:"globalTransformMatrix",get:function get(){var m=this[_globalTransform];return [m[0],m[1],m[3],m[4],m[6],m[7]];}},{key:"viewMatrix",get:function get(){return this[_globalTransform];}}]);return Renderer;}();/***/},function(module,exports,__webpack_require__){var arrayWithHoles=__webpack_require__(14);var iterableToArrayLimit=__webpack_require__(15);var unsupportedIterableToArray=__webpack_require__(16);var nonIterableRest=__webpack_require__(18);function _slicedToArray(arr,i){return arrayWithHoles(arr)||iterableToArrayLimit(arr,i)||unsupportedIterableToArray(arr,i)||nonIterableRest();}module.exports=_slicedToArray;/***/},function(module,exports){function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}module.exports=_arrayWithHoles;/***/},function(module,exports){function _iterableToArrayLimit(arr,i){if(typeof Symbol==="undefined"||!(Symbol.iterator in Object(arr)))return;var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}module.exports=_iterableToArrayLimit;/***/},function(module,exports,__webpack_require__){var arrayLikeToArray=__webpack_require__(17);function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return arrayLikeToArray(o,minLen);}module.exports=_unsupportedIterableToArray;/***/},function(module,exports){function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}module.exports=_arrayLikeToArray;/***/},function(module,exports){function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}module.exports=_nonIterableRest;/***/},function(module,exports,__webpack_require__){var arrayWithoutHoles=__webpack_require__(20);var iterableToArray=__webpack_require__(21);var unsupportedIterableToArray=__webpack_require__(16);var nonIterableSpread=__webpack_require__(22);function _toConsumableArray(arr){return arrayWithoutHoles(arr)||iterableToArray(arr)||unsupportedIterableToArray(arr)||nonIterableSpread();}module.exports=_toConsumableArray;/***/},function(module,exports,__webpack_require__){var arrayLikeToArray=__webpack_require__(17);function _arrayWithoutHoles(arr){if(Array.isArray(arr))return arrayLikeToArray(arr);}module.exports=_arrayWithoutHoles;/***/},function(module,exports){function _iterableToArray(iter){if(typeof Symbol!=="undefined"&&Symbol.iterator in Object(iter))return Array.from(iter);}module.exports=_iterableToArray;/***/},function(module,exports){function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}module.exports=_nonIterableSpread;/***/},function(module,exports){function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}module.exports=_classCallCheck;/***/},function(module,exports){function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}module.exports=_createClass;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony import */var _renderer__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(26);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);/* harmony default export */__webpack_exports__["default"]=_renderer__WEBPACK_IMPORTED_MODULE_0__["default"];/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return Renderer;});/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(27);/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(29);/* harmony import */var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(23);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(24);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__);/* harmony import */var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(30);/* harmony import */var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);/* harmony import */var _helpers__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(31);/* harmony import */var _default_vert_glsl__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(33);/* harmony import */var _default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(34);/* harmony import */var _default_feeback_vert_glsl__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(35);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var GLSL_LIBS={};function mapTextureCoordinate(positions){var size=arguments.length>1&&arguments[1]!==undefined?arguments[1]:3;var texVertexData=[];var len=positions.length;for(var i=0;i<len;i++){if(i%size<2)texVertexData.push(0.5*(positions[i]+1));}return texVertexData;}function clearBuffers(gl,program){var buffers=program._buffers;Object.values(buffers).forEach(function(buffer){gl.deleteBuffer(buffer);});program._buffers={};}function bindTexture(gl,texture,i){gl.activeTexture(gl.TEXTURE0+i);if(Array.isArray(texture._img)){gl.bindTexture(gl.TEXTURE_CUBE_MAP,texture);}else {gl.bindTexture(gl.TEXTURE_2D,texture);}return texture;}var uniformTypeMap={int:'1i',ivec2:'2i',ivec3:'3i',ivec4:'4i',float:'1f',vec2:'2f',vec3:'3f',vec4:'4f',mat2:'Matrix2fv',mat3:'Matrix3fv',mat4:'Matrix4fv',sampler1D:'sampler1D',sampler2D:'sampler2D',sampler3D:'sampler3D',samplerCube:'samplerCube',sampler1DShadow:'sampler1DShadow',sampler2DShadow:'sampler2DShadow',sampler2DRect:'sampler2DRect',sampler2DRectShadow:'sampler2DRectShadow'};var Renderer=/*#__PURE__*/function(){_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(Renderer,null,[{key:"addLibs",value:function addLibs(){var libs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};Object.assign(GLSL_LIBS,libs);}},{key:"FLOAT",value:function FLOAT(points,buffer){return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points,Float32Array,buffer);}},{key:"UNSIGNED_BYTE",value:function UNSIGNED_BYTE(points,buffer){return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points,Uint8Array,buffer);}},{key:"UNSIGNED_SHORT",value:function UNSIGNED_SHORT(points,buffer){return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points,Uint16Array,buffer);}},{key:"BYTE",value:function BYTE(points,buffer){return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points,Int8Array,buffer);}},{key:"SHORT",value:function SHORT(points,buffer){return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points,Int16Array,buffer);}}]);function Renderer(canvas){var opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default()(this,Renderer);this.options=Object.assign({},Renderer.defaultOptions,opts);this.canvas=canvas;var gl;if(this.options.webgl2){gl=canvas.getContext('webgl2',this.options);}if(gl==null){gl=Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["setupWebGL"])(canvas,this.options);this.aia_ext=gl.getExtension('ANGLE_instanced_arrays');}this.gl=gl;gl.viewport(0,0,canvas.width,canvas.height);// gl.clearColor(1.0, 1.0, 1.0, 1.0);
  // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.clearColor(0.0,0.0,0.0,0.0);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);this.programs=[];this._events={};}_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(Renderer,[{key:"_declareUniform",// WebGLRenderingContext.uniform[1234][fi][v]()
  // WebGLRenderingContext.uniformMatrix[234]fv()
  value:function _declareUniform(program,name){var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'1f';var gl=this.gl;var uniform=gl.getUniformLocation(program,name);var value;var that=this;if(/^sampler/.test(type)){var samplerMap=program._samplerMap;var textures=program._bindTextures;Object.defineProperty(program.uniforms,name,{get:function get(){return value;},set:function set(v){value=v;var idx=samplerMap[name]!=null?samplerMap[name]:textures.length;textures[idx]=v;bindTexture(gl,v,idx);if(!samplerMap[name]){samplerMap[name]=idx;gl.uniform1i(uniform,idx);}// gl.bindTexture(gl.TEXTURE_2D, null);
  if(that.options.autoUpdate)that.update();},configurable:false,enumerable:true});}else {var isMatrix=type.indexOf('Matrix')===0;var isTypeV=!isMatrix&&/v$/.test(type);var setUniform=gl["uniform".concat(type)].bind(gl);Object.defineProperty(program.uniforms,name,{get:function get(){return value;},set:function set(v){value=v;if(typeof v==='number'){v=[v];}if(isMatrix)setUniform(uniform,false,v);else if(isTypeV)setUniform(uniform,v);else setUniform.apply(void 0,[uniform].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(v)));if(that.options.autoUpdate)that.update();},configurable:false,enumerable:true});}}},{key:"_draw",value:function _draw(){var _this=this;var program=this.program;program.meshData.forEach(function(meshData,meshIndex){var positions=meshData.positions,cells=meshData.cells,instanceCount=meshData.instanceCount,cellsCount=meshData.cellsCount,attributes=meshData.attributes,uniforms=meshData.uniforms,textureCoord=meshData.textureCoord,enableBlend=meshData.enableBlend;var gl=_this.gl;var mode=meshData.mode!=null?meshData.mode:gl.TRIANGLES;if(typeof mode==='string'){mode=gl[mode];}if(enableBlend)gl.enable(gl.BLEND);else gl.disable(gl.BLEND);gl.bindBuffer(gl.ARRAY_BUFFER,program._buffers.verticesBuffer);gl.bufferData(gl.ARRAY_BUFFER,positions,gl.STATIC_DRAW);if(cells){gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,program._buffers.cellsBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,cells,gl.STATIC_DRAW);}var locations=[];if(attributes){Object.values(attributes).forEach(function(_ref){var name=_ref.name,data=_ref.data,divisor=_ref.divisor;gl.bindBuffer(gl.ARRAY_BUFFER,program._buffers[name]);gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW);if(divisor!=null){var location=gl.getAttribLocation(program,name);if(location>=0){gl.enableVertexAttribArray(location);locations.push(location);if(gl.vertexAttribDivisor){gl.vertexAttribDivisor(location,divisor);}else if(_this.aia_ext){_this.aia_ext.vertexAttribDivisorANGLE(location,divisor);}}}});}if(uniforms){Object.entries(uniforms).forEach(function(_ref2){var _ref3=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref2,2),key=_ref3[0],value=_ref3[1];_this.uniforms[key]=value;});}var count;if(!cells){var dimension=program._dimension;count=positions.length/dimension;}if(program._enableTextures&&program._buffers.texCoordBuffer){var texVertexData=textureCoord||mapTextureCoordinate(positions,program._dimension);gl.bindBuffer(gl.ARRAY_BUFFER,program._buffers.texCoordBuffer);gl.bufferData(gl.ARRAY_BUFFER,Renderer.FLOAT(texVertexData),gl.STATIC_DRAW);}if(instanceCount!=null){if(cells){if(gl.drawElementsInstanced){gl.drawElementsInstanced(mode,cellsCount,gl.UNSIGNED_SHORT,0,instanceCount);}else if(_this.aia_ext){_this.aia_ext.drawElementsInstancedANGLE(mode,cellsCount,gl.UNSIGNED_SHORT,0,instanceCount);}}else if(gl.drawArraysInstanced){gl.drawArraysInstanced(mode,0,count,instanceCount);}else {_this.aia_ext.drawArraysInstancedANGLE(mode,0,count,instanceCount);}locations.forEach(function(location){if(gl.vertexAttribDivisor){gl.vertexAttribDivisor(location,null);}else if(_this.aia_ext){_this.aia_ext.vertexAttribDivisorANGLE(location,null);}});}else if(cells){gl.drawElements(mode,cellsCount,gl.UNSIGNED_SHORT,0);}else {gl.drawArrays(mode,0,count);}});}},{key:"deleteProgram",value:function deleteProgram(program){var gl=this.gl;if(this.program===program){this.startRender=false;if(this._renderFrameID){cancelAnimationFrame(this._renderFrameID);delete this._renderFrameID;}gl.useProgram(null);}var idx=this.programs.indexOf(program);if(idx>=0){this.programs.splice(idx,1);}clearBuffers(gl,program);gl.deleteProgram(program);}/**
        [{
          positions: ...
          cells: ...
          textureCoord: ...
          attributes: {name: {data:..., normalize: true}},
          uniforms: ...
        }]
       */},{key:"setMeshData",value:function setMeshData(data){var _this2=this;if(!Array.isArray(data)){data=[data];}var program=this.program;program.meshData=data.map(function(_ref4){var mode=_ref4.mode,positions=_ref4.positions,instanceCount=_ref4.instanceCount,cells=_ref4.cells,cellsCount=_ref4.cellsCount,attributes=_ref4.attributes,uniforms=_ref4.uniforms,textureCoord=_ref4.textureCoord,enableBlend=_ref4.enableBlend;var meshData={positions:Renderer.FLOAT(positions),uniforms:uniforms,enableBlend:!!enableBlend,textureCoord:Renderer.FLOAT(textureCoord)};if(cells){meshData.cells=Renderer.USHORT(cells);meshData.cellsCount=cellsCount||meshData.cells.length;}if(mode!=null){meshData.mode=mode;}if(instanceCount!=null){if(!_this2.isWebGL2&&!_this2.aia_ext)throw new Error('Cannot use instanceCount in this rendering context, use webgl2 context instead.');else meshData.instanceCount=instanceCount;}if(attributes){var copied={};Object.entries(attributes).forEach(function(_ref5){var _ref6=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref5,2),key=_ref6[0],value=_ref6[1];if(!program._attribute[key]){// throw new Error(`Invalid attribute ${key}.`);
  program._attribute[key]='ignored';}else if(program._attribute[key]!=='ignored'){var _program$_attribute$k=program._attribute[key],name=_program$_attribute$k.name,type=_program$_attribute$k.type;var buffer=value.data||value;if(Array.isArray(buffer)){buffer=Renderer[type](buffer);}copied[key]={name:name,data:buffer};if(value.divisor!=null){if(!_this2.isWebGL2&&!_this2.aia_ext)throw new Error('Cannot use divisor in this rendering context, use webgl2 context instead.');else copied[key].divisor=value.divisor;}}});meshData.attributes=copied;}return meshData;});if(this.options.autoUpdate)this.update();}},{key:"createProgram",value:function createProgram(fragmentShader,vertexShader){var _this3=this;// this.deleteProgram();
  // this._events = {};
  var enableTextures=/^\s*uniform\s+sampler/mg.test(fragmentShader);if(fragmentShader==null)fragmentShader=_default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__["default"];if(vertexShader==null)vertexShader=enableTextures?_default_feeback_vert_glsl__WEBPACK_IMPORTED_MODULE_10__["default"]:_default_vert_glsl__WEBPACK_IMPORTED_MODULE_8__["default"];var gl=this.gl;var program=Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["createProgram"])(gl,vertexShader,fragmentShader);program.shaderText={vertexShader:vertexShader,fragmentShader:fragmentShader};program._buffers={};program._attribute={};program.uniforms={};program._samplerMap={};program._bindTextures=[];// console.log(vertexShader);
  var pattern=new RegExp("(?:attribute|in) vec(\\d) ".concat(this.options.vertexPosition),'im');var matched=vertexShader.match(pattern);if(matched){program._dimension=Number(matched[1]);}var texCoordPattern=new RegExp("(?:attribute|in) vec(\\d) ".concat(this.options.vertexTextureCoord),'im');matched=vertexShader.match(texCoordPattern);if(matched){program._texCoordSize=Number(matched[1]);}var attributePattern=/^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;matched=vertexShader.match(attributePattern);if(matched){for(var i=0;i<matched.length;i++){var patt=/^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im;var _matched=matched[i].match(patt);if(_matched&&_matched[3]!==this.options.vertexPosition&&_matched[3]!==this.options.vertexTextureCoord){var _matched2=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_matched,4),type=_matched2[1],size=_matched2[2],name=_matched2[3];if(type==='mat')size=Math.pow(size,2);program._buffers[name]=gl.createBuffer();program._attribute[name]={name:name,type:type,size:Number(size)||1};}}}var uniformPattern=/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;matched=vertexShader.match(uniformPattern)||[];matched=matched.concat(fragmentShader.match(uniformPattern)||[]);matched.forEach(function(m){var _matched=m.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);var _matched$slice=_matched.slice(1),_matched$slice2=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_matched$slice,3),type=_matched$slice2[0],name=_matched$slice2[1],isTypeV=_matched$slice2[2];type=uniformTypeMap[type];isTypeV=!!isTypeV;if(type.indexOf('Matrix')!==0&&isTypeV){type+='v';}_this3._declareUniform(program,name,type);});program._buffers.verticesBuffer=gl.createBuffer();program._buffers.cellsBuffer=gl.createBuffer();var vTexCoord=gl.getAttribLocation(program,this.options.vertexTextureCoord);program._enableTextures=vTexCoord>=0;if(program._enableTextures){program._buffers.texCoordBuffer=gl.createBuffer();}this.programs.push(program);return program;}},{key:"useProgram",value:function useProgram(program){var attrOptions=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.startRender=false;if(this._renderFrameID){cancelAnimationFrame(this._renderFrameID);delete this._renderFrameID;}var gl=this.gl;gl.useProgram(program);// this.program = program;
  var dimension=program._dimension;gl.bindBuffer(gl.ARRAY_BUFFER,program._buffers.verticesBuffer);var vPosition=gl.getAttribLocation(program,this.options.vertexPosition);gl.vertexAttribPointer(vPosition,dimension,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(vPosition);if(program._enableTextures){gl.bindBuffer(gl.ARRAY_BUFFER,program._buffers.texCoordBuffer);var vTexCoord=gl.getAttribLocation(program,this.options.vertexTextureCoord);gl.vertexAttribPointer(vTexCoord,program._texCoordSize||2,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(vTexCoord);}Object.entries(program._attribute).forEach(function(_ref7){var _ref8=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref7,2),name=_ref8[0],item=_ref8[1];if(item!=='ignored'){var size=item.size;var options=attrOptions[name]||{};var normalize=!!options.normalize;var bufferType=options.type||'FLOAT';var key=options.key||name;if(bufferType==='UBYTE')bufferType='UNSIGNED_BYTE';if(bufferType==='USHORT')bufferType='UNSIGNED_SHORT';item.type=bufferType;if(key&&key!==name){program._attribute[key]=item;}gl.bindBuffer(gl.ARRAY_BUFFER,program._buffers[name]);var attrib=gl.getAttribLocation(program,name);// console.log(size, gl[bufferType]);
  if(attrib>=0){gl.vertexAttribPointer(attrib,size,gl[bufferType],normalize,0,0);gl.enableVertexAttribArray(attrib);}}});if(!program.meshData){var positions=[[-1,-1,0,1].slice(0,dimension),[1,-1,0,1].slice(0,dimension),[1,1,0,1].slice(0,dimension),[-1,1,0,1].slice(0,dimension)];var cells=[[0,1,3],[3,1,2]];this.setMeshData({positions:positions,cells:cells});}return program;}},{key:"compileSync",value:function compileSync(frag,vert){frag=frag||_default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__["default"];var loaded={};function _compile(content){content=content.replace(/^\s*/mg,'');var includes=[];var matched=content.match(/^#pragma\s+include\s+.*/mg);if(matched){// console.log(matched, url);
  for(var i=0;i<matched.length;i++){var m=matched[i];var _matched=m.match(/(?:<|")(.*)(?:>|")/);if(_matched){var type=_matched[0].indexOf('<')===0?'lib':'link';var name=_matched[1];if(name==='graph')name='graphics';if(!loaded[name]){loaded[name]=true;if(type==='lib'){var c=_compile(GLSL_LIBS[name]);// eslint-disable-line no-await-in-loop
  includes.push(c);}else if(type==='link'){throw new Error('Cannot load external links synchronously. Use compile instead of compileSync.');}}else {includes.push("/* included ".concat(name," */"));}}}includes.forEach(function(inc){content=content.replace(/^#pragma\s+include\s+.*/m,inc);});}return content;}var fragmentShader=_compile(frag);var vertexShader=vert?_compile(vert):null;var program=this.createProgram(fragmentShader,vertexShader);return program;}},{key:"compile",value:function(){var _compile2=_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(frag,vert){var loaded,_compile,_compile3,fragmentShader,vertexShader,program;return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_compile3=function _compile5(){_compile3=_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(content){var includes,matched,i,m,_matched,type,name,c,_c;return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:content=content.replace(/^\s*/mg,'');includes=[];matched=content.match(/^#pragma\s+include\s+.*/mg);if(!matched){_context.next=36;break;}i=0;case 5:if(!(i<matched.length)){_context.next=35;break;}m=matched[i];_matched=m.match(/(?:<|")(.*)(?:>|")/);if(!_matched){_context.next=32;break;}type=_matched[0].indexOf('<')===0?'lib':'link';name=_matched[1];if(name==='graph')name='graphics';if(loaded[name]){_context.next=31;break;}loaded[name]=true;// TODO: 这里可以优化成异步加载
  if(!(type==='lib')){_context.next=21;break;}_context.next=17;return _compile(GLSL_LIBS[name]);case 17:c=_context.sent;// eslint-disable-line no-await-in-loop
  includes.push(c);_context.next=29;break;case 21:if(!(type==='link')){_context.next=29;break;}_context.next=24;return Renderer.fetchShader(name);case 24:_c=_context.sent;_context.next=27;return _compile(_c);case 27:_c=_context.sent;// eslint-disable-line no-await-in-loop
  includes.push(_c);case 29:_context.next=32;break;case 31:includes.push("/* included ".concat(name," */"));case 32:i++;_context.next=5;break;case 35:includes.forEach(function(inc){content=content.replace(/^#pragma\s+include\s+.*/m,inc);});case 36:return _context.abrupt("return",content);case 37:case"end":return _context.stop();}}},_callee);}));return _compile3.apply(this,arguments);};_compile=function _compile4(_x3){return _compile3.apply(this,arguments);};frag=frag||_default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__["default"];loaded={};_context2.next=6;return _compile(frag);case 6:fragmentShader=_context2.sent;if(!vert){_context2.next=13;break;}_context2.next=10;return _compile(vert);case 10:_context2.t0=_context2.sent;_context2.next=14;break;case 13:_context2.t0=null;case 14:vertexShader=_context2.t0;program=this.createProgram(fragmentShader,vertexShader);return _context2.abrupt("return",program);case 17:case"end":return _context2.stop();}}},_callee2,this);}));function compile(_x,_x2){return _compile2.apply(this,arguments);}return compile;}()},{key:"load",value:function(){var _load=_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(frag){var vert,_args3=arguments;return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:vert=_args3.length>1&&_args3[1]!==undefined?_args3[1]:null;_context3.next=3;return Renderer.fetchShader(frag);case 3:frag=_context3.sent;if(!vert){_context3.next=8;break;}_context3.next=7;return Renderer.fetchShader(vert);case 7:vert=_context3.sent;case 8:return _context3.abrupt("return",this.compile(frag,vert));case 9:case"end":return _context3.stop();}}},_callee3,this);}));function load(_x4){return _load.apply(this,arguments);}return load;}()},{key:"createTexture",value:function createTexture(){var _this4=this;var img=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var _ref9=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref9$wrapS=_ref9.wrapS,wrapS=_ref9$wrapS===void 0?this.gl.CLAMP_TO_EDGE:_ref9$wrapS,_ref9$wrapT=_ref9.wrapT,wrapT=_ref9$wrapT===void 0?this.gl.CLAMP_TO_EDGE:_ref9$wrapT,_ref9$minFilter=_ref9.minFilter,minFilter=_ref9$minFilter===void 0?this.gl.LINEAR:_ref9$minFilter,_ref9$magFilter=_ref9.magFilter,magFilter=_ref9$magFilter===void 0?this.gl.LINEAR:_ref9$magFilter;var gl=this.gl;var target=Array.isArray(img)?gl.TEXTURE_CUBE_MAP:gl.TEXTURE_2D;this._max_texture_image_units=this._max_texture_image_units||gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);gl.activeTexture(gl.TEXTURE0+this._max_texture_image_units-1);var texture=gl.createTexture();gl.bindTexture(target,texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);var _this$canvas=this.canvas,width=_this$canvas.width,height=_this$canvas.height;if(img){if(target===gl.TEXTURE_CUBE_MAP){// For cube maps
  for(var i=0;i<6;i++){gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img[i]);}}else {gl.texImage2D(target,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);}}else if(target===gl.TEXTURE_CUBE_MAP){// For cube maps
  for(var _i=0;_i<6;_i++){this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X+_i,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);}}else {gl.texImage2D(target,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);}// gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.
  gl.texParameteri(target,gl.TEXTURE_MIN_FILTER,minFilter);gl.texParameteri(target,gl.TEXTURE_MAG_FILTER,magFilter);// Prevents s-coordinate wrapping (repeating).
  gl.texParameteri(target,gl.TEXTURE_WRAP_S,wrapS);// Prevents t-coordinate wrapping (repeating).
  gl.texParameteri(target,gl.TEXTURE_WRAP_T,wrapT);if(target===gl.TEXTURE_CUBE_MAP){// gl.texParameteri(target, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
  img.width=img[0].width;img.height=img[0].height;}gl.bindTexture(target,null);texture._img=img||{width:width,height:height};texture.delete=function(){_this4.deleteTexture(texture);};return texture;}},{key:"deleteTexture",value:function deleteTexture(texture){var image=texture._img;this.gl.deleteTexture(texture);if(typeof image.close==='function'){// release ImageBitmap
  image.close();}}},{key:"loadTexture",value:function(){var _loadTexture=_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4(source){var _ref10,_ref10$useImageBitmap,useImageBitmap,img,_args4=arguments;return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_ref10=_args4.length>1&&_args4[1]!==undefined?_args4[1]:{},_ref10$useImageBitmap=_ref10.useImageBitmap,useImageBitmap=_ref10$useImageBitmap===void 0?true:_ref10$useImageBitmap;_context4.next=3;return Renderer.loadImage(source,{useImageBitmap:useImageBitmap});case 3:img=_context4.sent;return _context4.abrupt("return",this.createTexture(img));case 5:case"end":return _context4.stop();}}},_callee4,this);}));function loadTexture(_x5){return _loadTexture.apply(this,arguments);}return loadTexture;}()},{key:"createFBO",value:function createFBO(){var _ref11=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref11$color=_ref11.color,color=_ref11$color===void 0?1:_ref11$color,_ref11$blend=_ref11.blend,blend=_ref11$blend===void 0?false:_ref11$blend,_ref11$depth=_ref11.depth,depth=_ref11$depth===void 0?this.options.depth!==false:_ref11$depth,_ref11$stencil=_ref11.stencil,stencil=_ref11$stencil===void 0?!!this.options.stencil:_ref11$stencil;var gl=this.gl;var buffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,buffer);var textures=[];for(var i=0;i<color;i++){var texture=this.createTexture();gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.TEXTURE_2D,texture,0/* level */);textures.push(texture);}buffer.textures=textures;buffer.texture=textures[0];buffer.blend=blend;var _this$canvas2=this.canvas,width=_this$canvas2.width,height=_this$canvas2.height;// Render buffers
  if(depth&&!stencil){buffer.depthBuffer=gl.createRenderbuffer();gl.bindRenderbuffer(gl.RENDERBUFFER,buffer.depthBuffer);gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16,width,height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,buffer.depthBuffer);}if(stencil&&!depth){buffer.stencilBuffer=gl.createRenderbuffer();gl.bindRenderbuffer(gl.RENDERBUFFER,buffer.stencilBuffer);gl.renderbufferStorage(gl.RENDERBUFFER,gl.STENCIL_INDEX8,width,height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.STENCIL_ATTACHMENT,gl.RENDERBUFFER,buffer.stencilBuffer);}if(depth&&stencil){buffer.depthStencilBuffer=gl.createRenderbuffer();gl.bindRenderbuffer(gl.RENDERBUFFER,buffer.depthStencilBuffer);gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_STENCIL,width,height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,buffer.depthStencilBuffer);}gl.bindFramebuffer(gl.FRAMEBUFFER,null);return buffer;}},{key:"bindFBO",value:function bindFBO(){var fbo=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;this.fbo=fbo;}},{key:"render",value:function render(){var _ref12=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_ref12.clearBuffer;this.startRender=true;var gl=this.gl;var program=this.program;if(!program){program=this.createProgram();this.useProgram(program);}if(this.fbo){gl.bindFramebuffer(gl.FRAMEBUFFER,this.fbo);}var depth=this.options.depth;if(depth){gl.enable(gl.DEPTH_TEST);}this.gl.clear(this.gl.COLOR_BUFFER_BIT|(depth?this.gl.DEPTH_BUFFER_BIT:0)|(this.options.stencil?this.gl.STENCIL_BUFFER_BIT:0));var lastFrameID=this._renderFrameID;this._draw();if(this.fbo){gl.bindFramebuffer(gl.FRAMEBUFFER,null);}if(this._renderFrameID===lastFrameID){this._renderFrameID=null;}}},{key:"update",value:function update(){if(!this.startRender)return;if(this._renderFrameID==null){this._renderFrameID=requestAnimationFrame(this.render.bind(this));}}},{key:"program",get:function get(){var gl=this.gl;return gl.getParameter(gl.CURRENT_PROGRAM);}},{key:"isWebGL2",get:function get(){return typeof WebGL2RenderingContext!=='undefined'&&this.gl instanceof WebGL2RenderingContext;}},{key:"enableTextures",get:function get(){return this.program&&this.program._enableTextures;}},{key:"uniforms",get:function get(){var program=this.program;if(!program||!program.uniforms){throw Error('No avaliable program.');}return program.uniforms;}}]);return Renderer;}();_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer,"defaultOptions",{preserveDrawingBuffer:true,autoUpdate:true,vertexPosition:'a_vertexPosition',vertexTextureCoord:'a_vertexTextureCoord',webgl2:false});_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer,"UBYTE",Renderer.UNSIGNED_BYTE);_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer,"USHORT",Renderer.UNSIGNED_SHORT);_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer,"fetchShader",_helpers__WEBPACK_IMPORTED_MODULE_7__["fetchShader"]);_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer,"loadImage",_helpers__WEBPACK_IMPORTED_MODULE_7__["loadImage"]);/***/},function(module,exports,__webpack_require__){module.exports=__webpack_require__(28);/***/},function(module,exports,__webpack_require__){/**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */var runtime=function(exports){var Op=Object.prototype;var hasOwn=Op.hasOwnProperty;var undefined$1;// More compressible than void 0.
  var $Symbol=typeof Symbol==="function"?Symbol:{};var iteratorSymbol=$Symbol.iterator||"@@iterator";var asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator";var toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});return obj[key];}try{// IE 8 has a broken Object.defineProperty that only works on DOM objects.
  define({},"");}catch(err){define=function(obj,key,value){return obj[key]=value;};}function wrap(innerFn,outerFn,self,tryLocsList){// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
  var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator;var generator=Object.create(protoGenerator.prototype);var context=new Context(tryLocsList||[]);// The ._invoke method unifies the implementations of the .next,
  // .throw, and .return methods.
  generator._invoke=makeInvokeMethod(innerFn,self,context);return generator;}exports.wrap=wrap;// Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn,obj,arg){try{return {type:"normal",arg:fn.call(obj,arg)};}catch(err){return {type:"throw",arg:err};}}var GenStateSuspendedStart="suspendedStart";var GenStateSuspendedYield="suspendedYield";var GenStateExecuting="executing";var GenStateCompleted="completed";// Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel={};// Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}// This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype={};IteratorPrototype[iteratorSymbol]=function(){return this;};var getProto=Object.getPrototypeOf;var NativeIteratorPrototype=getProto&&getProto(getProto(values([])));if(NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)){// This environment has a native %IteratorPrototype%; use it instead
  // of the polyfill.
  IteratorPrototype=NativeIteratorPrototype;}var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);GeneratorFunction.prototype=Gp.constructor=GeneratorFunctionPrototype;GeneratorFunctionPrototype.constructor=GeneratorFunction;GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction");// Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype){["next","throw","return"].forEach(function(method){define(prototype,method,function(arg){return this._invoke(method,arg);});});}exports.isGeneratorFunction=function(genFun){var ctor=typeof genFun==="function"&&genFun.constructor;return ctor?ctor===GeneratorFunction||// For the native GeneratorFunction constructor, the best we can
  // do is to check its .name property.
  (ctor.displayName||ctor.name)==="GeneratorFunction":false;};exports.mark=function(genFun){if(Object.setPrototypeOf){Object.setPrototypeOf(genFun,GeneratorFunctionPrototype);}else {genFun.__proto__=GeneratorFunctionPrototype;define(genFun,toStringTagSymbol,"GeneratorFunction");}genFun.prototype=Object.create(Gp);return genFun;};// Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap=function(arg){return {__await:arg};};function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if(record.type==="throw"){reject(record.arg);}else {var result=record.arg;var value=result.value;if(value&&typeof value==="object"&&hasOwn.call(value,"__await")){return PromiseImpl.resolve(value.__await).then(function(value){invoke("next",value,resolve,reject);},function(err){invoke("throw",err,resolve,reject);});}return PromiseImpl.resolve(value).then(function(unwrapped){// When a yielded Promise is resolved, its final value becomes
  // the .value of the Promise<{value,done}> result for the
  // current iteration.
  result.value=unwrapped;resolve(result);},function(error){// If a rejected Promise was yielded, throw the rejection back
  // into the async generator function so it can be handled there.
  return invoke("throw",error,resolve,reject);});}}var previousPromise;function enqueue(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl(function(resolve,reject){invoke(method,arg,resolve,reject);});}return previousPromise=// If enqueue has been called before, then we want to wait until
  // all previous Promises have been resolved before calling invoke,
  // so that results are always delivered in the correct order. If
  // enqueue has not been called before, then it is important to
  // call invoke immediately, without waiting on a callback to fire,
  // so that the async generator function has the opportunity to do
  // any necessary setup in a predictable way. This predictability
  // is why the Promise constructor synchronously invokes its
  // executor callback, and why async functions synchronously
  // execute code before the first await. Since we implement simple
  // async functions in terms of async generators, it is especially
  // important to get this right, even though it requires care.
  previousPromise?previousPromise.then(callInvokeWithMethodAndArg,// Avoid propagating failures to Promises returned by later
  // invocations of the iterator.
  callInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}// Define the unified helper method that is used to implement .next,
  // .throw, and .return (see defineIteratorMethods).
  this._invoke=enqueue;}defineIteratorMethods(AsyncIterator.prototype);AsyncIterator.prototype[asyncIteratorSymbol]=function(){return this;};exports.AsyncIterator=AsyncIterator;// Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){if(PromiseImpl===void 0)PromiseImpl=Promise;var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter// If outerFn is a generator, return the full iterator.
  :iter.next().then(function(result){return result.done?result.value:iter.next();});};function makeInvokeMethod(innerFn,self,context){var state=GenStateSuspendedStart;return function invoke(method,arg){if(state===GenStateExecuting){throw new Error("Generator is already running");}if(state===GenStateCompleted){if(method==="throw"){throw arg;}// Be forgiving, per 25.3.3.3.3 of the spec:
  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
  return doneResult();}context.method=method;context.arg=arg;while(true){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult;}}if(context.method==="next"){// Setting context._sent for legacy support of Babel's
  // function.sent implementation.
  context.sent=context._sent=context.arg;}else if(context.method==="throw"){if(state===GenStateSuspendedStart){state=GenStateCompleted;throw context.arg;}context.dispatchException(context.arg);}else if(context.method==="return"){context.abrupt("return",context.arg);}state=GenStateExecuting;var record=tryCatch(innerFn,self,context);if(record.type==="normal"){// If an exception is thrown from innerFn, we leave state ===
  // GenStateExecuting and loop back for another invocation.
  state=context.done?GenStateCompleted:GenStateSuspendedYield;if(record.arg===ContinueSentinel){continue;}return {value:record.arg,done:context.done};}else if(record.type==="throw"){state=GenStateCompleted;// Dispatch the exception by looping back around to the
  // context.dispatchException(context.arg) call above.
  context.method="throw";context.arg=record.arg;}}};}// Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(method===undefined$1){// A .throw or .return when the delegate iterator has no .throw
  // method always terminates the yield* loop.
  context.delegate=null;if(context.method==="throw"){// Note: ["return"] must be used for ES3 parsing compatibility.
  if(delegate.iterator["return"]){// If the delegate iterator has a return method, give it a
  // chance to clean up.
  context.method="return";context.arg=undefined$1;maybeInvokeDelegate(delegate,context);if(context.method==="throw"){// If maybeInvokeDelegate(context) changed context.method from
  // "return" to "throw", let that override the TypeError below.
  return ContinueSentinel;}}context.method="throw";context.arg=new TypeError("The iterator does not provide a 'throw' method");}return ContinueSentinel;}var record=tryCatch(method,delegate.iterator,context.arg);if(record.type==="throw"){context.method="throw";context.arg=record.arg;context.delegate=null;return ContinueSentinel;}var info=record.arg;if(!info){context.method="throw";context.arg=new TypeError("iterator result is not an object");context.delegate=null;return ContinueSentinel;}if(info.done){// Assign the result of the finished delegate to the temporary
  // variable specified by delegate.resultName (see delegateYield).
  context[delegate.resultName]=info.value;// Resume execution at the desired location (see delegateYield).
  context.next=delegate.nextLoc;// If context.method was "throw" but the delegate handled the
  // exception, let the outer generator proceed normally. If
  // context.method was "next", forget context.arg since it has been
  // "consumed" by the delegate iterator. If context.method was
  // "return", allow the original .return call to continue in the
  // outer generator.
  if(context.method!=="return"){context.method="next";context.arg=undefined$1;}}else {// Re-yield the result returned by the delegate method.
  return info;}// The delegate iterator is finished, so forget it and continue with
  // the outer generator.
  context.delegate=null;return ContinueSentinel;}// Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);define(Gp,toStringTagSymbol,"Generator");// A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol]=function(){return this;};Gp.toString=function(){return "[object Generator]";};function pushTryEntry(locs){var entry={tryLoc:locs[0]};if(1 in locs){entry.catchLoc=locs[1];}if(2 in locs){entry.finallyLoc=locs[2];entry.afterLoc=locs[3];}this.tryEntries.push(entry);}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal";delete record.arg;entry.completion=record;}function Context(tryLocsList){// The root entry object (effectively a try statement without a catch
  // or a finally block) gives us a place to store values thrown from
  // locations where there is no enclosing try statement.
  this.tryEntries=[{tryLoc:"root"}];tryLocsList.forEach(pushTryEntry,this);this.reset(true);}exports.keys=function(object){var keys=[];for(var key in object){keys.push(key);}keys.reverse();// Rather than returning an object with a next method, we keep
  // things simple and return the next function itself.
  return function next(){while(keys.length){var key=keys.pop();if(key in object){next.value=key;next.done=false;return next;}}// To avoid creating an additional object, we just hang the .value
  // and .done properties off the next function object itself. This
  // also ensures that the minifier will not anonymize the function.
  next.done=true;return next;};};function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod){return iteratorMethod.call(iterable);}if(typeof iterable.next==="function"){return iterable;}if(!isNaN(iterable.length)){var i=-1,next=function next(){while(++i<iterable.length){if(hasOwn.call(iterable,i)){next.value=iterable[i];next.done=false;return next;}}next.value=undefined$1;next.done=true;return next;};return next.next=next;}}// Return an iterator with no values.
  return {next:doneResult};}exports.values=values;function doneResult(){return {value:undefined$1,done:true};}Context.prototype={constructor:Context,reset:function(skipTempReset){this.prev=0;this.next=0;// Resetting context._sent for legacy support of Babel's
  // function.sent implementation.
  this.sent=this._sent=undefined$1;this.done=false;this.delegate=null;this.method="next";this.arg=undefined$1;this.tryEntries.forEach(resetTryEntry);if(!skipTempReset){for(var name in this){// Not sure about the optimal order of these conditions:
  if(name.charAt(0)==="t"&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))){this[name]=undefined$1;}}}},stop:function(){this.done=true;var rootEntry=this.tryEntries[0];var rootRecord=rootEntry.completion;if(rootRecord.type==="throw"){throw rootRecord.arg;}return this.rval;},dispatchException:function(exception){if(this.done){throw exception;}var context=this;function handle(loc,caught){record.type="throw";record.arg=exception;context.next=loc;if(caught){// If the dispatched exception was caught by a catch block,
  // then let that catch block handle the exception normally.
  context.method="next";context.arg=undefined$1;}return !!caught;}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];var record=entry.completion;if(entry.tryLoc==="root"){// Exception thrown outside of any try block that could handle
  // it, so set the completion value of the entire function to
  // throw the exception.
  return handle("end");}if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc");var hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}else if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else if(hasCatch){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}}else if(hasFinally){if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else {throw new Error("try statement without catch or finally");}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break;}}if(finallyEntry&&(type==="break"||type==="continue")&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc){// Ignore the finally entry if control is not jumping to a
  // location outside the try/catch block.
  finallyEntry=null;}var record=finallyEntry?finallyEntry.completion:{};record.type=type;record.arg=arg;if(finallyEntry){this.method="next";this.next=finallyEntry.finallyLoc;return ContinueSentinel;}return this.complete(record);},complete:function(record,afterLoc){if(record.type==="throw"){throw record.arg;}if(record.type==="break"||record.type==="continue"){this.next=record.arg;}else if(record.type==="return"){this.rval=this.arg=record.arg;this.method="return";this.next="end";}else if(record.type==="normal"&&afterLoc){this.next=afterLoc;}return ContinueSentinel;},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc){this.complete(entry.completion,entry.afterLoc);resetTryEntry(entry);return ContinueSentinel;}}},"catch":function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if(record.type==="throw"){var thrown=record.arg;resetTryEntry(entry);}return thrown;}}// The context.catch method must only be called with a location
  // argument that corresponds to a known catch block.
  throw new Error("illegal catch attempt");},delegateYield:function(iterable,resultName,nextLoc){this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc};if(this.method==="next"){// Deliberately forget the last sent value so that we don't
  // accidentally pass it on to the delegate.
  this.arg=undefined$1;}return ContinueSentinel;}};// Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;}(// If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports);try{regeneratorRuntime=runtime;}catch(accidentalStrictMode){// This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r","regeneratorRuntime = r")(runtime);}/***/},function(module,exports){function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else {Promise.resolve(value).then(_next,_throw);}}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise(function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value);}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err);}_next(undefined);});};}module.exports=_asyncToGenerator;/***/},function(module,exports){function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}module.exports=_defineProperty;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"setupWebGL",function(){return setupWebGL;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"createProgram",function(){return createProgram;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"pointsToBuffer",function(){return pointsToBuffer;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"loadImage",function(){return loadImage;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"fetchShader",function(){return fetchShader;});/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(27);/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(29);/* harmony import */var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(32);/* harmony import */var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function create3DContext(canvas,opt_attribs){var names=['webgl','experimental-webgl','webkit-3d','moz-webgl'];var context=null;for(var ii=0;ii<names.length;++ii){try{context=canvas.getContext(names[ii],opt_attribs);}catch(e){// no-empty
  }if(context){break;}}return context;}function setupWebGL(canvas,opt_attribs){var context=create3DContext(canvas,opt_attribs);if(!context){throw new Error("Sorry, your browser doesn't support WebGL.");}return context;}function createProgram(gl,vertex,fragment){var vertShdr=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vertShdr,vertex);gl.compileShader(vertShdr);if(!gl.getShaderParameter(vertShdr,gl.COMPILE_STATUS)){var msg="Vertex shader failed to compile.  The error log is:".concat(gl.getShaderInfoLog(vertShdr));throw new Error(msg);}var fragShdr=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fragShdr,fragment);gl.compileShader(fragShdr);if(!gl.getShaderParameter(fragShdr,gl.COMPILE_STATUS)){var _msg="Fragment shader failed to compile.  The error log is:".concat(gl.getShaderInfoLog(fragShdr));throw new Error(_msg);}var program=gl.createProgram();gl.attachShader(program,vertShdr);gl.attachShader(program,fragShdr);gl.linkProgram(program);if(!gl.getProgramParameter(program,gl.LINK_STATUS)){var _msg2="Shader program failed to link.  The error log is:".concat(gl.getProgramInfoLog(program));throw new Error(_msg2);}gl.deleteShader(vertShdr);gl.deleteShader(fragShdr);return program;}function pointsToBuffer(points){var Type=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Float32Array;var buffer=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(buffer&&!(buffer instanceof Type))throw new TypeError('Wrong buffer type.');if(points==null)return points;if(points instanceof Type)return points;if(points[0]==null||points[0].length==null){if(buffer){buffer.set(points,0);return buffer;}return new Type(points);}var deminsion=points[0].length;var len=points.length;if(!buffer){buffer=new Type(deminsion*len);}var idx=0;for(var i=0;i<len;i++){for(var j=0;j<deminsion;j++){buffer[idx++]=points[i][j];}}return buffer;}var imageCache={};function loadImage(src){var _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref$useImageBitmap=_ref.useImageBitmap,useImageBitmap=_ref$useImageBitmap===void 0?true:_ref$useImageBitmap,_ref$alias=_ref.alias,alias=_ref$alias===void 0?null:_ref$alias;if(!imageCache[src]){if(typeof Image==='function'){var img=new Image();if(typeof src==='string'&&!((typeof location==="undefined"?"undefined":_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(location))==='object'&&/^file:/.test(location.href))// eslint-disable-line no-restricted-globals
  &&!/^data:/.test(src)){// base64 dont need crossOrigin - fix early webkit cross domain bug
  img.crossOrigin='anonymous';}imageCache[src]=new Promise(function(resolve){img.onload=function(){if(useImageBitmap&&typeof createImageBitmap==='function'){createImageBitmap(img,{imageOrientation:'flipY'}).then(function(bitmap){imageCache[src]=bitmap;if(alias)imageCache[alias]=bitmap;resolve(bitmap);});}else {imageCache[src]=img;if(alias)imageCache[alias]=img;resolve(img);}};img.src=src;});if(alias)imageCache[alias]=imageCache[src];}else if(typeof fetch==='function'){// run in worker
  return fetch(src,{method:'GET',mode:'cors',cache:'default'}).then(function(response){return response.blob();}).then(function(blob){return createImageBitmap(blob,{imageOrientation:'flipY'}).then(function(bitmap){imageCache[src]=bitmap;if(alias)imageCache[alias]=bitmap;return bitmap;});});}}return imageCache[src];}var shaderCache={};function fetchShader(_x){return _fetchShader.apply(this,arguments);}function _fetchShader(){_fetchShader=_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(url){var res,content;return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!shaderCache[url]){_context.next=2;break;}return _context.abrupt("return",shaderCache[url]);case 2:_context.next=4;return fetch(url);case 4:res=_context.sent;if(!(res.status>=200&&res.status<300)){_context.next=11;break;}_context.next=8;return res.text();case 8:content=_context.sent;shaderCache[url]=content;return _context.abrupt("return",content);case 11:throw new Error('Shader loaded error.');case 12:case"end":return _context.stop();}}},_callee);}));return _fetchShader.apply(this,arguments);}/***/},function(module,exports){function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){module.exports=_typeof=function _typeof(obj){return typeof obj;};}else {module.exports=_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}module.exports=_typeof;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony default export */__webpack_exports__["default"]="attribute vec3 a_vertexPosition;\n\nvoid main() {\n  gl_PointSize = 1.0;\n  gl_Position = vec4(a_vertexPosition, 1);\n}";/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony default export */__webpack_exports__["default"]="#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);\n}";/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony default export */__webpack_exports__["default"]="attribute vec4 a_vertexPosition;\nattribute vec2 a_vertexTextureCoord;\nvarying vec2 vTextureCoord;\n\nvoid main() {\n  gl_PointSize = 1.0;\n  gl_Position = a_vertexPosition;\n  vTextureCoord = a_vertexTextureCoord;\n}";/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return CanvasRenderer;});/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(27);/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);/* harmony import */var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(29);/* harmony import */var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(23);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(24);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__);/* harmony import */var _utils_env__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(37);/* harmony import */var _utils_canvas__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(41);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var _transform=Symbol('transform');var CanvasRenderer=/*#__PURE__*/function(){function CanvasRenderer(canvas,options){_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default()(this,CanvasRenderer);this.context=canvas.getContext('2d');this.options=options;this[_transform]=[1,0,0,1,0,0];}_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(CanvasRenderer,[{key:"createTexture",value:function createTexture(img){var texture={_img:img};return texture;}},{key:"loadTexture",value:function(){var _loadTexture=_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee(textureURL){var image;return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _utils_env__WEBPACK_IMPORTED_MODULE_6__["default"].loadImage(textureURL,{useImageBitmap:false});case 2:image=_context.sent;return _context.abrupt("return",this.createTexture(image));case 4:case"end":return _context.stop();}}},_callee,this);}));function loadTexture(_x){return _loadTexture.apply(this,arguments);}return loadTexture;}()},{key:"deleteTexture",value:function deleteTexture(texture){return texture;}},{key:"clear",value:function clear(x,y,w,h){var context=this.context;x=x||0;y=y||0;w=w||context.canvas.width-x;h=h||context.canvas.height-y;context.clearRect(x,y,w,h);}},{key:"drawMeshCloud",value:function drawMeshCloud(cloud){var _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref$clear=_ref.clear,clear=_ref$clear===void 0?false:_ref$clear;var cloudMeshes=[];for(var i=0;i<cloud.amount;i++){var transform=cloud.getTransform(i);var frame=cloud.getTextureFrame(i);if(frame)frame=frame._img;var filter=cloud.getFilter(i);var _cloud$getCloudRGBA=cloud.getCloudRGBA(i),fill=_cloud$getCloudRGBA.fill,stroke=_cloud$getCloudRGBA.stroke;cloudMeshes.push({mesh:cloud.mesh,_cloudOptions:[fill,stroke,frame,transform,filter]});// console.log(transform, colorTransform, frame);
  }if(cloud.beforeRender)cloud.beforeRender(this.context,cloud);this.drawMeshes(cloudMeshes,{clear:clear,hook:false});if(cloud.afterRender)cloud.afterRender(this.context,cloud);}},{key:"drawMeshes",value:function drawMeshes(meshes){var _this=this;var _ref2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref2$clear=_ref2.clear,clear=_ref2$clear===void 0?false:_ref2$clear,_ref2$hook=_ref2.hook,hook=_ref2$hook===void 0?true:_ref2$hook;var context=this.context;if(clear){context.clearRect(0,0,context.canvas.width,context.canvas.height);}var lastFilter=null;var _context$canvas=context.canvas,width=_context$canvas.width,height=_context$canvas.height;var len=meshes.length;meshes.forEach(function(mesh,i){var fill,stroke,frame,transform,cloudFilter;if(hook&&mesh.beforeRender)mesh.beforeRender(context,mesh);if(mesh._cloudOptions){var _mesh$_cloudOptions=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(mesh._cloudOptions,5);fill=_mesh$_cloudOptions[0];stroke=_mesh$_cloudOptions[1];frame=_mesh$_cloudOptions[2];transform=_mesh$_cloudOptions[3];cloudFilter=_mesh$_cloudOptions[4];mesh=mesh.mesh;}var filter=mesh.filter;if(cloudFilter)filter=filter?"".concat(filter," ").concat(cloudFilter):cloudFilter;if(filter&&!_this.filterBuffer&&_this.filterBuffer!==false){var canvas=_utils_env__WEBPACK_IMPORTED_MODULE_6__["default"].createCanvas(width,height);if(canvas){_this.filterBuffer=canvas.getContext('2d');}else {_this.filterBuffer=false;}}if(lastFilter&&lastFilter!==filter){Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["applyFilter"])(_this.filterBuffer,lastFilter);context.drawImage(_this.filterBuffer.canvas,0,0,width,height);_this.filterBuffer.clearRect(0,0,width,height);lastFilter=null;}if(filter&&_this.filterBuffer){var _this$filterBuffer;_this.filterBuffer.save();(_this$filterBuffer=_this.filterBuffer).transform.apply(_this$filterBuffer,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_this[_transform]));// console.log(this[_transform]);
  Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["drawMesh2D"])(mesh,_this.filterBuffer,false,fill,stroke,frame,transform);_this.filterBuffer.restore();if(i===len-1){Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["applyFilter"])(_this.filterBuffer,filter);context.drawImage(_this.filterBuffer.canvas,0,0,width,height);_this.filterBuffer.clearRect(0,0,width,height);}else {lastFilter=filter;}}else {context.save();context.transform.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_this[_transform]));Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["drawMesh2D"])(mesh,context,false,fill,stroke,frame,transform);context.restore();}if(hook&&mesh.afterRender)mesh.afterRender(context,mesh);});}},{key:"setTransform",value:function setTransform(transform){this[_transform]=transform;}}]);return CanvasRenderer;}();/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* WEBPACK VAR INJECTION */(function(global){/* harmony import */var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(32);/* harmony import */var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var gl_renderer__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(25);/* harmony import */var _parse_font__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(39);/* harmony import */var _vector_to_rgba__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(40);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var cacheMap={};function fontEx(info,ratio){var style=info.style,variant=info.variant,weight=info.weight,stretch=info.stretch,size=info.size,pxLineHeight=info.pxLineHeight,family=info.family;if(stretch==='normal'){// fix iOS10 bug
  return "".concat(style," ").concat(variant," ").concat(weight," ").concat(size*ratio,"px/").concat(pxLineHeight*ratio,"px ").concat(family);}return "".concat(style," ").concat(variant," ").concat(weight," ").concat(stretch," ").concat(size*ratio,"px/").concat(pxLineHeight*ratio,"px ").concat(family);}function createText(text,_ref){var font=_ref.font,fillColor=_ref.fillColor,strokeColor=_ref.strokeColor,strokeWidth=_ref.strokeWidth,_ref$ratio=_ref.ratio,ratio=_ref$ratio===void 0?1:_ref$ratio,textCanvas=_ref.textCanvas,_ref$cachable=_ref.cachable,cachable=_ref$cachable===void 0?false:_ref$cachable;var key;if(cachable){key=[text,font,String(fillColor),String(strokeColor),String(strokeWidth)].join('###');var cachedCanvas=cacheMap[key];if(cachedCanvas)return cachedCanvas;}if(!textCanvas){textCanvas=createCanvas(1,1);}var textContext=textCanvas.getContext('2d');textContext.save();textContext.font=font;var _textContext$measureT=textContext.measureText(text),width=_textContext$measureT.width;textContext.restore();var fontInfo=Object(_parse_font__WEBPACK_IMPORTED_MODULE_3__["default"])(font);var height=Math.max(fontInfo.pxLineHeight,fontInfo.pxHeight*1.13);if(/italic|oblique/.test(font)){width+=height*Math.tan(15*Math.PI/180);}if(!fillColor&&!strokeColor)fillColor='#000';var canvas=textContext.canvas;var w=Math.ceil(width);var h=Math.ceil(height);canvas.width=Math.round(w*ratio);canvas.height=Math.round(h*ratio);textContext.save();textContext.font=fontEx(fontInfo,ratio);textContext.textAlign='center';textContext.textBaseline='middle';var top=canvas.height*0.5+fontInfo.pxHeight*0.05*ratio;var left=canvas.width*0.5;if(fillColor){if(Array.isArray(fillColor))fillColor=Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_4__["default"])(fillColor);else if(fillColor.vector){var gradient;var _fillColor=fillColor,vector=_fillColor.vector,colors=_fillColor.colors;if(vector.length===6){gradient=textContext.createRadialGradient.apply(textContext,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(vector));}else {gradient=textContext.createLinearGradient.apply(textContext,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(vector));}colors.forEach(function(_ref2){var offset=_ref2.offset,color=_ref2.color;gradient.addColorStop(offset,color);});fillColor=gradient;}textContext.fillStyle=fillColor;textContext.fillText(text,left,top);}if(strokeColor){textContext.lineWidth=strokeWidth*ratio;if(Array.isArray(strokeColor))strokeColor=Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_4__["default"])(strokeColor);else if(strokeColor.vector){var _gradient;var _strokeColor=strokeColor,_vector=_strokeColor.vector,_colors=_strokeColor.colors;if(_vector.length===6){_gradient=textContext.createRadialGradient.apply(textContext,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(_vector));}else {_gradient=textContext.createLinearGradient.apply(textContext,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(_vector));}_colors.forEach(function(_ref3){var offset=_ref3.offset,color=_ref3.color;_gradient.addColorStop(offset,color);});strokeColor=_gradient;}textContext.strokeStyle=strokeColor;textContext.strokeText(text,left,top);}textContext.restore();var ret={image:textCanvas,rect:[0,0,w,h]};if(cachable){cacheMap[key]=ret;}return ret;}// Fixed: use offscreen canvas as texture will fail in early chrome.
  var isEarlyChrome=false;if((typeof navigator==="undefined"?"undefined":_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(navigator))==='object'&&typeof navigator.userAgent==='string'){var matched=navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);if(matched){isEarlyChrome=Number(matched[1])<70;}}function createCanvas(width,height){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var offscreen=options.offscreen||!isEarlyChrome&&options.offscreen!==false;var canvas;if(typeof global!=='undefined'&&typeof global.createCanvas==='function'){canvas=global.createCanvas(width,height,options);}else if(offscreen&&typeof OffscreenCanvas==='function'){canvas=new OffscreenCanvas(width,height);}else {canvas=document.createElement('canvas');canvas.width=width;canvas.height=height;}return canvas;}var ENV={createCanvas:createCanvas,createText:createText,loadImage:gl_renderer__WEBPACK_IMPORTED_MODULE_2__["default"].loadImage};/* harmony default export */__webpack_exports__["default"]=ENV;/* WEBPACK VAR INJECTION */}).call(this,__webpack_require__(38));/***/},function(module,exports){var g;// This works in non-strict mode
  g=function(){return this;}();try{// This works if eval is allowed (see CSP)
  g=g||new Function("return this")();}catch(e){// This works if the window reference is available
  if(typeof window==="object")g=window;}// g can still be undefined, but nothing to do about it...
  // We return undefined, instead of nothing here, so it's
  // easier to handle this case. if(!global) { ...}
  module.exports=g;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return parseFont;});__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function sizeToPixel(value,defaultWidth){// eslint-disable-line complexity
  if(typeof value==='string'){var matched=value.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);if(matched){value={size:parseFloat(matched[1]),unit:matched[2]};}else {value={size:parseInt(value,10),unit:'px'};}}var _value=value,size=_value.size,unit=_value.unit;if(unit==='pt'){size/=0.75;}else if(unit==='pc'){size*=16;}else if(unit==='in'){size*=96;}else if(unit==='cm'){size*=96.0/2.54;}else if(unit==='mm'){size*=96.0/25.4;}else if(unit==='em'||unit==='rem'||unit==='ex'){if(!defaultWidth&&typeof getComputedStyle==='function'&&typeof document!=='undefined'){var root=getComputedStyle(document.documentElement).fontSize;defaultWidth=sizeToPixel(root,16);}size*=defaultWidth;if(unit==='ex')size/=2;}else if(unit==='q'){size*=96.0/25.4/4;}else if(unit==='vw'||unit==='vh'){if(typeof document!=='undefined'){var val=unit==='vw'?document.documentElement.clientWidth:document.documentElement.clientHeight;size*=val/100;}}else if(unit==='vmax'||unit==='vmin'){if(typeof document!=='undefined'){var width=document.documentElement.clientWidth;var height=document.documentElement.clientHeight;if(unit==='vmax'){size*=Math.max(width,height)/100;}else {size*=Math.min(width,height)/100;}}}return size;}// borrow from node-canvas (https://github.com/Automattic/node-canvas)
  /**
   * Font RegExp helpers.
   */var weights='bold|bolder|lighter|[1-9]00',styles='italic|oblique',variants='small-caps',stretches='ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded',units='px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%',string="'([^']+)'|\"([^\"]+)\"|([\\w-]|[\u4E00-\u9FA5])+";// [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]?
  //    <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ]
  // https://drafts.csswg.org/css-fonts-3/#font-prop
  var weightRe=new RegExp("(".concat(weights,") +"),'i');var styleRe=new RegExp("(".concat(styles,") +"),'i');var variantRe=new RegExp("(".concat(variants,") +"),'i');var stretchRe=new RegExp("(".concat(stretches,") +"),'i');/* eslint-disable prefer-template */var sizeFamilyRe=new RegExp('([\\d\\.]+)('+units+')(?:\\/([\\d\\.]+)('+units+'))? *'+'((?:'+string+')( *, *(?:'+string+'))*)');/* eslint-enable prefer-template */ /**
   * Parse font `str`.
   *
   * @param {String} str
   * @return {Object} Parsed font. `size` is in device units. `unit` is the unit
   *   appearing in the input string.
   * @api private
   */function parseFont(str,defaultHeight){// Try for required properties first.
  var sizeFamily=sizeFamilyRe.exec(str);if(!sizeFamily)return;// invalid
  var lineHeight=parseFloat(sizeFamily[3]);// Default values and required properties
  var font={weight:'normal',style:'normal',stretch:'normal',variant:'normal',size:parseFloat(sizeFamily[1]),unit:sizeFamily[2],lineHeight:Number.isFinite(lineHeight)?lineHeight:undefined,lineHeightUnit:sizeFamily[4],family:sizeFamily[5].replace(/ *, */g,',')};// Stop search at `sizeFamily.index`
  var substr=str.substring(0,sizeFamily.index);// Optional, unordered properties.
  var weight=weightRe.exec(substr),style=styleRe.exec(substr),variant=variantRe.exec(substr),stretch=stretchRe.exec(substr);if(weight)font.weight=weight[1];if(style)font.style=style[1];if(variant)font.variant=variant[1];if(stretch)font.stretch=stretch[1];font.pxHeight=sizeToPixel({size:font.size,unit:font.unit},defaultHeight);font.pxLineHeight=sizeToPixel({size:font.lineHeight||font.size,unit:font.lineHeightUnit||font.unit},defaultHeight);return font;}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return vectorToRGBA;});__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function vectorToRGBA(vector){return "rgba(".concat(vector.map(function(c,i){if(i<3)return Math.round(c*255);return c;}).join(),")");}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"applyFilter",function(){return applyFilter;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"drawMesh2D",function(){return drawMesh2D;});/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var gl_matrix__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(1);/* harmony import */var _vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(40);/* harmony import */var _parse_font__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(39);/* harmony import */var _math__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(42);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function applyFilter(context,filter){var canvas=context.canvas;context.save();context.filter=filter;context.drawImage(canvas,0,0,canvas.width,canvas.height);context.restore();}function mixRGBA(a,b){var pattern=/rgba\((\d+),(\d+),(\d+),(\d+)\)/;a=a.match(pattern).slice(1,5).map(Number);b=b.match(pattern).slice(1,5).map(Number);var c=[];var alpha=b[3];for(var i=0;i<4;i++){c[i]=Object(_math__WEBPACK_IMPORTED_MODULE_4__["mix"])(a[i],b[i],alpha);}return "rgba(".concat(c.join(),")");}function drawMesh2D(mesh,context){var enableFilter=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var cloudFill=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;var cloudStroke=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var cloudFrame=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;var cloudTransform=arguments.length>6&&arguments[6]!==undefined?arguments[6]:null;context.save();var stroke=false;var fill=false;context.globalAlpha=mesh.getOpacity();if(mesh._updateMatrix){var acc=mesh.transformScale/mesh.contours.scale;if(acc>1.5){mesh.accurate(mesh.transformScale);}}if(mesh.lineWidth){var _gradient=mesh.gradient&&mesh.gradient.stroke;if(_gradient){var _gradient2=_gradient,vector=_gradient2.vector,colors=_gradient2.colors;if(vector.length===6){_gradient=context.createRadialGradient.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(vector));}else if(vector.length===4){_gradient=context.createLinearGradient.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(vector));}else if(vector.length===3){_gradient=context.createCircularGradient.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(vector));}else {throw new TypeError('Invalid vector dimension.');}colors.forEach(function(_ref){var offset=_ref.offset,color=_ref.color;var rgba=Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(color);if(cloudStroke)rgba=mixRGBA(rgba,cloudStroke);_gradient.addColorStop(offset,rgba);});context.strokeStyle=_gradient;stroke=true;}else if(mesh.strokeStyle){if(cloudStroke){context.strokeStyle=mixRGBA(mesh.strokeStyle,cloudStroke);}else {context.strokeStyle=mesh.strokeStyle;}stroke=true;}}if(stroke){context.lineWidth=mesh.lineWidth;context.lineJoin=mesh.lineJoin;context.lineCap=mesh.lineCap;context.miterLimit=mesh.miterLimit;if(mesh.lineDash){context.setLineDash(mesh.lineDash);if(mesh.lineDashOffset){context.lineDashOffset=mesh.lineDashOffset;}}}var gradient=mesh.gradient&&mesh.gradient.fill;if(gradient){var _gradient3=gradient,_vector=_gradient3.vector,_colors=_gradient3.colors;if(_vector.length===6){gradient=context.createRadialGradient.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_vector));}else if(_vector.length===4){gradient=context.createLinearGradient.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_vector));}else if(_vector.length===3){gradient=context.createCircularGradient.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_vector));}else {throw new TypeError('Invalid vector dimension.');}_colors.forEach(function(_ref2){var offset=_ref2.offset,color=_ref2.color;var rgba=Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(color);if(cloudStroke)rgba=mixRGBA(rgba,cloudStroke);gradient.addColorStop(offset,rgba);});context.fillStyle=gradient;fill=true;}else if(mesh.fillStyle){if(cloudFill){context.fillStyle=mixRGBA(mesh.fillStyle,cloudFill);}else {context.fillStyle=mesh.fillStyle;}fill=true;}// if(enableFilter) {
  //   const filter = mesh.filter;
  //   if(filter) {
  //     context.filter = filter;
  //   }
  // }
  if(cloudTransform){context.transform.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(cloudTransform));}context.transform.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.transformMatrix));if(mesh.clipPath){var clipPath=mesh.clipPath;var path=new Path2D(clipPath);context.clip(path);}var count=mesh.contours.length;mesh.contours.forEach(function(points,i){// eslint-disable-line complexity
  var len=points.length;var closed=len>1&&gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec2"].equals(points[0],points[len-1]);var drawTexture=i===count-1&&mesh.texture;if(points&&len>0){if(fill||stroke||drawTexture){context.beginPath();context.moveTo.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[0]));for(var _i=1;_i<len;_i++){if(_i===len-1&&closed){context.closePath();}else {context.lineTo.apply(context,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[_i]));}}}if(fill){context.fill(mesh.fillRule);}if(drawTexture){context.save();context.clip();var _mesh$texture=mesh.texture,image=_mesh$texture.image,options=_mesh$texture.options;if(cloudFrame)image=cloudFrame;if(options.repeat)console.warn('Context 2D not supported image repeat yet.');if(image.font){if(options.scale)console.warn('Context 2D not supported text scale yet.');if(options.srcRect)console.warn('Context 2D not supported text srcRect yet.');var _image=image,font=_image.font,fillColor=_image.fillColor,strokeColor=_image.strokeColor,strokeWidth=_image.strokeWidth,text=_image.text;if(!fillColor&&!strokeColor)fillColor='#000';if(Array.isArray(fillColor))fillColor=Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(fillColor);if(Array.isArray(strokeColor))strokeColor=Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(strokeColor);context.font=font;var _context$measureText=context.measureText(text),width=_context$measureText.width;var fontInfo=Object(_parse_font__WEBPACK_IMPORTED_MODULE_3__["default"])(font);var height=Math.max(fontInfo.pxLineHeight,fontInfo.pxHeight*1.13);context.textAlign='center';context.textBaseline='middle';// text ignore rect scale
  var rect=options.rect;var top=rect[0]+height*0.5+fontInfo.pxHeight*0.06;var left=rect[1]+width*0.5;if(rect[2]!=null){context.scale(rect[2]/width,rect[3]/height);}if(fillColor){context.fillStyle=fillColor;context.fillText(text,left,top);}if(strokeColor){context.lineWidth=strokeWidth;context.strokeStyle=strokeColor;context.strokeText(text,left,top);}}else {var _rect=options.rect;var srcRect=options.srcRect;if(options.scale){_rect=[0,0,context.canvas.width,context.canvas.height];}if(options.rotated&&_rect){_rect=[-_rect[1],_rect[0],_rect[3],_rect[2]];}if(srcRect){_rect=_rect||[0,0,srcRect[2],srcRect[3]];}if(options.rotated){context.translate(0,_rect?_rect[2]:image.width);context.rotate(-0.5*Math.PI);}if(srcRect){context.drawImage.apply(context,[image].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(srcRect),_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_rect)));}else if(_rect){context.drawImage.apply(context,[image].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_rect)));}else {context.drawImage(image,0,0);}}context.restore();}if(stroke){context.stroke();}}});context.restore();if(enableFilter){var filter=mesh.filter;if(filter){applyFilter(context,filter);}}}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clamp",function(){return clamp;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"mix",function(){return mix;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"transformPoint",function(){return transformPoint;});/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function clamp(value,min,max){if(min>max){var _ref=[max,min];min=_ref[0];max=_ref[1];}if(value<min)return min;if(value>max)return max;return value;}function mix(src,dest,p){return src*(1-p)+dest*p;}function transformPoint(p,m){var _p=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(p,2),x=_p[0],y=_p[1];return [x*m[0]+y*m[2]+m[4],x*m[1]+y*m[3]+m[5]];}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return compress;});/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(27);/* harmony import */var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _flatten_meshes__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(44);/* harmony import */var _mesh_cloud__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(45);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var _marked=/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(compress);function compareUniform(a,b,temp){var ua=a.uniforms||{};var ub=b.uniforms||{};if(ua.u_texSampler&&ub.u_texSampler&&ua.u_texSampler!==ub.u_texSampler)return false;var keysA=Object.keys(ua),keysB=Object.keys(ub);// console.log(keysA, keysB);
  var idx1=keysA.indexOf('u_texSampler');var idx2=keysB.indexOf('u_texSampler');if(idx1>=0)keysA.splice(idx1,1);if(idx2>=0)keysB.splice(idx2,1);if(keysA.length!==keysB.length)return false;var ret=keysA.every(function(key){var va=ua[key],vb=ub[key];if(va===vb)return true;if(va.length&&vb.length&&va.length===vb.length){for(var i=0;i<va.length;i++){if(va[i]!==vb[i])return false;}return true;}return false;});if(ret){if(ua.u_texSampler&&!ub.u_texSampler){b.setTexture(ua.u_texSampler,{hidden:true});}else if(!ua.u_texSampler&&ub.u_texSampler){// a.setTexture(ub.u_texSampler, {hidden: true});
  for(var i=0;i<temp.length;i++){temp[i].setTexture(ub.u_texSampler,{hidden:true});}}}return ret;}var bufferCache={};function packData(temp,enableBlend){if(temp.length){var meshData=Object(_flatten_meshes__WEBPACK_IMPORTED_MODULE_1__["default"])(temp,bufferCache);meshData.enableBlend=enableBlend;if(temp[0].filterCanvas){meshData.filterCanvas=true;}meshData.packIndex=temp[0].packIndex;meshData.packLength=temp.length;meshData.beforeRender=temp[0].beforeRender;meshData.pass=temp[0].pass;meshData.afterRender=temp[temp.length-1].afterRender;temp.length=0;return meshData;}}function compress(renderer,meshes){var ignoreTrasnparent,temp,maxSize,size,enableBlend,i,mesh,meshData,texture,len,filterCanvas,lastMesh,_args=arguments;return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function compress$(_context){while(1){switch(_context.prev=_context.next){case 0:ignoreTrasnparent=_args.length>2&&_args[2]!==undefined?_args[2]:false;temp=[];maxSize=renderer.options.bufferSize;size=0;enableBlend=false;i=0;case 6:if(!(i<meshes.length)){_context.next=50;break;}mesh=meshes[i];if(!(mesh instanceof _mesh_cloud__WEBPACK_IMPORTED_MODULE_2__["default"])){_context.next=18;break;}if(!temp.length){_context.next=12;break;}_context.next=12;return packData(temp,enableBlend);case 12:size=0;enableBlend=false;_context.next=16;return mesh;case 16:_context.next=47;break;case 18:meshData=mesh.meshData;if(meshData.clipPath&&!meshData.uniforms.u_clipSampler){texture=renderer.createTexture(meshData.clipPath);meshData.uniforms.u_clipSampler=texture;}len=0;if(!((!ignoreTrasnparent||!mesh.canIgnore())&&meshData&&meshData.positions.length)){_context.next=43;break;}mesh.packIndex=i;filterCanvas=mesh.filterCanvas;len=meshData.positions.length;if(!(filterCanvas||size+len>maxSize)){_context.next=33;break;}if(!temp.length){_context.next=29;break;}_context.next=29;return packData(temp,enableBlend);case 29:size=0;enableBlend=false;_context.next=40;break;case 33:if(!size){_context.next=40;break;}lastMesh=temp[temp.length-1];if(!(lastMesh&&(lastMesh.filterCanvas||lastMesh.afterRender||mesh.beforeRender||lastMesh.pass.length||mesh.pass.length||lastMesh.program!==mesh.program||!compareUniform(lastMesh,mesh,temp)))){_context.next=40;break;}_context.next=38;return packData(temp,enableBlend);case 38:size=0;enableBlend=false;case 40:temp.push(mesh);enableBlend=enableBlend||mesh.enableBlend;size+=len;case 43:if(!(i===meshes.length-1)){_context.next=47;break;}if(!temp.length){_context.next=47;break;}_context.next=47;return packData(temp,enableBlend);case 47:i++;_context.next=6;break;case 50:case"end":return _context.stop();}}},_marked);}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return flattenMeshes;});/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var typeMap={UNSIGNED_BYTE:Uint8Array,UNSIGNED_SHORT:Uint16Array,BYTE:Int8Array,SHORT:Int16Array,FLOAT:Float32Array};function allocateBuffer(meshes,bufferCache){// eslint-disable-line complexity
  var positionsCount=0;var cellsCount=0;var textureCoordCount=0;var sourceRectCount=0;var clipUVCount=0;var colorCount=0;var count=0;var program=meshes[0].program;for(var i=0;i<meshes.length;i++){var mesh=meshes[i].meshData;if(mesh){count+=mesh.positions.length;var dimension=mesh.positions[0].length;positionsCount+=mesh.positions.length*dimension;cellsCount+=mesh.cells.length*3;colorCount+=mesh.attributes.a_color.length*4;var _textureCoord=mesh.textureCoord;if(_textureCoord){textureCoordCount+=_textureCoord.length*_textureCoord[0].length;}var _sourceRect=mesh.attributes.a_sourceRect;if(_sourceRect){sourceRectCount+=_sourceRect.length*4;}var _clipUV=mesh.attributes.a_clipUV;if(_clipUV){clipUVCount+=_clipUV.length*2;}}}if(!bufferCache.positions||bufferCache.positions.length<positionsCount){bufferCache.positions=new Float32Array(positionsCount);}if(!bufferCache.cells||bufferCache.cells.length<cellsCount){bufferCache.cells=new Uint16Array(cellsCount);}if(textureCoordCount){if(!bufferCache.textureCoord||bufferCache.textureCoord.length<textureCoordCount){bufferCache.textureCoord=new Float32Array(textureCoordCount);}}if(!bufferCache.a_color||bufferCache.a_color.length<colorCount){bufferCache.a_color=new Uint8Array(colorCount);}if(sourceRectCount){if(!bufferCache.a_sourceRect||bufferCache.a_sourceRect.length<sourceRectCount){bufferCache.a_sourceRect=new Float32Array(sourceRectCount);}}if(clipUVCount){if(!bufferCache.a_clipUV||bufferCache.a_clipUV.length<clipUVCount){bufferCache.a_clipUV=new Float32Array(clipUVCount);}}if(program){var attribs=Object.entries(program._attribute);var meta=program._attribOpts||{};for(var _i=0;_i<attribs.length;_i++){var _attribs$_i=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(attribs[_i],2),key=_attribs$_i[0],opts=_attribs$_i[1];if(key!=='a_color'&&key!=='a_sourceRect'&&opts!=='ignored'){var type=meta[key]?meta[key].type:'FLOAT';var TypeArray=typeMap[type];var attribCount=opts.size*count;if(!bufferCache[key]||bufferCache[key].length<attribCount){bufferCache[key]=new TypeArray(attribCount);}}}}return bufferCache;}function flattenMeshes(meshes,bufferCache){// eslint-disable-line complexity
  var positions=[];var cells=[];var textureCoord=[];var a_color=[];var a_sourceRect=[];// sourceRect no buffer;
  var a_clipUV=[];// uv no buffer
  var idx=0;var cidx=0;var uniforms=meshes[0]?meshes[0].uniforms||{}:{};var program=meshes[0]?meshes[0].program:null;if(bufferCache){allocateBuffer(meshes,bufferCache);cells=bufferCache.cells;positions=bufferCache.positions;textureCoord=bufferCache.textureCoord;a_color=bufferCache.a_color;a_sourceRect=bufferCache.a_sourceRect;a_clipUV=bufferCache.a_clipUV;}var hasSourceRect=false;var hasClipPath=false;var attributes={};for(var i=0;i<meshes.length;i++){var mesh=meshes[i];if(mesh){if(mesh.meshData)mesh=mesh.meshData;if(bufferCache){var _positions=mesh.positions;for(var j=0;j<_positions.length;j++){var p=_positions[j];var o=3*(idx+j);for(var k=0;k<p.length;k++){positions[o+k]=p[k];}}}else {var _positions2;(_positions2=positions).push.apply(_positions2,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.positions));}var _cells=mesh.cells;for(var _j=0;_j<_cells.length;_j++){var cell=_cells[_j];if(bufferCache){var _o=3*(cidx+_j);cells[_o]=cell[0]+idx;cells[_o+1]=cell[1]+idx;cells[_o+2]=cell[2]+idx;}else {cells.push([cell[0]+idx,cell[1]+idx,cell[2]+idx]);}}// cells.push(...mesh.cells.map(cell => cell.map(c => c + idx)));
  if(bufferCache){var _colors=mesh.attributes.a_color;for(var _j2=0;_j2<_colors.length;_j2++){var c=_colors[_j2];var _o2=4*(idx+_j2);a_color[_o2]=c[0];a_color[_o2+1]=c[1];a_color[_o2+2]=c[2];a_color[_o2+3]=c[3];}}else {var _a_color;(_a_color=a_color).push.apply(_a_color,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes.a_color));}if(mesh.attributes.a_sourceRect){hasSourceRect=true;if(bufferCache){var _sourceRect=mesh.attributes.a_sourceRect;for(var _j3=0;_j3<_sourceRect.length;_j3++){var s=_sourceRect[_j3];var _o3=4*(idx+_j3);a_sourceRect[_o3]=s[0];a_sourceRect[_o3+1]=s[1];a_sourceRect[_o3+2]=s[2];a_sourceRect[_o3+3]=s[3];}}else {var _a_sourceRect;(_a_sourceRect=a_sourceRect).push.apply(_a_sourceRect,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes.a_sourceRect));}}if(mesh.attributes.a_clipUV){hasClipPath=true;if(bufferCache){var _clipUV=mesh.attributes.a_clipUV;for(var _j4=0;_j4<_clipUV.length;_j4++){var _s=_clipUV[_j4];var _o4=2*(idx+_j4);a_clipUV[_o4]=_s[0];a_clipUV[_o4+1]=_s[1];}}else {var _a_clipUV;(_a_clipUV=a_clipUV).push.apply(_a_clipUV,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes.a_clipUV));}}if(mesh.textureCoord){if(bufferCache){var _textureCoord=mesh.textureCoord;for(var _j5=0;_j5<_textureCoord.length;_j5++){var t=_textureCoord[_j5];var _o5=3*(idx+_j5);for(var _k=0;_k<t.length;_k++){textureCoord[_o5+_k]=t[_k];}}}else {var _textureCoord2;(_textureCoord2=textureCoord).push.apply(_textureCoord2,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.textureCoord));}}if(program){var attribs=Object.entries(program._attribute);for(var _j6=0;_j6<attribs.length;_j6++){var _attribs$_j=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(attribs[_j6],2),name=_attribs$_j[0],opts=_attribs$_j[1];if(name!=='a_color'&&name!=='a_sourceRect'&&opts!=='ignored'){attributes[name]=[];if(bufferCache){attributes[name]=bufferCache[name];var _attr=mesh.attributes[name];var size=_attr[0].length;for(var _k2=0;_k2<_attr.length;_k2++){var _t=_attr[_k2];var _o6=size*(idx+_k2);for(var w=0;w<_t.length;w++){attributes[name][_o6+w]=_t[w];}}}else {var _attributes$name;(_attributes$name=attributes[name]).push.apply(_attributes$name,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes[name]));}}}}idx+=mesh.positions.length;cidx+=mesh.cells.length;}}attributes.a_color=a_color;if(hasSourceRect&&a_sourceRect&&a_sourceRect.length>0)attributes.a_sourceRect=a_sourceRect;var ret={positions:positions,cells:cells,attributes:attributes,uniforms:uniforms,cellsCount:cidx*3,program:program};if(textureCoord&&textureCoord.length){ret.textureCoord=textureCoord;}if(hasClipPath&&a_clipUV.length>0)attributes.a_clipUV=a_clipUV;return ret;}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return _default;});/* harmony import */var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(30);/* harmony import */var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(23);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(24);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__);/* harmony import */var gl_matrix__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(1);/* harmony import */var _utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(46);/* harmony import */var _utils_math__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(42);/* harmony import */var _utils_parse_color__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(47);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else {ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}var _mesh=Symbol('mesh');var _count=Symbol('count');var _blend=Symbol('blend');var _filters=Symbol('filter');var _textures=Symbol('textures');var _textureOptions=Symbol('textureOptions');var _hasCloudColor=Symbol('cloudColor');var _hasCloudFilter=Symbol('cloudFilter');var _buffer=Symbol('buffer');function createBuffer(buffer){var oldBuffer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var transform0=new Float32Array(3*buffer);var transform1=new Float32Array(3*buffer);var color0=new Float32Array(4*buffer);var color1=new Float32Array(4*buffer);var color2=new Float32Array(4*buffer);var color3=new Float32Array(4*buffer);var color4=new Float32Array(4*buffer);var frameIndex=new Uint8Array(buffer);var fillColor=new Uint8Array(4*buffer);var strokeColor=new Uint8Array(4*buffer);if(oldBuffer){transform0.set(oldBuffer.transform0,0);transform1.set(oldBuffer.transform1,0);color0.set(oldBuffer.color0,0);color1.set(oldBuffer.color1,0);color2.set(oldBuffer.color2,0);color3.set(oldBuffer.color3,0);color4.set(oldBuffer.color4,0);frameIndex.set(oldBuffer.frameIndex,0);fillColor.set(oldBuffer.fillColor,0);strokeColor.set(oldBuffer.strokeColor,0);}return {bufferSize:buffer,transform0:transform0,transform1:transform1,color0:color0,color1:color1,color2:color2,color3:color3,color4:color4,frameIndex:frameIndex,fillColor:fillColor,strokeColor:strokeColor};}var _default=/*#__PURE__*/function(){function _default(mesh){var amount=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var _ref=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref$buffer=_ref.buffer,buffer=_ref$buffer===void 0?1000:_ref$buffer;_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this,_default);buffer=Math.max(buffer,amount);this[_count]=amount;this[_mesh]=mesh;this[_buffer]=createBuffer(buffer);this[_textures]=[];this[_filters]=[];this[_hasCloudColor]=false;this[_hasCloudFilter]=false;this[_blend]=false;this.initBuffer();}_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(_default,[{key:"initBuffer",value:function initBuffer(){var offset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var amount=this[_count];for(var i=offset;i<amount;i++){this[_buffer].transform0.set([1,0,0],i*3);this[_buffer].transform1.set([0,1,0],i*3);this[_buffer].frameIndex.set([-1],i);this[_buffer].fillColor.set([0,0,0,0],i*4);this[_buffer].strokeColor.set([0,0,0,0],i*4);this.setColorTransform(i,null);}}},{key:"_getFilter",value:function _getFilter(idx){this[_filters][idx]=this[_filters][idx]||[];return this[_filters][idx];}},{key:"getFilter",value:function getFilter(idx){return this._getFilter(idx).join(' ');}},{key:"canIgnore",value:function canIgnore(){return this[_mesh].canIgnore();}},{key:"delete",value:function _delete(idx){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');var _this$_buffer=this[_buffer],transform0=_this$_buffer.transform0,transform1=_this$_buffer.transform1,color0=_this$_buffer.color0,color1=_this$_buffer.color1,color2=_this$_buffer.color2,color3=_this$_buffer.color3,color4=_this$_buffer.color4,frameIndex=_this$_buffer.frameIndex,fillColor=_this$_buffer.fillColor,strokeColor=_this$_buffer.strokeColor;transform0.set(transform0.subarray(3*(idx+1)),3*idx);transform1.set(transform1.subarray(3*(idx+1)),3*idx);color0.set(color0.subarray(4*(idx+1)),4*idx);color1.set(color1.subarray(4*(idx+1)),4*idx);color2.set(color2.subarray(4*(idx+1)),4*idx);color3.set(color3.subarray(4*(idx+1)),4*idx);color4.set(color4.subarray(4*(idx+1)),4*idx);frameIndex.set(frameIndex.subarray(idx+1),idx);fillColor.set(fillColor.subarray(4*(idx+1)),4*idx);strokeColor.set(strokeColor.subarray(4*(idx+1)),4*idx);for(var i in this[_filters]){// eslint-disable-line no-restricted-syntax
  if(i===idx){delete this[_filters][i];}else if(i>idx){this[_filters][i-1]=this[_filters][i];delete this[_filters][i];}}this[_count]--;}},{key:"setColorTransform",value:function setColorTransform(idx,m){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');idx*=4;var _this$_buffer2=this[_buffer],color0=_this$_buffer2.color0,color1=_this$_buffer2.color1,color2=_this$_buffer2.color2,color3=_this$_buffer2.color3,color4=_this$_buffer2.color4;if(m!=null){color0.set([m[0],m[5],m[10],m[15]],idx);color1.set([m[1],m[6],m[11],m[16]],idx);color2.set([m[2],m[7],m[12],m[17]],idx);color3.set([m[3],m[8],m[13],m[18]],idx);color4.set([m[4],m[9],m[14],m[19]],idx);this[_blend]=this[_blend]||m[18]<1.0;this[_hasCloudFilter]=true;}else {color0.set([1,0,0,0],idx);color1.set([0,1,0,0],idx);color2.set([0,0,1,0],idx);color3.set([0,0,0,1],idx);color4.set([0,0,0,0],idx);}return this;}},{key:"getColorTransform",value:function getColorTransform(idx){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');idx*=4;var _this$_buffer3=this[_buffer],color0=_this$_buffer3.color0,color1=_this$_buffer3.color1,color2=_this$_buffer3.color2,color3=_this$_buffer3.color3,color4=_this$_buffer3.color4;return [color0[idx],color1[idx],color2[idx],color3[idx],color4[idx],color0[idx+1],color1[idx+1],color2[idx+1],color3[idx+1],color4[idx+1],color0[idx+2],color1[idx+2],color2[idx+2],color3[idx+2],color4[idx+2],color0[idx+3],color1[idx+3],color2[idx+3],color3[idx+3],color4[idx+3]];}},{key:"transformColor",value:function transformColor(idx,m){var transform=this.getColorTransform(idx);transform=Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["multiply"])(transform,m);this.setColorTransform(idx,transform);return this;}},{key:"setFillColor",value:function setFillColor(idx,color){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');if(typeof color==='string')color=Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_8__["default"])(color);if(color[3]>0.0)this[_hasCloudColor]=true;this[_buffer].fillColor.set(color.map(function(c){return Math.round(255*c);}),4*idx);}},{key:"setStrokeColor",value:function setStrokeColor(idx,color){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');if(typeof color==='string')color=Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_8__["default"])(color);if(color[3]>0.0)this[_hasCloudColor]=true;this[_buffer].strokeColor.set(color.map(function(c){return Math.round(255*c);}),4*idx);}},{key:"getCloudRGBA",value:function getCloudRGBA(idx){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');idx*=4;var _this$_buffer4=this[_buffer],fillColor=_this$_buffer4.fillColor,strokeColor=_this$_buffer4.strokeColor;var _fillColor=[fillColor[idx],fillColor[idx+1],fillColor[idx+2],fillColor[idx+3]];var _strokeColor=[strokeColor[idx],strokeColor[idx+1],strokeColor[idx+2],strokeColor[idx+3]];_fillColor[3]/=255;_strokeColor[3]/=255;return {fill:"rgba(".concat(_fillColor.join(),")"),stroke:"rgba(".concat(_strokeColor.join(),")")};}},{key:"grayscale",value:function grayscale(idx,p){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["grayscale"])(p));this._getFilter(idx).push("grayscale(".concat(100*p,"%)"));}},{key:"brightness",value:function brightness(idx,p){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["brightness"])(p));this._getFilter(idx).push("brightness(".concat(100*p,"%)"));}},{key:"saturate",value:function saturate(idx,p){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["saturate"])(p));this._getFilter(idx).push("saturate(".concat(100*p,"%)"));}},{key:"contrast",value:function contrast(idx,p){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["contrast"])(p));this._getFilter(idx).push("contrast(".concat(100*p,"%)"));}},{key:"invert",value:function invert(idx,p){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["invert"])(p));this._getFilter(idx).push("invert(".concat(100*p,"%)"));}},{key:"sepia",value:function sepia(idx,p){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["sepia"])(p));this._getFilter(idx).push("sepia(".concat(100*p,"%)"));}},{key:"opacity",value:function opacity(idx,p){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["opacity"])(p));this._getFilter(idx).push("opacity(".concat(100*p,"%)"));}},{key:"hueRotate",value:function hueRotate(idx,deg){this.transformColor(idx,Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["hueRotate"])(deg));this._getFilter(idx).push("hue-rotate(".concat(deg,"deg)"));}},{key:"setTransform",value:function setTransform(idx,m){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');idx*=3;if(m==null)m=[1,0,0,1,0,0];var _this$_buffer5=this[_buffer],transform0=_this$_buffer5.transform0,transform1=_this$_buffer5.transform1;transform0.set([m[0],m[2],m[4]],idx);transform1.set([m[1],m[3],m[5]],idx);return this;}},{key:"getTransform",value:function getTransform(idx){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');idx*=3;var _this$_buffer6=this[_buffer],transform0=_this$_buffer6.transform0,transform1=_this$_buffer6.transform1;var m=[transform0[idx],transform1[idx],transform0[idx+1],transform1[idx+1],transform0[idx+2],transform1[idx+2]];return m;}},{key:"getTextureFrame",value:function getTextureFrame(idx){return this[_textures][this[_buffer].frameIndex[idx]];}},{key:"setTextureFrames",value:function setTextureFrames(){var frames=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(frames.length>12){throw new Error('Max frames exceed. Allow 12 frames.');}if(frames.length){var mesh=this[_mesh];mesh.setTexture(frames[0],options);}this[_textures]=frames;this[_textureOptions]=options;}},{key:"setFrameIndex",value:function setFrameIndex(idx,frameIndex){if(idx>=this[_count]||idx<0)throw new Error('Out of range.');var len=this[_textures].length;if(len<=0)throw new Error('No frames');this[_buffer].frameIndex[idx]=frameIndex%len;}},{key:"setProgram",value:function setProgram(program){this[_mesh].setProgram(program);}},{key:"transform",value:function transform(idx,m){var transform=this.getTransform(idx);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0,0,0,0,0,0),transform,m);this.setTransform(idx,m);return this;}},{key:"translate",value:function translate(idx,_ref2){var _ref3=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref2,2),x=_ref3[0],y=_ref3[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[x,y]);return this.transform(idx,m);}},{key:"rotate",value:function rotate(idx,rad){var _ref4=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[0,0],_ref5=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref4,2),ox=_ref5[0],oy=_ref5[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].rotate(Array.of(0,0,0,0,0,0),m,rad);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[-ox,-oy]);return this.transform(idx,m);}},{key:"scale",value:function scale(idx,_ref6){var _ref7=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref6,2),x=_ref7[0],_ref7$=_ref7[1],y=_ref7$===void 0?x:_ref7$;var _ref8=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[0,0],_ref9=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref8,2),ox=_ref9[0],oy=_ref9[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].scale(Array.of(0,0,0,0,0,0),m,[x,y]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[-ox,-oy]);return this.transform(idx,m);}},{key:"skew",value:function skew(idx,_ref10){var _ref11=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref10,2),x=_ref11[0],_ref11$=_ref11[1],y=_ref11$===void 0?x:_ref11$;var _ref12=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[0,0],_ref13=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref12,2),ox=_ref13[0],oy=_ref13[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0,0,0,0,0,0),m,gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].fromValues(1,Math.tan(y),Math.tan(x),1,0,0));m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[-ox,-oy]);return this.transform(idx,m);}},{key:"isPointCollision",value:function isPointCollision(idx,_ref14){var _this$_mesh;var _ref15=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref14,2),x=_ref15[0],y=_ref15[1];var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'both';var m=this.getTransform(idx);var p=Object(_utils_math__WEBPACK_IMPORTED_MODULE_7__["transformPoint"])([x,y],gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].invert(Array.of(0,0,0,0,0,0),m));return (_this$_mesh=this[_mesh]).isPointCollision.apply(_this$_mesh,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(p).concat([type]));}},{key:"isPointInFill",value:function isPointInFill(idx,_ref16){var _ref17=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref16,2),x=_ref17[0],y=_ref17[1];return this.isPointCollision(idx,[x,y],'fill');}},{key:"isPointInStroke",value:function isPointInStroke(idx,_ref18){var _ref19=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref18,2),x=_ref19[0],y=_ref19[1];return this.isPointCollision(idx,[x,y],'stroke');}},{key:"bufferSize",get:function get(){return this[_buffer].bufferSize;}},{key:"mesh",get:function get(){return this[_mesh];},set:function set(mesh){this[_mesh]=mesh;if(this[_textures]){this.setTextureFrames(this[_textures],this[_textureOptions]);}}},{key:"hasCloudColor",get:function get(){return this[_hasCloudColor];}},{key:"hasCloudFilter",get:function get(){return this[_hasCloudFilter];}},{key:"enableBlend",get:function get(){return this[_mesh].enableBlend||this[_blend];}},{key:"amount",get:function get(){return this[_count];},set:function set(value){var amount=this[_count];if(value===amount)return;if(value>this[_buffer].bufferSize){this[_buffer]=createBuffer(Math.max(value,this[_buffer].bufferSize+1000),this[_buffer]);}this[_count]=value;if(value>amount){this.initBuffer(amount);}}},{key:"meshData",get:function get(){var _this$_mesh$meshData=this[_mesh].meshData,attributes=_this$_mesh$meshData.attributes,cells=_this$_mesh$meshData.cells,positions=_this$_mesh$meshData.positions,textureCoord=_this$_mesh$meshData.textureCoord,uniforms=_this$_mesh$meshData.uniforms;var frames=this[_textures];var meshData={attributes:_objectSpread({},attributes),cells:cells,positions:positions,textureCoord:textureCoord,uniforms:_objectSpread({},uniforms),instanceCount:this[_count],enableBlend:this.enableBlend};if(frames.length){frames.forEach(function(frame,i){meshData.uniforms["u_texFrame".concat(i)]=frame;});}var _this$_buffer7=this[_buffer],transform0=_this$_buffer7.transform0,transform1=_this$_buffer7.transform1,color0=_this$_buffer7.color0,color1=_this$_buffer7.color1,color2=_this$_buffer7.color2,color3=_this$_buffer7.color3,color4=_this$_buffer7.color4,fillColor=_this$_buffer7.fillColor,strokeColor=_this$_buffer7.strokeColor,frameIndex=_this$_buffer7.frameIndex;if(this[_mesh].uniforms.u_texSampler){meshData.attributes.a_frameIndex={data:frameIndex,divisor:1};}// console.log(this[_mesh].meshData)
  meshData.attributes.a_transform0={data:transform0,divisor:1};meshData.attributes.a_transform1={data:transform1,divisor:1};meshData.attributes.a_colorCloud0={data:color0,divisor:1};meshData.attributes.a_colorCloud1={data:color1,divisor:1};meshData.attributes.a_colorCloud2={data:color2,divisor:1};meshData.attributes.a_colorCloud3={data:color3,divisor:1};meshData.attributes.a_colorCloud4={data:color4,divisor:1};if(this.hasCloudColor){meshData.attributes.a_fillCloudColor={data:fillColor,divisor:1};meshData.attributes.a_strokeCloudColor={data:strokeColor,divisor:1};}return meshData;}},{key:"program",get:function get(){return this[_mesh].program;}}]);return _default;}();/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"multiply",function(){return multiply;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"grayscale",function(){return grayscale;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"brightness",function(){return brightness;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"saturate",function(){return saturate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"contrast",function(){return contrast;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"invert",function(){return invert;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sepia",function(){return sepia;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"opacity",function(){return opacity;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"hueRotate",function(){return hueRotate;});/* harmony import */var _math__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(42);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function multiply(a,b){var out=[];var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a04=a[4];// eslint-disable-line one-var-declaration-per-line
  var a10=a[5],a11=a[6],a12=a[7],a13=a[8],a14=a[9];// eslint-disable-line one-var-declaration-per-line
  var a20=a[10],a21=a[11],a22=a[12],a23=a[13],a24=a[14];// eslint-disable-line one-var-declaration-per-line
  var a30=a[15],a31=a[16],a32=a[17],a33=a[18],a34=a[19];// eslint-disable-line one-var-declaration-per-line
  // Cache only the current line of the second matrix
  var b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4];// eslint-disable-line one-var-declaration-per-line
  out[0]=b0*a00+b1*a10+b2*a20+b3*a30;out[1]=b0*a01+b1*a11+b2*a21+b3*a31;out[2]=b0*a02+b1*a12+b2*a22+b3*a32;out[3]=b0*a03+b1*a13+b2*a23+b3*a33;out[4]=b0*a04+b1*a14+b2*a24+b3*a34+b4;b0=b[5];b1=b[6];b2=b[7];b3=b[8];b4=b[9];out[5]=b0*a00+b1*a10+b2*a20+b3*a30;out[6]=b0*a01+b1*a11+b2*a21+b3*a31;out[7]=b0*a02+b1*a12+b2*a22+b3*a32;out[8]=b0*a03+b1*a13+b2*a23+b3*a33;out[9]=b0*a04+b1*a14+b2*a24+b3*a34+b4;b0=b[10];b1=b[11];b2=b[12];b3=b[13];b4=b[14];out[10]=b0*a00+b1*a10+b2*a20+b3*a30;out[11]=b0*a01+b1*a11+b2*a21+b3*a31;out[12]=b0*a02+b1*a12+b2*a22+b3*a32;out[13]=b0*a03+b1*a13+b2*a23+b3*a33;out[14]=b0*a04+b1*a14+b2*a24+b3*a34+b4;b0=b[15];b1=b[16];b2=b[17];b3=b[18];b4=b[19];out[15]=b0*a00+b1*a10+b2*a20+b3*a30;out[16]=b0*a01+b1*a11+b2*a21+b3*a31;out[17]=b0*a02+b1*a12+b2*a22+b3*a32;out[18]=b0*a03+b1*a13+b2*a23+b3*a33;out[19]=b0*a04+b1*a14+b2*a24+b3*a34+b4;return out;}// export function transformColor(color, m) {
  //   const [r, g, b, a] = color;
  //   color[0] = m[0] * r + m[1] * g + m[2] * b + m[3] * a + m[4];
  //   color[1] = m[5] * r + m[6] * g + m[7] * b + m[8] * a + m[9];
  //   color[2] = m[10] * r + m[11] * g + m[12] * b + m[13] * a + m[14];
  //   color[3] = m[15] * r + m[16] * g + m[17] * b + m[18] * a + m[19];
  //   return color;
  // }
  function grayscale(p){p=Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(0,1,p);var r=0.2126*p;var g=0.7152*p;var b=0.0722*p;return [r+1-p,g,b,0,0,r,g+1-p,b,0,0,r,g,b+1-p,0,0,0,0,0,1,0];}function brightness(p){return [p,0,0,0,0,0,p,0,0,0,0,0,p,0,0,0,0,0,1,0];}function saturate(p){// p = clamp(0, 1, p);
  var r=0.2126*(1-p);var g=0.7152*(1-p);var b=0.0722*(1-p);return [r+p,g,b,0,0,r,g+p,b,0,0,r,g,b+p,0,0,0,0,0,1,0];}function contrast(p){var d=0.5*(1-p);return [p,0,0,0,d,0,p,0,0,d,0,0,p,0,d,0,0,0,1,0];}function invert(p){var d=1-2*p;return [d,0,0,0,p,0,d,0,0,p,0,0,d,0,p,0,0,0,1,0];}function sepia(p){return [1-0.607*p,0.769*p,0.189*p,0,0,0.349*p,1-0.314*p,0.168*p,0,0,0.272*p,0.534*p,1-0.869*p,0,0,0,0,0,1,0];}function opacity(p){return [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,p,0];}function hueRotate(deg){var rotation=deg/180*Math.PI;var cos=Math.cos(rotation),sin=Math.sin(rotation),lumR=0.2126,lumG=0.7152,lumB=0.0722;return [lumR+cos*(1-lumR)+sin*-lumR,lumG+cos*-lumG+sin*-lumG,lumB+cos*-lumB+sin*(1-lumB),0,0,lumR+cos*-lumR+sin*0.143,lumG+cos*(1-lumG)+sin*0.140,lumB+cos*-lumB+sin*-0.283,0,0,lumR+cos*-lumR+sin*-(1-lumR),lumG+cos*-lumG+sin*lumG,lumB+cos*(1-lumB)+sin*lumB,0,0,0,0,0,1,0];}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return parseColor;});/* harmony import */var color_rgba__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(48);/* harmony import */var color_rgba__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(color_rgba__WEBPACK_IMPORTED_MODULE_0__);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function parseColor(colorStr){var ret=color_rgba__WEBPACK_IMPORTED_MODULE_0___default()(colorStr);if(!ret||!ret.length)throw new TypeError('Invalid color value.');return [ret[0]/255,ret[1]/255,ret[2]/255,ret[3]];}/***/},function(module,exports,__webpack_require__){/** @module  color-rgba */var parse=__webpack_require__(49);var hsl=__webpack_require__(53);var clamp=__webpack_require__(55);module.exports=function rgba(color){var values;//attempt to parse non-array arguments
  var parsed=parse(color);if(!parsed.space)return [];values=Array(3);values[0]=clamp(parsed.values[0],0,255);values[1]=clamp(parsed.values[1],0,255);values[2]=clamp(parsed.values[2],0,255);if(parsed.space[0]==='h'){values=hsl.rgb(values);}values.push(clamp(parsed.alpha,0,1));return values;};/***/},function(module,exports,__webpack_require__){/* WEBPACK VAR INJECTION */(function(global){/**
   * @module color-parse
   */var names=__webpack_require__(50);var isObject=__webpack_require__(51);var defined=__webpack_require__(52);module.exports=parse;/**
   * Base hues
   * http://dev.w3.org/csswg/css-color/#typedef-named-hue
   */ //FIXME: use external hue detector
  var baseHues={red:0,orange:60,yellow:120,green:180,blue:240,purple:300};/**
   * Parse color from the string passed
   *
   * @return {Object} A space indicator `space`, an array `values` and `alpha`
   */function parse(cstr){var m,parts=[],alpha=1,space;if(typeof cstr==='string'){//keyword
  if(names[cstr]){parts=names[cstr].slice();space='rgb';}//reserved words
  else if(cstr==='transparent'){alpha=0;space='rgb';parts=[0,0,0];}//hex
  else if(/^#[A-Fa-f0-9]+$/.test(cstr)){var base=cstr.slice(1);var size=base.length;var isShort=size<=4;alpha=1;if(isShort){parts=[parseInt(base[0]+base[0],16),parseInt(base[1]+base[1],16),parseInt(base[2]+base[2],16)];if(size===4){alpha=parseInt(base[3]+base[3],16)/255;}}else {parts=[parseInt(base[0]+base[1],16),parseInt(base[2]+base[3],16),parseInt(base[4]+base[5],16)];if(size===8){alpha=parseInt(base[6]+base[7],16)/255;}}if(!parts[0])parts[0]=0;if(!parts[1])parts[1]=0;if(!parts[2])parts[2]=0;space='rgb';}//color space
  else if(m=/^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)){var name=m[1];var isRGB=name==='rgb';var base=name.replace(/a$/,'');space=base;var size=base==='cmyk'?4:base==='gray'?1:3;parts=m[2].trim().split(/\s*,\s*/).map(function(x,i){//<percentage>
  if(/%$/.test(x)){//alpha
  if(i===size)return parseFloat(x)/100;//rgb
  if(base==='rgb')return parseFloat(x)*255/100;return parseFloat(x);}//hue
  else if(base[i]==='h'){//<deg>
  if(/deg$/.test(x)){return parseFloat(x);}//<base-hue>
  else if(baseHues[x]!==undefined){return baseHues[x];}}return parseFloat(x);});if(name===base)parts.push(1);alpha=isRGB?1:parts[size]===undefined?1:parts[size];parts=parts.slice(0,size);}//named channels case
  else if(cstr.length>10&&/[0-9](?:\s|\/)/.test(cstr)){parts=cstr.match(/([0-9]+)/g).map(function(value){return parseFloat(value);});space=cstr.match(/([a-z])/ig).join('').toLowerCase();}}//numeric case
  else if(!isNaN(cstr)){space='rgb';parts=[cstr>>>16,(cstr&0x00ff00)>>>8,cstr&0x0000ff];}//object case - detects css cases of rgb and hsl
  else if(isObject(cstr)){var r=defined(cstr.r,cstr.red,cstr.R,null);if(r!==null){space='rgb';parts=[r,defined(cstr.g,cstr.green,cstr.G),defined(cstr.b,cstr.blue,cstr.B)];}else {space='hsl';parts=[defined(cstr.h,cstr.hue,cstr.H),defined(cstr.s,cstr.saturation,cstr.S),defined(cstr.l,cstr.lightness,cstr.L,cstr.b,cstr.brightness)];}alpha=defined(cstr.a,cstr.alpha,cstr.opacity,1);if(cstr.opacity!=null)alpha/=100;}//array
  else if(Array.isArray(cstr)||global.ArrayBuffer&&ArrayBuffer.isView&&ArrayBuffer.isView(cstr)){parts=[cstr[0],cstr[1],cstr[2]];space='rgb';alpha=cstr.length===4?cstr[3]:1;}return {space:space,values:parts,alpha:alpha};}/* WEBPACK VAR INJECTION */}).call(this,__webpack_require__(38));/***/},function(module,exports,__webpack_require__){module.exports={"aliceblue":[240,248,255],"antiquewhite":[250,235,215],"aqua":[0,255,255],"aquamarine":[127,255,212],"azure":[240,255,255],"beige":[245,245,220],"bisque":[255,228,196],"black":[0,0,0],"blanchedalmond":[255,235,205],"blue":[0,0,255],"blueviolet":[138,43,226],"brown":[165,42,42],"burlywood":[222,184,135],"cadetblue":[95,158,160],"chartreuse":[127,255,0],"chocolate":[210,105,30],"coral":[255,127,80],"cornflowerblue":[100,149,237],"cornsilk":[255,248,220],"crimson":[220,20,60],"cyan":[0,255,255],"darkblue":[0,0,139],"darkcyan":[0,139,139],"darkgoldenrod":[184,134,11],"darkgray":[169,169,169],"darkgreen":[0,100,0],"darkgrey":[169,169,169],"darkkhaki":[189,183,107],"darkmagenta":[139,0,139],"darkolivegreen":[85,107,47],"darkorange":[255,140,0],"darkorchid":[153,50,204],"darkred":[139,0,0],"darksalmon":[233,150,122],"darkseagreen":[143,188,143],"darkslateblue":[72,61,139],"darkslategray":[47,79,79],"darkslategrey":[47,79,79],"darkturquoise":[0,206,209],"darkviolet":[148,0,211],"deeppink":[255,20,147],"deepskyblue":[0,191,255],"dimgray":[105,105,105],"dimgrey":[105,105,105],"dodgerblue":[30,144,255],"firebrick":[178,34,34],"floralwhite":[255,250,240],"forestgreen":[34,139,34],"fuchsia":[255,0,255],"gainsboro":[220,220,220],"ghostwhite":[248,248,255],"gold":[255,215,0],"goldenrod":[218,165,32],"gray":[128,128,128],"green":[0,128,0],"greenyellow":[173,255,47],"grey":[128,128,128],"honeydew":[240,255,240],"hotpink":[255,105,180],"indianred":[205,92,92],"indigo":[75,0,130],"ivory":[255,255,240],"khaki":[240,230,140],"lavender":[230,230,250],"lavenderblush":[255,240,245],"lawngreen":[124,252,0],"lemonchiffon":[255,250,205],"lightblue":[173,216,230],"lightcoral":[240,128,128],"lightcyan":[224,255,255],"lightgoldenrodyellow":[250,250,210],"lightgray":[211,211,211],"lightgreen":[144,238,144],"lightgrey":[211,211,211],"lightpink":[255,182,193],"lightsalmon":[255,160,122],"lightseagreen":[32,178,170],"lightskyblue":[135,206,250],"lightslategray":[119,136,153],"lightslategrey":[119,136,153],"lightsteelblue":[176,196,222],"lightyellow":[255,255,224],"lime":[0,255,0],"limegreen":[50,205,50],"linen":[250,240,230],"magenta":[255,0,255],"maroon":[128,0,0],"mediumaquamarine":[102,205,170],"mediumblue":[0,0,205],"mediumorchid":[186,85,211],"mediumpurple":[147,112,219],"mediumseagreen":[60,179,113],"mediumslateblue":[123,104,238],"mediumspringgreen":[0,250,154],"mediumturquoise":[72,209,204],"mediumvioletred":[199,21,133],"midnightblue":[25,25,112],"mintcream":[245,255,250],"mistyrose":[255,228,225],"moccasin":[255,228,181],"navajowhite":[255,222,173],"navy":[0,0,128],"oldlace":[253,245,230],"olive":[128,128,0],"olivedrab":[107,142,35],"orange":[255,165,0],"orangered":[255,69,0],"orchid":[218,112,214],"palegoldenrod":[238,232,170],"palegreen":[152,251,152],"paleturquoise":[175,238,238],"palevioletred":[219,112,147],"papayawhip":[255,239,213],"peachpuff":[255,218,185],"peru":[205,133,63],"pink":[255,192,203],"plum":[221,160,221],"powderblue":[176,224,230],"purple":[128,0,128],"rebeccapurple":[102,51,153],"red":[255,0,0],"rosybrown":[188,143,143],"royalblue":[65,105,225],"saddlebrown":[139,69,19],"salmon":[250,128,114],"sandybrown":[244,164,96],"seagreen":[46,139,87],"seashell":[255,245,238],"sienna":[160,82,45],"silver":[192,192,192],"skyblue":[135,206,235],"slateblue":[106,90,205],"slategray":[112,128,144],"slategrey":[112,128,144],"snow":[255,250,250],"springgreen":[0,255,127],"steelblue":[70,130,180],"tan":[210,180,140],"teal":[0,128,128],"thistle":[216,191,216],"tomato":[255,99,71],"turquoise":[64,224,208],"violet":[238,130,238],"wheat":[245,222,179],"white":[255,255,255],"whitesmoke":[245,245,245],"yellow":[255,255,0],"yellowgreen":[154,205,50]};/***/},function(module,exports,__webpack_require__){var toString=Object.prototype.toString;module.exports=function(x){var prototype;return toString.call(x)==='[object Object]'&&(prototype=Object.getPrototypeOf(x),prototype===null||prototype===Object.getPrototypeOf({}));};/***/},function(module,exports){module.exports=function(){for(var i=0;i<arguments.length;i++){if(arguments[i]!==undefined)return arguments[i];}};/***/},function(module,exports,__webpack_require__){/**
   * @module color-space/hsl
   */var rgb=__webpack_require__(54);module.exports={name:'hsl',min:[0,0,0],max:[360,100,100],channel:['hue','saturation','lightness'],alias:['HSL'],rgb:function(hsl){var h=hsl[0]/360,s=hsl[1]/100,l=hsl[2]/100,t1,t2,t3,rgb,val;if(s===0){val=l*255;return [val,val,val];}if(l<0.5){t2=l*(1+s);}else {t2=l+s-l*s;}t1=2*l-t2;rgb=[0,0,0];for(var i=0;i<3;i++){t3=h+1/3*-(i-1);if(t3<0){t3++;}else if(t3>1){t3--;}if(6*t3<1){val=t1+(t2-t1)*6*t3;}else if(2*t3<1){val=t2;}else if(3*t3<2){val=t1+(t2-t1)*(2/3-t3)*6;}else {val=t1;}rgb[i]=val*255;}return rgb;}};//extend rgb
  rgb.hsl=function(rgb){var r=rgb[0]/255,g=rgb[1]/255,b=rgb[2]/255,min=Math.min(r,g,b),max=Math.max(r,g,b),delta=max-min,h,s,l;if(max===min){h=0;}else if(r===max){h=(g-b)/delta;}else if(g===max){h=2+(b-r)/delta;}else if(b===max){h=4+(r-g)/delta;}h=Math.min(h*60,360);if(h<0){h+=360;}l=(min+max)/2;if(max===min){s=0;}else if(l<=0.5){s=delta/(max+min);}else {s=delta/(2-max-min);}return [h,s*100,l*100];};/***/},function(module,exports,__webpack_require__){/**
   * RGB space.
   *
   * @module  color-space/rgb
   */module.exports={name:'rgb',min:[0,0,0],max:[255,255,255],channel:['red','green','blue'],alias:['RGB']};/***/},function(module,exports){module.exports=clamp;function clamp(value,min,max){return min<max?value<min?min:value>max?max:value:value<max?max:value>min?min:value;}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return Figure2D;});/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(57);/* harmony import */var _babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(23);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(24);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);/* harmony import */var parse_svg_path__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(58);/* harmony import */var parse_svg_path__WEBPACK_IMPORTED_MODULE_4___default=/*#__PURE__*/__webpack_require__.n(parse_svg_path__WEBPACK_IMPORTED_MODULE_4__);/* harmony import */var bound_points__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(59);/* harmony import */var bound_points__WEBPACK_IMPORTED_MODULE_5___default=/*#__PURE__*/__webpack_require__.n(bound_points__WEBPACK_IMPORTED_MODULE_5__);/* harmony import */var abs_svg_path__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(60);/* harmony import */var abs_svg_path__WEBPACK_IMPORTED_MODULE_6___default=/*#__PURE__*/__webpack_require__.n(abs_svg_path__WEBPACK_IMPORTED_MODULE_6__);/* harmony import */var _normalize_svg_path__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(61);/* harmony import */var _svg_path_contours__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(63);/* harmony import */var _svg_path_contours__WEBPACK_IMPORTED_MODULE_8___default=/*#__PURE__*/__webpack_require__.n(_svg_path_contours__WEBPACK_IMPORTED_MODULE_8__);/* harmony import */var _utils_contours__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(70);/* harmony import */var _utils_ellipse__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(72);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var _contours=Symbol('contours');var _path=Symbol('path');var _simplify=Symbol('simplify');var _scale=Symbol('scale');var PI2=2*Math.PI;var Figure2D=/*#__PURE__*/function(){function Figure2D(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this,Figure2D);if(typeof options==='string')options={path:options};if(options.path)this[_path]=parse_svg_path__WEBPACK_IMPORTED_MODULE_4___default()(options.path);else this[_path]=[];this[_contours]=null;this[_simplify]=options.simplify!=null?options.simplify:0;this[_scale]=options.scale!=null?options.scale:2;}_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(Figure2D,[{key:"normalize",value:function normalize(){var _this$_path;var x0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y0=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var path=Object(_normalize_svg_path__WEBPACK_IMPORTED_MODULE_7__["default"])(abs_svg_path__WEBPACK_IMPORTED_MODULE_6___default()(this[_path])).map(function(_ref){var _ref2=_babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1___default()(_ref),cmd=_ref2[0],args=_ref2.slice(1);var transformed=[cmd];for(var i=0;i<args.length;i+=2){var x=args[i]-x0,y=args[i+1]-y0;transformed.push(x,y);}return transformed;});this.beginPath();(_this$_path=this[_path]).push.apply(_this$_path,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(path));return this;}},{key:"getPointAtLength",value:function getPointAtLength(length){if(this.contours){return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_9__["getPointAtLength"])(this[_contours],length);}return null;}},{key:"getTotalLength",value:function getTotalLength(){if(this.contours){return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_9__["getTotalLength"])(this[_contours]);}return 0;}},{key:"addPath",value:function addPath(path){var _this$_path2;this[_contours]=null;if(typeof path==='string')path=parse_svg_path__WEBPACK_IMPORTED_MODULE_4___default()(path);(_this$_path2=this[_path]).push.apply(_this$_path2,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(path));}},{key:"beginPath",value:function beginPath(){this[_path]=[];this[_contours]=null;}},{key:"clear",value:function clear(){this.beginPath();}},{key:"ellipse",value:function ellipse(x,y,radiusX,radiusY,rotation,startAngle,endAngle){var anticlockwise=arguments.length>7&&arguments[7]!==undefined?arguments[7]:0;startAngle+=rotation;endAngle+=rotation;if(radiusX<=0||radiusY<=0||endAngle===startAngle)return;if(endAngle<startAngle){endAngle=startAngle+PI2+(endAngle-startAngle)%PI2;}if(endAngle-startAngle>PI2){endAngle=startAngle+PI2;}var delta=endAngle-startAngle;if(delta>=PI2){endAngle-=1e-3;}var path=this[_path].length>0&&delta<PI2?'L':'M';var startPoint=Object(_utils_ellipse__WEBPACK_IMPORTED_MODULE_10__["getPoint"])(x,y,radiusX,radiusY,startAngle);var endPoint=Object(_utils_ellipse__WEBPACK_IMPORTED_MODULE_10__["getPoint"])(x,y,radiusX,radiusY,endAngle);var sweepFlag=Number(!anticlockwise);var largeArcFlag=delta>Math.PI?1:0;if(anticlockwise)largeArcFlag=1-largeArcFlag;path+=startPoint.join(' ');path+="A".concat(radiusX," ").concat(radiusY," 0 ").concat(largeArcFlag," ").concat(sweepFlag," ").concat(endPoint.join(' '));if(delta>=PI2){path+='Z';}this.addPath(path);}},{key:"arc",value:function arc(x,y,radius,startAngle,endAngle){var anticlockwise=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;return this.ellipse(x,y,radius,radius,0,startAngle,endAngle,anticlockwise);}},{key:"arcTo",value:function arcTo(rx,ry,xAxisRotation,largeArcFlag,sweepFlag,x,y){this[_contours]=null;this[_path].push(['A',rx,ry,xAxisRotation,largeArcFlag,sweepFlag,x,y]);}},{key:"moveTo",value:function moveTo(x,y){this[_contours]=null;this[_path].push(['M',x,y]);}},{key:"lineTo",value:function lineTo(x,y){this[_contours]=null;this[_path].push(['L',x,y]);}},{key:"bezierCurveTo",value:function bezierCurveTo(x1,y1,x2,y2,x,y){this[_contours]=null;this[_path].push(['C',x1,y1,x2,y2,x,y]);}},{key:"quadraticCurveTo",value:function quadraticCurveTo(x1,y1,x,y){this[_contours]=null;this[_path].push(['Q',x1,y1,x,y]);}},{key:"rect",value:function rect(x,y,width,height){var path="M".concat(x," ").concat(y,"L").concat(x+width," ").concat(y,"L").concat(x+width," ").concat(y+height,"L").concat(x," ").concat(y+height,"Z");this.addPath(path);}},{key:"closePath",value:function closePath(){this[_contours]=null;var lastPath=[];var len=this[_path].length;if(len>0){lastPath=this[_path][len-1];}if(lastPath[0]!=='Z'&&lastPath[0]!=='z'){this[_path].push(['Z']);}}},{key:"contours",get:function get(){var ret=null;if(!this[_contours]&&this[_path]){var path=Object(_normalize_svg_path__WEBPACK_IMPORTED_MODULE_7__["default"])(abs_svg_path__WEBPACK_IMPORTED_MODULE_6___default()(this[_path]));this[_contours]=_svg_path_contours__WEBPACK_IMPORTED_MODULE_8___default()(path,this[_scale],this[_simplify]);this[_contours].path=path;this[_contours].simplify=this[_simplify];this[_contours].scale=this[_scale];}if(this[_contours]){ret=this[_contours].map(function(c){return _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(c);});ret.path=this[_contours].path;ret.simplify=this[_contours].simplify;ret.scale=this[_contours].scale;}return ret;}},{key:"path",get:function get(){return this[_path];}},{key:"simplify",get:function get(){return this[_simplify];}},{key:"boundingBox",get:function get(){var contours=this.contours;if(contours&&contours.length){var points=contours.reduce(function(a,b){return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(a),_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(b));});return bound_points__WEBPACK_IMPORTED_MODULE_5___default()(points);}return [[0,0],[0,0]];}},{key:"boundingCenter",get:function get(){var bound=this.boundingBox;if(bound){return [0.5*(bound[0][0]+bound[1][0]),0.5*(bound[0][1]+bound[1][1])];}return [0,0];}}]);return Figure2D;}();/***/},function(module,exports,__webpack_require__){var arrayWithHoles=__webpack_require__(14);var iterableToArray=__webpack_require__(21);var unsupportedIterableToArray=__webpack_require__(16);var nonIterableRest=__webpack_require__(18);function _toArray(arr){return arrayWithHoles(arr)||iterableToArray(arr)||unsupportedIterableToArray(arr)||nonIterableRest();}module.exports=_toArray;/***/},function(module,exports){module.exports=parse;/**
   * expected argument lengths
   * @type {Object}
   */var length={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0};/**
   * segment pattern
   * @type {RegExp}
   */var segment=/([astvzqmhlc])([^astvzqmhlc]*)/ig;/**
   * parse an svg path data string. Generates an Array
   * of commands where each command is an Array of the
   * form `[command, arg1, arg2, ...]`
   *
   * @param {String} path
   * @return {Array}
   */function parse(path){var data=[];path.replace(segment,function(_,command,args){var type=command.toLowerCase();args=parseValues(args);// overloaded moveTo
  if(type=='m'&&args.length>2){data.push([command].concat(args.splice(0,2)));type='l';command=command=='m'?'l':'L';}while(true){if(args.length==length[type]){args.unshift(command);return data.push(args);}if(args.length<length[type])throw new Error('malformed path data');data.push([command].concat(args.splice(0,length[type])));}});return data;}var number=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function parseValues(args){var numbers=args.match(number);return numbers?numbers.map(Number):[];}/***/},function(module,exports,__webpack_require__){module.exports=findBounds;function findBounds(points){var n=points.length;if(n===0){return [[],[]];}var d=points[0].length;var lo=points[0].slice();var hi=points[0].slice();for(var i=1;i<n;++i){var p=points[i];for(var j=0;j<d;++j){var x=p[j];lo[j]=Math.min(lo[j],x);hi[j]=Math.max(hi[j],x);}}return [lo,hi];}/***/},function(module,exports){module.exports=absolutize;/**
   * redefine `path` with absolute coordinates
   *
   * @param {Array} path
   * @return {Array}
   */function absolutize(path){var startX=0;var startY=0;var x=0;var y=0;return path.map(function(seg){seg=seg.slice();var type=seg[0];var command=type.toUpperCase();// is relative
  if(type!=command){seg[0]=command;switch(type){case'a':seg[6]+=x;seg[7]+=y;break;case'v':seg[1]+=y;break;case'h':seg[1]+=x;break;default:for(var i=1;i<seg.length;){seg[i++]+=x;seg[i++]+=y;}}}// update cursor state
  switch(command){case'Z':x=startX;y=startY;break;case'H':x=seg[1];break;case'V':y=seg[1];break;case'M':x=startX=seg[1];y=startY=seg[2];break;default:x=seg[seg.length-2];y=seg[seg.length-1];}return seg;});}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return normalize;});/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _a2c__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(62);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);// https://github.com/jkroso/normalize-svg-path
  /* eslint-disable */function normalize(path){// init state
  var prev;var result=[];var bezierX=0;var bezierY=0;var startX=0;var startY=0;var quadX=null;var quadY=null;var x=0;var y=0;for(var i=0,len=path.length;i<len;i++){var seg=path[i];var command=seg[0];switch(command){case'M':startX=seg[1];startY=seg[2];break;case'A':var curves=Object(_a2c__WEBPACK_IMPORTED_MODULE_1__["default"])(x,y,seg[6],seg[7],seg[4],seg[5],seg[1],seg[2],seg[3]);if(!curves.length)continue;curves=curves.map(function(curve){var _curve=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(curve,8);_curve[0];_curve[1];var x1=_curve[2],y1=_curve[3],x2=_curve[4],y2=_curve[5],x=_curve[6],y=_curve[7];return {x1:x1,y1:y1,x2:x2,y2:y2,x:x,y:y};});for(var j=0,c;j<curves.length;j++){c=curves[j];seg=['C',c.x1,c.y1,c.x2,c.y2,c.x,c.y];if(j<curves.length-1)result.push(seg);}break;case'S':// default control point
  var cx=x;var cy=y;if(prev=='C'||prev=='S'){cx+=cx-bezierX;// reflect the previous command's control
  cy+=cy-bezierY;// point relative to the current point
  }seg=['C',cx,cy,seg[1],seg[2],seg[3],seg[4]];break;case'T':if(prev=='Q'||prev=='T'){quadX=x*2-quadX;// as with 'S' reflect previous control point
  quadY=y*2-quadY;}else {quadX=x;quadY=y;}seg=quadratic(x,y,quadX,quadY,seg[1],seg[2]);break;case'Q':quadX=seg[1];quadY=seg[2];seg=quadratic(x,y,seg[1],seg[2],seg[3],seg[4]);break;case'L':seg=line(x,y,seg[1],seg[2]);break;case'H':seg=line(x,y,seg[1],y);break;case'V':seg=line(x,y,x,seg[1]);break;case'Z':seg=line(x,y,startX,startY);break;}// update state
  prev=command;x=seg[seg.length-2];y=seg[seg.length-1];if(seg.length>4){bezierX=seg[seg.length-4];bezierY=seg[seg.length-3];}else {bezierX=x;bezierY=y;}result.push(seg);}return result;}function line(x1,y1,x2,y2){return ['C',x1,y1,x2,y2,x2,y2];}function quadratic(x1,y1,cx,cy,x2,y2){return ['C',x1/3+2/3*cx,y1/3+2/3*cy,x2/3+2/3*cx,y2/3+2/3*cy,x2,y2];}/* eslint-enable */ /***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return a2c;});__webpack_require__(1).glMatrix.setMatrixArrayType(Array);// https://github.com/colinmeinke/svg-arc-to-cubic-bezier
  //
  // Convert an arc to a sequence of cubic bézier curves
  //
  var TAU=Math.PI*2;/* eslint-disable space-infix-ops */ // Calculate an angle between two unit vectors
  //
  // Since we measure angle between radii of circular arcs,
  // we can use simplified math (without length normalization)
  //
  function unit_vector_angle(ux,uy,vx,vy){var sign=ux*vy-uy*vx<0?-1:1;var dot=ux*vx+uy*vy;// Add this to work with arbitrary vectors:
  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
  // rounding errors, e.g. -1.0000000000000002 can screw up this
  if(dot>1.0){dot=1.0;}if(dot<-1.0){dot=-1.0;}return sign*Math.acos(dot);}// Convert from endpoint to center parameterization,
  // see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  //
  // Return [cx, cy, theta1, delta_theta]
  //
  function get_arc_center(x1,y1,x2,y2,fa,fs,rx,ry,sin_phi,cos_phi){// Step 1.
  //
  // Moving an ellipse so origin will be the middlepoint between our two
  // points. After that, rotate it to line up ellipse axes with coordinate
  // axes.
  //
  var x1p=cos_phi*(x1-x2)/2+sin_phi*(y1-y2)/2;var y1p=-sin_phi*(x1-x2)/2+cos_phi*(y1-y2)/2;var rx_sq=rx*rx;var ry_sq=ry*ry;var x1p_sq=x1p*x1p;var y1p_sq=y1p*y1p;// Step 2.
  //
  // Compute coordinates of the centre of this ellipse (cx', cy')
  // in the new coordinate system.
  //
  var radicant=rx_sq*ry_sq-rx_sq*y1p_sq-ry_sq*x1p_sq;if(radicant<0){// due to rounding errors it might be e.g. -1.3877787807814457e-17
  radicant=0;}radicant/=rx_sq*y1p_sq+ry_sq*x1p_sq;radicant=Math.sqrt(radicant)*(fa===fs?-1:1);var cxp=radicant*rx/ry*y1p;var cyp=radicant*-ry/rx*x1p;// Step 3.
  //
  // Transform back to get centre coordinates (cx, cy) in the original
  // coordinate system.
  //
  var cx=cos_phi*cxp-sin_phi*cyp+(x1+x2)/2;var cy=sin_phi*cxp+cos_phi*cyp+(y1+y2)/2;// Step 4.
  //
  // Compute angles (theta1, delta_theta).
  //
  var v1x=(x1p-cxp)/rx;var v1y=(y1p-cyp)/ry;var v2x=(-x1p-cxp)/rx;var v2y=(-y1p-cyp)/ry;var theta1=unit_vector_angle(1,0,v1x,v1y);var delta_theta=unit_vector_angle(v1x,v1y,v2x,v2y);if(fs===0&&delta_theta>0){delta_theta-=TAU;}if(fs===1&&delta_theta<0){delta_theta+=TAU;}return [cx,cy,theta1,delta_theta];}//
  // Approximate one unit arc segment with bézier curves,
  // see http://math.stackexchange.com/questions/873224
  //
  function approximate_unit_arc(theta1,delta_theta){var alpha=4/3*Math.tan(delta_theta/4);var x1=Math.cos(theta1);var y1=Math.sin(theta1);var x2=Math.cos(theta1+delta_theta);var y2=Math.sin(theta1+delta_theta);return [x1,y1,x1-y1*alpha,y1+x1*alpha,x2+y2*alpha,y2-x2*alpha,x2,y2];}function a2c(x1,y1,x2,y2,fa,fs,rx,ry,phi){var sin_phi=Math.sin(phi*TAU/360);var cos_phi=Math.cos(phi*TAU/360);// Make sure radii are valid
  //
  var x1p=cos_phi*(x1-x2)/2+sin_phi*(y1-y2)/2;var y1p=-sin_phi*(x1-x2)/2+cos_phi*(y1-y2)/2;if(x1p===0&&y1p===0){// we're asked to draw line to itself
  return [];}if(rx===0||ry===0){// one of the radii is zero
  return [];}// Compensate out-of-range radii
  //
  rx=Math.abs(rx);ry=Math.abs(ry);var lambda=x1p*x1p/(rx*rx)+y1p*y1p/(ry*ry);if(lambda>1){rx*=Math.sqrt(lambda);ry*=Math.sqrt(lambda);}// Get center parameters (cx, cy, theta1, delta_theta)
  //
  var cc=get_arc_center(x1,y1,x2,y2,fa,fs,rx,ry,sin_phi,cos_phi);var result=[];var theta1=cc[2];var delta_theta=cc[3];// Split an arc to multiple segments, so each segment
  // will be less than τ/4 (= 90°)
  //
  var segments=Math.max(Math.ceil(Math.abs(delta_theta)/(TAU/4)),1);delta_theta/=segments;for(var i=0;i<segments;i++){result.push(approximate_unit_arc(theta1,delta_theta));theta1+=delta_theta;}// We have a bezier approximation of a unit circle,
  // now need to transform back to the original ellipse
  //
  return result.map(function(curve){for(var _i=0;_i<curve.length;_i+=2){var x=curve[_i+0];var y=curve[_i+1];// scale
  x*=rx;y*=ry;// rotate
  var xp=cos_phi*x-sin_phi*y;var yp=sin_phi*x+cos_phi*y;// translate
  curve[_i+0]=xp+cc[0];curve[_i+1]=yp+cc[1];}return curve;});}/***/},function(module,exports,__webpack_require__){__webpack_require__(1).glMatrix.setMatrixArrayType(Array);// https://github.com/mattdesl/svg-path-contours
  /* eslint-disable */var bezier=__webpack_require__(64);var _require=__webpack_require__(66),copy=_require.copy;var simplify=__webpack_require__(67);function set(out,x,y){out[0]=x;out[1]=y;return out;}var tmp1=[0,0],tmp2=[0,0],tmp3=[0,0];function bezierTo(points,scale,start,seg){bezier(start,set(tmp1,seg[1],seg[2]),set(tmp2,seg[3],seg[4]),set(tmp3,seg[5],seg[6]),scale,points);}module.exports=function contours(svg,scale,simp){var paths=[];var points=[];var pen=[0,0];svg.forEach(function(segment,i,self){if(segment[0]==='M'){copy(pen,segment.slice(1));if(points.length>0){paths.push(points);points=[];}}else if(segment[0]==='C'){bezierTo(points,scale,pen,segment);set(pen,segment[5],segment[6]);}else {throw new Error('illegal type in SVG: '+segment[0]);}});if(points.length>0)paths.push(points);return paths.map(function(points){return simplify(points,simp||0);});};/***/},function(module,exports,__webpack_require__){module.exports=__webpack_require__(65)();/***/},function(module,exports){function clone(point){//TODO: use gl-vec2 for this
  return [point[0],point[1]];}function vec2(x,y){return [x,y];}module.exports=function createBezierBuilder(opt){opt=opt||{};var RECURSION_LIMIT=typeof opt.recursion==='number'?opt.recursion:8;var FLT_EPSILON=typeof opt.epsilon==='number'?opt.epsilon:1.19209290e-7;var PATH_DISTANCE_EPSILON=typeof opt.pathEpsilon==='number'?opt.pathEpsilon:1.0;var curve_angle_tolerance_epsilon=typeof opt.angleEpsilon==='number'?opt.angleEpsilon:0.01;var m_angle_tolerance=opt.angleTolerance||0;var m_cusp_limit=opt.cuspLimit||0;return function bezierCurve(start,c1,c2,end,scale,points){if(!points)points=[];scale=typeof scale==='number'?scale:1.0;var distanceTolerance=PATH_DISTANCE_EPSILON/scale;distanceTolerance*=distanceTolerance;begin(start,c1,c2,end,points,distanceTolerance);return points;};////// Based on:
  ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp
  function begin(start,c1,c2,end,points,distanceTolerance){points.push(clone(start));var x1=start[0],y1=start[1],x2=c1[0],y2=c1[1],x3=c2[0],y3=c2[1],x4=end[0],y4=end[1];recursive(x1,y1,x2,y2,x3,y3,x4,y4,points,distanceTolerance,0);points.push(clone(end));}function recursive(x1,y1,x2,y2,x3,y3,x4,y4,points,distanceTolerance,level){if(level>RECURSION_LIMIT)return;var pi=Math.PI;// Calculate all the mid-points of the line segments
  //----------------------
  var x12=(x1+x2)/2;var y12=(y1+y2)/2;var x23=(x2+x3)/2;var y23=(y2+y3)/2;var x34=(x3+x4)/2;var y34=(y3+y4)/2;var x123=(x12+x23)/2;var y123=(y12+y23)/2;var x234=(x23+x34)/2;var y234=(y23+y34)/2;var x1234=(x123+x234)/2;var y1234=(y123+y234)/2;if(level>0){// Enforce subdivision first time
  // Try to approximate the full cubic curve by a single straight line
  //------------------
  var dx=x4-x1;var dy=y4-y1;var d2=Math.abs((x2-x4)*dy-(y2-y4)*dx);var d3=Math.abs((x3-x4)*dy-(y3-y4)*dx);var da1,da2;if(d2>FLT_EPSILON&&d3>FLT_EPSILON){// Regular care
  //-----------------
  if((d2+d3)*(d2+d3)<=distanceTolerance*(dx*dx+dy*dy)){// If the curvature doesn't exceed the distanceTolerance value
  // we tend to finish subdivisions.
  //----------------------
  if(m_angle_tolerance<curve_angle_tolerance_epsilon){points.push(vec2(x1234,y1234));return;}// Angle & Cusp Condition
  //----------------------
  var a23=Math.atan2(y3-y2,x3-x2);da1=Math.abs(a23-Math.atan2(y2-y1,x2-x1));da2=Math.abs(Math.atan2(y4-y3,x4-x3)-a23);if(da1>=pi)da1=2*pi-da1;if(da2>=pi)da2=2*pi-da2;if(da1+da2<m_angle_tolerance){// Finally we can stop the recursion
  //----------------------
  points.push(vec2(x1234,y1234));return;}if(m_cusp_limit!==0.0){if(da1>m_cusp_limit){points.push(vec2(x2,y2));return;}if(da2>m_cusp_limit){points.push(vec2(x3,y3));return;}}}}else {if(d2>FLT_EPSILON){// p1,p3,p4 are collinear, p2 is considerable
  //----------------------
  if(d2*d2<=distanceTolerance*(dx*dx+dy*dy)){if(m_angle_tolerance<curve_angle_tolerance_epsilon){points.push(vec2(x1234,y1234));return;}// Angle Condition
  //----------------------
  da1=Math.abs(Math.atan2(y3-y2,x3-x2)-Math.atan2(y2-y1,x2-x1));if(da1>=pi)da1=2*pi-da1;if(da1<m_angle_tolerance){points.push(vec2(x2,y2));points.push(vec2(x3,y3));return;}if(m_cusp_limit!==0.0){if(da1>m_cusp_limit){points.push(vec2(x2,y2));return;}}}}else if(d3>FLT_EPSILON){// p1,p2,p4 are collinear, p3 is considerable
  //----------------------
  if(d3*d3<=distanceTolerance*(dx*dx+dy*dy)){if(m_angle_tolerance<curve_angle_tolerance_epsilon){points.push(vec2(x1234,y1234));return;}// Angle Condition
  //----------------------
  da1=Math.abs(Math.atan2(y4-y3,x4-x3)-Math.atan2(y3-y2,x3-x2));if(da1>=pi)da1=2*pi-da1;if(da1<m_angle_tolerance){points.push(vec2(x2,y2));points.push(vec2(x3,y3));return;}if(m_cusp_limit!==0.0){if(da1>m_cusp_limit){points.push(vec2(x3,y3));return;}}}}else {// Collinear case
  //-----------------
  dx=x1234-(x1+x4)/2;dy=y1234-(y1+y4)/2;if(dx*dx+dy*dy<=distanceTolerance){points.push(vec2(x1234,y1234));return;}}}}// Continue subdivision
  //----------------------
  recursive(x1,y1,x12,y12,x123,y123,x1234,y1234,points,distanceTolerance,level+1);recursive(x1234,y1234,x234,y234,x34,y34,x4,y4,points,distanceTolerance,level+1);}};/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"create",function(){return create;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"clone",function(){return clone;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"copy",function(){return copy;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"scaleAndAdd",function(){return scaleAndAdd;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"dot",function(){return dot;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"rotate",function(){return rotate;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"cross",function(){return cross;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"sub",function(){return sub;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"add",function(){return add;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"computeMiter",function(){return computeMiter;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normal",function(){return normal;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"direction",function(){return direction;});/* harmony import */var gl_matrix__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(1);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function clone(arr){return [arr[0],arr[1]];}function create(){return [0,0];}var copy=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].copy;var scaleAndAdd=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].scaleAndAdd;var dot=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].dot;var rotate=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].rotate;var cross=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].cross;var sub=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].sub;var add=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].add;var normalize=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].normalize;var set=gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].set;var tmp=create();function computeMiter(tangent,miter,lineA,lineB,halfThick){// get tangent line
  add(tangent,lineA,lineB);normalize(tangent,tangent);// get miter as a unit vector
  set(miter,-tangent[1],tangent[0]);set(tmp,-lineA[1],lineA[0]);// get the necessary length of our miter
  var miterLen=halfThick/dot(miter,tmp);return Math.abs(miterLen);// avoid -Infinity
  }function normal(out,dir){// get perpendicular
  set(out,-dir[1],dir[0]);return out;}function direction(out,a,b){// get unit dir of two lines
  sub(out,a,b);normalize(out,out);return out;}/***/},function(module,exports,__webpack_require__){var simplifyRadialDist=__webpack_require__(68);var simplifyDouglasPeucker=__webpack_require__(69);//simplifies using both algorithms
  module.exports=function simplify(points,tolerance){points=simplifyRadialDist(points,tolerance);points=simplifyDouglasPeucker(points,tolerance);return points;};module.exports.radialDistance=simplifyRadialDist;module.exports.douglasPeucker=simplifyDouglasPeucker;/***/},function(module,exports){function getSqDist(p1,p2){var dx=p1[0]-p2[0],dy=p1[1]-p2[1];return dx*dx+dy*dy;}// basic distance-based simplification
  module.exports=function simplifyRadialDist(points,tolerance){if(points.length<=1)return points;tolerance=typeof tolerance==='number'?tolerance:1;var sqTolerance=tolerance*tolerance;var prevPoint=points[0],newPoints=[prevPoint],point;for(var i=1,len=points.length;i<len;i++){point=points[i];if(getSqDist(point,prevPoint)>sqTolerance){newPoints.push(point);prevPoint=point;}}if(prevPoint!==point)newPoints.push(point);return newPoints;};/***/},function(module,exports){// square distance from a point to a segment
  function getSqSegDist(p,p1,p2){var x=p1[0],y=p1[1],dx=p2[0]-x,dy=p2[1]-y;if(dx!==0||dy!==0){var t=((p[0]-x)*dx+(p[1]-y)*dy)/(dx*dx+dy*dy);if(t>1){x=p2[0];y=p2[1];}else if(t>0){x+=dx*t;y+=dy*t;}}dx=p[0]-x;dy=p[1]-y;return dx*dx+dy*dy;}function simplifyDPStep(points,first,last,sqTolerance,simplified){var maxSqDist=sqTolerance,index;for(var i=first+1;i<last;i++){var sqDist=getSqSegDist(points[i],points[first],points[last]);if(sqDist>maxSqDist){index=i;maxSqDist=sqDist;}}if(maxSqDist>sqTolerance){if(index-first>1)simplifyDPStep(points,first,index,sqTolerance,simplified);simplified.push(points[index]);if(last-index>1)simplifyDPStep(points,index,last,sqTolerance,simplified);}}// simplification using Ramer-Douglas-Peucker algorithm
  module.exports=function simplifyDouglasPeucker(points,tolerance){if(points.length<=1)return points;tolerance=typeof tolerance==='number'?tolerance:1;var sqTolerance=tolerance*tolerance;var last=points.length-1;var simplified=[points[0]];simplifyDPStep(points,0,last,sqTolerance,simplified);simplified.push(points[last]);return simplified;};/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getTotalLength",function(){return getTotalLength;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getPointAtLength",function(){return getPointAtLength;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getDashContours",function(){return getDashContours;});/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _positions__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(71);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function getTotalLength(contours){if(contours.totalLength!=null)return contours.totalLength;var length=0;contours.forEach(function(points){var s=points[0];for(var i=1;i<points.length;i++){var p=points[i];length+=Object(_positions__WEBPACK_IMPORTED_MODULE_1__["distance"])(s,p);s=p;}});contours.totalLength=length;return length;}function splitContours(contours,length){var rest=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;length=Number(length);if(!Number.isFinite(length)){throw new TypeError('Failed to execute \'getPointAtLength\' on figure: The provided float value is non-finite.');}if(length<=0){throw new TypeError('Length must > 0');}var contoursLength=getTotalLength(contours);if(length>=contoursLength){var points=contours[contours.length-1];var p0=points[points.length-2];var p1=points[points.length-1];var angle=Math.atan2(p1[1]-p0[1],p1[0]-p0[0]);return {current:contours.map(function(c){return _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(c);}),point:{x:p1[0],y:p1[1],angle:angle}};}var current=[];for(var i=0;i<contours.length;i++){current[i]=[];var _points=contours[i];var _p=_points[0];for(var j=1;j<_points.length;j++){var _p2=_points[j];var d=Object(_positions__WEBPACK_IMPORTED_MODULE_1__["distance"])(_p,_p2);if(length<d){var p=length/d;var _angle=Math.atan2(_p2[1]-_p[1],_p2[0]-_p[0]);var point={x:_p[0]*(1-p)+_p2[0]*p,y:_p[1]*(1-p)+_p2[1]*p,angle:_angle};current[i].push(_p);if(length>0)current[i].push([point.x,point.y]);if(!rest){return {current:current,point:point};}var restContours=[];var o=i;for(;i<contours.length;i++){restContours[i-o]=[];if(i===o)restContours[0].push([point.x,point.y]);for(;j<_points.length;j++){restContours[i-o].push(_points[j]);}j=0;}return {current:current,point:point,rest:restContours};}length-=d;current[i].push(_p);_p=_p2;}}}function getPointAtLength(contours,length){length=Number(length);if(!Number.isFinite(length)){throw new TypeError('Failed to execute \'getPointAtLength\' on figure: The provided float value is non-finite.');}if(contours.length<=0)return {x:0,y:0,angle:0};if(length<=0){var p0=contours[0][0];var p1=contours[0][1];var angle=Math.atan2(p1[1]-p0[1],p1[0]-p0[0]);return {x:p0[0],y:p0[1],angle:angle};}return splitContours(contours,length,false).point;}function getDashContours(contours,lineDash,lineDashOffset){var idx=0;var dash=lineDash[0];var rest=contours;var splitedContours=[];var lineDashLen=lineDash.length;if(lineDashOffset>0){do{lineDashOffset-=lineDash[idx%lineDashLen];idx++;}while(lineDashOffset>0);if(lineDashOffset<0){dash=-lineDashOffset;idx--;}}else if(lineDashOffset<0){idx=-1;do{lineDashOffset+=lineDash[idx%lineDashLen+lineDashLen-1];idx--;}while(lineDashOffset<0);if(lineDashOffset>=0){idx++;dash=lineDash[idx%lineDashLen+lineDashLen-1]-lineDashOffset;}}do{var splited=splitContours(rest,dash);rest=splited.rest;if(++idx%2)splitedContours.push.apply(splitedContours,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(splited.current));var dashIndex=idx%lineDashLen;if(dashIndex<0)dashIndex+=lineDashLen;dash=lineDash[dashIndex];}while(rest);return splitedContours;}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"normalize",function(){return normalize;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"distance",function(){return distance;});/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function normalize(_ref,w,h,d){var _ref2=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref,3),x=_ref2[0],y=_ref2[1],z=_ref2[2];x=x*2/w-1;y=1-y*2/h;if(Number.isFinite(d)){z=z*2/d-1;return [x,y,z];}return [x,y];}function distance(_ref3,_ref4){var _ref5=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref3,3),x1=_ref5[0],y1=_ref5[1],_ref5$=_ref5[2],z1=_ref5$===void 0?0:_ref5$;var _ref6=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref4,3),x2=_ref6[0],y2=_ref6[1],_ref6$=_ref6[2],z2=_ref6$===void 0?0:_ref6$;return Math.hypot(x2-x1,y2-y1,z2-z1);}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"getPoint",function(){return getPoint;});__webpack_require__(1).glMatrix.setMatrixArrayType(Array);// 根据椭圆旋转角度求椭圆上的点
  var PI2=Math.PI*2;function getPoint(x0,y0,a,b,theta){theta%=PI2;if(theta<0)theta+=PI2;var k=Math.tan(theta);if(Math.abs(k)<1e5){// y - y0 = k (x - x0)
  // y = k x + (y0 - k x0)
  // (x - x0) ** 2 / a ** 2 + (y - y0) ** 2 / b ** 2 = 1
  var c=y0-k*x0;var t=1/Math.pow(a,2)+Math.pow(k,2)/Math.pow(b,2);var d=-1;if(theta<=Math.PI/2||theta>3*Math.PI/2)d=1;var x=d*Math.sqrt(1/t)+x0;var y=k*x+c;return [x,y];}if(theta<Math.PI){return [x0,y0+b];}return [x0,y0-b];}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"default",function(){return Mesh2D;});/* harmony import */var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(74);/* harmony import */var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(23);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(24);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(13);/* harmony import */var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4__);/* harmony import */var gl_matrix__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(1);/* harmony import */var bound_points__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(59);/* harmony import */var bound_points__WEBPACK_IMPORTED_MODULE_6___default=/*#__PURE__*/__webpack_require__.n(bound_points__WEBPACK_IMPORTED_MODULE_6__);/* harmony import */var _extrude_contours__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(76);/* harmony import */var _utils_flatten_meshes__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(44);/* harmony import */var _utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(40);/* harmony import */var _utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(46);/* harmony import */var _utils_transform__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(78);/* harmony import */var _utils_contours__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(70);/* harmony import */var _triangulate_contours__WEBPACK_IMPORTED_MODULE_13__=__webpack_require__(79);/* harmony import */var _triangulate_contours__WEBPACK_IMPORTED_MODULE_13___default=/*#__PURE__*/__webpack_require__.n(_triangulate_contours__WEBPACK_IMPORTED_MODULE_13__);/* harmony import */var _svg_path_contours__WEBPACK_IMPORTED_MODULE_14__=__webpack_require__(63);/* harmony import */var _svg_path_contours__WEBPACK_IMPORTED_MODULE_14___default=/*#__PURE__*/__webpack_require__.n(_svg_path_contours__WEBPACK_IMPORTED_MODULE_14__);/* harmony import */var _utils_parse_color__WEBPACK_IMPORTED_MODULE_15__=__webpack_require__(47);/* harmony import */var _figure2d__WEBPACK_IMPORTED_MODULE_16__=__webpack_require__(56);/* harmony import */var _utils_env__WEBPACK_IMPORTED_MODULE_17__=__webpack_require__(37);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var _mesh=Symbol('mesh');var _contours=Symbol('contours');var _stroke=Symbol('stroke');var _fill=Symbol('fill');var _strokeColor=Symbol('strokeColor');var _fillColor=Symbol('fillColor');var _transform=Symbol('transform');var _invertTransform=Symbol('invertTransform');var _uniforms=Symbol('uniforms');var _texOptions=Symbol('texOptions');var _blend=Symbol('blend');var _applyTexture=Symbol('applyTexture');var _applyTransform=Symbol('applyTransform');var _applyGradientTransform=Symbol('applyGradientTransform');var _applyProgram=Symbol('applyProgram');var _gradient=Symbol('gradient');var _filter=Symbol('filter');var _opacity=Symbol('opacity');var _program=Symbol('program');var _attributes=Symbol('attributes');var _pass=Symbol('pass');var _clipContext=Symbol('clipContext');var _applyClipPath=Symbol('applyClipPath');// function normalizePoints(points, bound) {
  //   const [w, h] = bound[1];
  //   for(let i = 0; i < points.length; i++) {
  //     const point = points[i];
  //     point[0] = 2 * point[0] / w - 1;
  //     point[1] = 1 - 2 * point[1] / h;
  //   }
  // }
  function generateUV(bounds,positions){var w=bounds[1][0]-bounds[0][0],h=bounds[1][1]-bounds[0][1];var ret=[];for(var j=0;j<positions.length;j++){var p=positions[j];var uv=[(p[0]-bounds[0][0])/w,1-(p[1]-bounds[0][1])/h];ret.push(uv);}return ret;}function getTexCoord(_ref,_ref2,_ref3){var _ref4=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref,2),x=_ref4[0],y=_ref4[1];var _ref5=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref2,4),ox=_ref5[0],oy=_ref5[1],w=_ref5[2],h=_ref5[3];var scale=_ref3.scale;if(!scale){x/=w;y=1-y/h;x-=ox;y+=oy;}return [x,y,0];}function _accurate(path,scale,simplify){var contours=_svg_path_contours__WEBPACK_IMPORTED_MODULE_14___default()(path,scale,simplify);contours.path=path;contours.simplify=simplify;contours.scale=scale;return contours;}var Mesh2D=/*#__PURE__*/function(){function Mesh2D(figure){_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this,Mesh2D);this[_stroke]=null;this[_fill]=null;this[_transform]=[1,0,0,1,0,0];this[_opacity]=1.0;this[_uniforms]={};this[_filter]=[];this[_blend]=null;this[_texOptions]={};this.contours=figure.contours;this[_program]=null;this[_attributes]={};this[_pass]=[];}_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(Mesh2D,[{key:"setProgram",value:function setProgram(program){this[_program]=program;if(this[_mesh]){this[_applyProgram](program);}}},{key:"setAttribute",value:function setAttribute(key,setter){if(setter==null){delete this[_attributes][key];}else {this[_attributes][key]=setter;}}},{key:"getOpacity",value:function getOpacity(){return this[_opacity];}},{key:"setOpacity",value:function setOpacity(value){if(value<0||value>1.0)throw new TypeError('Invalid opacity value.');if(this[_mesh]){this[_mesh].positions.forEach(function(p){p[2]=1/p[2]>0?value:-value;});}this[_opacity]=value;}},{key:"setClipPath",value:function setClipPath(path){this.clipPath=path;if(this[_uniforms].u_clipSampler){this[_uniforms].u_clipSampler.delete();}this.setUniforms({u_clipSampler:null});if(this[_mesh]){delete this[_mesh].attributes.a_clipUV;}if(path&&this[_mesh]){this[_applyClipPath]();}}},{key:_applyClipPath,value:function value(){if(this.clipPath){if(!this[_clipContext]){this[_clipContext]=_utils_env__WEBPACK_IMPORTED_MODULE_17__["default"].createCanvas(1,1);}var _this$boundingBox=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(this.boundingBox,2),_this$boundingBox$=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_this$boundingBox[0],2),_x=_this$boundingBox$[0],y=_this$boundingBox$[1],_this$boundingBox$2=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_this$boundingBox[1],2),w=_this$boundingBox$2[0],h=_this$boundingBox$2[1];if(w&&h){this[_clipContext].width=w-_x;this[_clipContext].height=h-y;}var context=this[_clipContext].getContext('2d');var path=new Path2D(this.clipPath);context.clearRect(0,0,this[_clipContext].width,this[_clipContext].height);context.save();context.translate(-_x,-y);context.fillStyle='white';context.fill(path);context.restore();this[_mesh].clipPath=this[_clipContext];var uv=generateUV(this.boundingBox,this[_mesh].position0);this[_mesh].attributes.a_clipUV=uv;}}},{key:"getPointAtLength",value:function getPointAtLength(length){return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_12__["getPointAtLength"])(this[_contours],length);}},{key:"getTotalLength",value:function getTotalLength(){return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_12__["getTotalLength"])(this[_contours]);}},{key:_applyProgram,value:function value(program){var attributes=this[_attributes];var positions=this[_mesh].position0;var attribs=Object.entries(program._attribute);for(var i=0;i<attribs.length;i++){var _attribs$i=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(attribs[i],2),name=_attribs$i[0],opts=_attribs$i[1];if(name!=='a_color'&&name!=='a_sourceRect'&&opts!=='ignored'){var setter=attributes[name];// console.log(opts.size);
  if(name==='uv'&&!setter){var bounds=this[_mesh].boundingBox||bound_points__WEBPACK_IMPORTED_MODULE_6___default()(positions);this[_mesh].attributes[name]=generateUV(bounds,positions);}else {this[_mesh].attributes[name]=[];for(var j=0;j<positions.length;j++){var p=positions[j];this[_mesh].attributes[name].push(setter?setter(p,i,positions):Array(opts.size).fill(0));}}}}}// {stroke, fill}
  },{key:_applyTransform,value:function value(mesh,m){var positions=mesh.positions,p=mesh.position0;for(var i=0;i<positions.length;i++){var _p$i=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(p[i],2),_x2=_p$i[0],y=_p$i[1];var position=positions[i];position[0]=_x2*m[0]+y*m[2]+m[4];position[1]=_x2*m[1]+y*m[3]+m[5];}this._updateMatrix=false;}},{key:_applyGradientTransform,value:function value(){var m=this[_transform];var vector=_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(this._radialGradientVector);if(vector){var _vector2=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(vector,5),x1=_vector2[0],y1=_vector2[1],x2=_vector2[3],y2=_vector2[4];vector[0]=x1*m[0]+y1*m[2]+m[4];vector[1]=x1*m[1]+y1*m[3]+m[5];vector[3]=x2*m[0]+y2*m[2]+m[4];vector[4]=x2*m[1]+y2*m[3]+m[5];this[_uniforms].u_radialGradientVector=vector;}}},{key:_applyTexture,value:function value(mesh,options){function compareRect(r1,r2){if(r1==null&&r2==null)return true;if(r1==null||r2==null)return false;return r1[0]===r2[0]&&r1[1]===r2[1]&&r1[2]===r2[2]&&r1[3]===r2[3];}var texture=this[_uniforms].u_texSampler;if(!texture)return;var _texture$_img=texture._img,imgWidth=_texture$_img.width,imgHeight=_texture$_img.height;var srcRect=options.srcRect;var rect=options.rect||[0,0];if(options.rotated){rect=[-rect[1],rect[0],rect[3],rect[2]];}if(rect[2]==null)rect[2]=srcRect?srcRect[2]:imgWidth;if(rect[3]==null)rect[3]=srcRect?srcRect[3]:imgHeight;if(options.hidden){mesh.textureCoord=mesh.positions.map(function(){return [-1,-1,-1];});}else if(!mesh.textureCoord||!compareRect(this[_texOptions].rect,options.rect)||this[_texOptions].hidden!==options.hidden||this[_texOptions].rotated!==options.rotated){var m=null;if(options.rotated){m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].rotate(Array.of(0,0,0,0,0,0),gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].fromValues(1,0,0,1,0,0),0.5*Math.PI);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[0,-rect[2]]);}mesh.textureCoord=mesh.position0.map(function(_ref6){var _ref7=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref6,3),x=_ref7[0],y=_ref7[1],z=_ref7[2];if(1/z>0){// fillTag
  if(options.rotated){var x0=x*m[0]+y*m[2]+m[4];var y0=x*m[1]+y*m[3]+m[5];x=x0;y=y0;}var texCoord=getTexCoord([x,y],[rect[0]/rect[2],rect[1]/rect[3],rect[2],rect[3]],options);if(options.repeat)texCoord[2]=1;return texCoord;}return [-1,-1,-1];});}if(srcRect){var sRect=[srcRect[0]/imgWidth,srcRect[1]/imgHeight,srcRect[2]/imgWidth,srcRect[3]/imgHeight];mesh.attributes.a_sourceRect=mesh.positions.map(function(){return [].concat(sRect);});}else {mesh.attributes.a_sourceRect=mesh.positions.map(function(){return [0,0,0,0];});}}},{key:"accurate",value:function accurate(scale){if(!this.contours)return;var path=this.contours.path;if(path){var simplify=this.contours.simplify;var contours=_accurate(this.contours.path,2*scale,simplify);this[_mesh]=null;this[_contours]=contours;}}},{key:"canIgnore",value:function canIgnore(){var noStroke=this[_stroke]==null||this[_stroke].lineWidth===0||this[_strokeColor][3]===0;var noFill=this[_fill]==null||this[_fillColor][3]===0;var noGradient=this[_uniforms].u_radialGradientVector==null;var noTexture=this[_uniforms].u_texSampler==null;return this[_opacity]===0||this[_program]==null&&noStroke&&noFill&&noGradient&&noTexture&&!this.beforeRender&&!this.afterRender;}// join: 'miter' or 'bevel'
  // cap: 'butt' or 'square'
  // lineDash: null
  // lineDashOffset: 0
  },{key:"setStroke",value:function setStroke(){var _ref8=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref8$thickness=_ref8.thickness,thickness=_ref8$thickness===void 0?1:_ref8$thickness,_ref8$cap=_ref8.cap,cap=_ref8$cap===void 0?'butt':_ref8$cap,_ref8$join=_ref8.join,join=_ref8$join===void 0?'miter':_ref8$join,_ref8$miterLimit=_ref8.miterLimit,miterLimit=_ref8$miterLimit===void 0?10:_ref8$miterLimit,_ref8$color=_ref8.color,color=_ref8$color===void 0?[0,0,0,0]:_ref8$color,_ref8$lineDash=_ref8.lineDash,lineDash=_ref8$lineDash===void 0?null:_ref8$lineDash,_ref8$lineDashOffset=_ref8.lineDashOffset,lineDashOffset=_ref8$lineDashOffset===void 0?0:_ref8$lineDashOffset,_ref8$roundSegments=_ref8.roundSegments,roundSegments=_ref8$roundSegments===void 0?20:_ref8$roundSegments;this[_mesh]=null;this[_stroke]=new _extrude_contours__WEBPACK_IMPORTED_MODULE_7__["default"]({lineWidth:thickness,lineCap:cap,lineJoin:join,miterLimit:miterLimit,roundSegments:roundSegments});if(typeof color==='string')color=Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_15__["default"])(color);this[_strokeColor]=color;this[_stroke].lineDash=lineDash;this[_stroke].lineDashOffset=lineDashOffset;return this;}},{key:"setFill",value:function setFill(){var _ref9=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref9$rule=_ref9.rule,rule=_ref9$rule===void 0?this.fillRule:_ref9$rule,_ref9$color=_ref9.color,color=_ref9$color===void 0?[0,0,0,0]:_ref9$color;this[_mesh]=null;this[_fill]={rule:rule};if(typeof color==='string')color=Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_15__["default"])(color);this[_fillColor]=color;return this;}/**
        options: {
          scale: false,
          repeat: false,
          rotated: false,
          rect: [10, 10],
          srcRect: [...],
          hidden: false,
        }
       */},{key:"setTexture",value:function setTexture(texture){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(texture&&texture.image){var _texture=texture,image=_texture.image,rect=_texture.rect;texture=image;if(options.rect){for(var i=0;i<options.rect.length;i++){rect[i]=options.rect[i];}}options.rect=rect;}if(!this[_fill]){this.setFill();}this.setUniforms({u_texSampler:texture});if(this[_mesh]){this[_applyTexture](this[_mesh],options);}this[_texOptions]=options;return this;}},{key:"setCircularGradient",value:function setCircularGradient(){var _ref10=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},vector=_ref10.vector,gradientColors=_ref10.colors,_ref10$type=_ref10.type,type=_ref10$type===void 0?'fill':_ref10$type;if(vector.length!==3)throw new TypeError('Invalid linearGradient.');this.setGradient({vector:vector,colors:gradientColors,type:type});}},{key:"setLinearGradient",value:function setLinearGradient(){var _ref11=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},vector=_ref11.vector,gradientColors=_ref11.colors,_ref11$type=_ref11.type,type=_ref11$type===void 0?'fill':_ref11$type;if(vector.length!==4)throw new TypeError('Invalid linearGradient.');this.setGradient({vector:vector,colors:gradientColors,type:type});}},{key:"setRadialGradient",value:function setRadialGradient(){var _ref12=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},vector=_ref12.vector,gradientColors=_ref12.colors,_ref12$type=_ref12.type,type=_ref12$type===void 0?'fill':_ref12$type;if(vector.length!==6)throw new TypeError('Invalid radialGradient.');this.setGradient({vector:vector,colors:gradientColors,type:type});}/**
        vector: [x0, y0, r0, x1, y1, r1],
        colors: [{offset:0, color}, {offset:1, color}, ...],
       */},{key:"setGradient",value:function setGradient(){var _ref13=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},vector=_ref13.vector,gradientColors=_ref13.colors,_ref13$type=_ref13.type,type=_ref13$type===void 0?'fill':_ref13$type;gradientColors=gradientColors.map(function(_ref14){var offset=_ref14.offset,color=_ref14.color;if(typeof color==='string')color=Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_15__["default"])(color);return {offset:offset,color:color};});this[_gradient]=this[_gradient]||{};this[_gradient][type]={vector:vector,colors:gradientColors};gradientColors.sort(function(a,b){return a.offset-b.offset;});var colorSteps=[];gradientColors.forEach(function(_ref15){var offset=_ref15.offset,color=_ref15.color;colorSteps.push.apply(colorSteps,[offset].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(color)));});var _vector;if(vector.length===4){// linear gradient;
  _vector=[vector[0],vector[1],0,vector[2],vector[3],0];}else {_vector=_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(vector);}if(colorSteps.length<40)colorSteps.push(-1);if(colorSteps.length>40)throw new Error('Too many colors, should be less than 8 colors');this._radialGradientVector=_vector;this[_uniforms].u_colorSteps=colorSteps;if(type==='fill')this[_uniforms].u_gradientType=1;else this[_uniforms].u_gradientType=0;this[_applyGradientTransform]();return this;}},{key:"setUniforms",value:function setUniforms(){var uniforms=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};Object.assign(this[_uniforms],uniforms);return this;}},{key:"setTransform",value:function setTransform(){var transform=this[_transform];for(var _len=arguments.length,m=new Array(_len),_key=0;_key<_len;_key++){m[_key]=arguments[_key];}if(!gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].equals(m,transform)){this[_transform]=m;delete this[_invertTransform];this._updateMatrix=true;}return this;}},{key:"transform",value:function transform(){var transform=this[_transform];for(var _len2=arguments.length,m=new Array(_len2),_key2=0;_key2<_len2;_key2++){m[_key2]=arguments[_key2];}this[_transform]=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0,0,0,0,0,0),transform,m);delete this[_invertTransform];this._updateMatrix=true;return this;}},{key:"translate",value:function translate(x,y){var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[x,y]);return this.transform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"rotate",value:function rotate(rad){var _ref16=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[0,0],_ref17=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref16,2),ox=_ref17[0],oy=_ref17[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].rotate(Array.of(0,0,0,0,0,0),m,rad);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[-ox,-oy]);return this.transform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"scale",value:function scale(x){var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:x;var _ref18=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[0,0],_ref19=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref18,2),ox=_ref19[0],oy=_ref19[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].scale(Array.of(0,0,0,0,0,0),m,[x,y]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[-ox,-oy]);return this.transform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"skew",value:function skew(x){var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:x;var _ref20=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[0,0],_ref21=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref20,2),ox=_ref21[0],oy=_ref21[1];var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[ox,oy]);m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0,0,0,0,0,0),m,gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].fromValues(1,Math.tan(y),Math.tan(x),1,0,0));m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0,0,0,0,0,0),m,[-ox,-oy]);return this.transform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));}},{key:"clearFilter",value:function clearFilter(){this.setColorTransform(null);this[_filter].length=0;return this;}},{key:"setColorTransform",value:function setColorTransform(){for(var _len3=arguments.length,m=new Array(_len3),_key3=0;_key3<_len3;_key3++){m[_key3]=arguments[_key3];}if(m[0]===null){this.setUniforms({u_filterFlag:0,u_colorMatrix:0});}else {this.setUniforms({u_filterFlag:1,u_colorMatrix:m});}return this;}// apply linear color transform
  },{key:"transformColor",value:function transformColor(){var transform=this.uniforms.u_colorMatrix;for(var _len4=arguments.length,m=new Array(_len4),_key4=0;_key4<_len4;_key4++){m[_key4]=arguments[_key4];}if(transform){transform=Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["multiply"])(transform,m);}else {transform=m;}this.setColorTransform.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(transform));return this;}},{key:"blur",value:function blur(length){this[_filter].push("blur(".concat(length,"px)"));return this;}},{key:"brightness",value:function brightness(){var p=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this[_filter].push("brightness(".concat(100*p,"%)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["brightness"])(p)));}},{key:"contrast",value:function contrast(){var p=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this[_filter].push("contrast(".concat(100*p,"%)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["contrast"])(p)));}},{key:"dropShadow",value:function dropShadow(offsetX,offsetY){var blurRadius=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var color=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[0,0,0,1];if(Array.isArray(color))color=Object(_utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__["default"])(color);this[_filter].push("drop-shadow(".concat(offsetX,"px ").concat(offsetY,"px ").concat(blurRadius,"px ").concat(color,")"));return this;}},{key:"grayscale",value:function grayscale(){var p=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this[_filter].push("grayscale(".concat(100*p,"%)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["grayscale"])(p)));}// https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
  },{key:"hueRotate",value:function hueRotate(){var deg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;this[_filter].push("hue-rotate(".concat(deg,"deg)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["hueRotate"])(deg)));}},{key:"invert",value:function invert(){var p=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this[_filter].push("invert(".concat(100*p,"%)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["invert"])(p)));}},{key:"opacity",value:function opacity(){var p=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this[_filter].push("opacity(".concat(100*p,"%)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["opacity"])(p)));}},{key:"saturate",value:function saturate(){var p=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this[_filter].push("saturate(".concat(100*p,"%)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["saturate"])(p)));}},{key:"sepia",value:function sepia(){var p=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this[_filter].push("sepia(".concat(100*p,"%)"));return this.transformColor.apply(this,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["sepia"])(p)));}},{key:"url",value:function url(svgFilter){this[_filter].push("url(".concat(svgFilter,")"));return this;}},{key:"isPointCollision",value:function isPointCollision(x,y){var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'both';var meshData=this.meshData;var positions=meshData.positions,cells=meshData.cells;var m=this.invertMatrix;var x0=m[0]*x+m[2]*y+m[4];var y0=m[1]*x+m[3]*y+m[5];var box=this.boundingBox;if(x0<box[0][0]||x0>box[1][0]||y0<box[0][1]||y0>box[1][1]){return false;}function projectionOn(_ref22,_ref23,_ref24){var _ref25=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref22,2),x0=_ref25[0],y0=_ref25[1];var _ref26=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref23,2),x1=_ref26[0],y1=_ref26[1];var _ref27=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref24,2),x2=_ref27[0],y2=_ref27[1];var v2x=x2-x1;var v2y=y2-y1;var p=((x0-x1)*v2x+(y0-y1)*v2y)/(Math.pow(v2x,2)+Math.pow(v2y,2));return p>=0&&p<=1;}for(var i=0;i<cells.length;i++){var cell=cells[i];if(type==='fill'&&cell[0]>=meshData.fillPointCount)break;if(type==='stroke'&&cell[0]<meshData.fillPointCount)continue;// eslint-disable-line no-continue
  var _cell$map=cell.map(function(idx){return positions[idx];}),_cell$map2=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map,3),_cell$map2$=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map2[0],2),x1=_cell$map2$[0],y1=_cell$map2$[1],_cell$map2$2=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map2[1],2),x2=_cell$map2$2[0],y2=_cell$map2$2[1],_cell$map2$3=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map2[2],2),x3=_cell$map2$3[0],y3=_cell$map2$3[1];var s1=Math.sign((x-x1)*(y2-y1)-(x2-x1)*(y-y1));if(s1===0&&projectionOn([x,y],[x1,y1],[x2,y2])){return true;}var s2=Math.sign((x-x2)*(y3-y2)-(x3-x2)*(y-y2));if(s2===0&&projectionOn([x,y],[x2,y2],[x3,y3])){return true;}var s3=Math.sign((x-x3)*(y1-y3)-(x1-x3)*(y-y3));if(s3===0&&projectionOn([x,y],[x3,y3],[x1,y1])){return true;}if(s1===1&&s2===1&&s3===1||s1===-1&&s2===-1&&s3===-1){return true;}}return false;}},{key:"isPointInFill",value:function isPointInFill(x,y){return this.isPointCollision(x,y,'fill');}},{key:"isPointInStroke",value:function isPointInStroke(x,y){return this.isPointCollision(x,y,'stroke');}},{key:"addPass",value:function addPass(program){var _ref28=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},width=_ref28.width,height=_ref28.height,uniforms=_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_ref28,["width","height"]);var figure=new _figure2d__WEBPACK_IMPORTED_MODULE_16__["default"]();figure.rect(0,0,width,height);var mesh=new Mesh2D(figure,{width:width,height:height});mesh.setUniforms(uniforms);mesh.setProgram(program);this[_pass].push(mesh);}},{key:"contours",get:function get(){return this[_contours];},set:function set(contours){this[_mesh]=null;this[_contours]=contours;var scale=contours.scale;var acc=this.transformScale/scale;if(acc>1.5){this.accurate(this.transformScale);}}},{key:"program",get:function get(){return this[_program];}},{key:"blend",get:function get(){return this[_blend]==null?'auto':this[_blend];},set:function set(blend){this[_blend]=blend;if(this[_mesh])this[_mesh].enableBlend=this.enableBlend;}},{key:"boundingBox",get:function get(){if(this[_mesh]&&this[_mesh].boundingBox)return this[_mesh].boundingBox;var meshData=this.meshData;if(meshData){var positions=meshData.position0;if(positions.length)meshData.boundingBox=bound_points__WEBPACK_IMPORTED_MODULE_6___default()(positions);else return [[0,0],[0,0]];return meshData.boundingBox;}return [[0,0],[0,0]];}},{key:"boundingCenter",get:function get(){var bound=this.boundingBox;if(bound){return [0.5*(bound[0][0]+bound[1][0]),0.5*(bound[0][1]+bound[1][1])];}return [0,0];}},{key:"fillRule",get:function get(){if(this[_fill]){return this[_fill].rule;}return 'nonzero';}},{key:"lineWidth",get:function get(){if(this[_stroke]){return this[_stroke].lineWidth;}return 0;}},{key:"lineCap",get:function get(){if(this[_stroke]){return this[_stroke].lineCap;}return '';}},{key:"lineJoin",get:function get(){if(this[_stroke]){return this[_stroke].lineJoin;}return '';}},{key:"miterLimit",get:function get(){if(this[_stroke]){return this[_stroke].miterLimit;}return 0;}},{key:"strokeStyle",get:function get(){if(this[_strokeColor]&&this[_strokeColor][3]!==0){return Object(_utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__["default"])(this[_strokeColor]);}return '';}},{key:"lineDash",get:function get(){if(this[_stroke]){return this[_stroke].lineDash;}return null;}},{key:"lineDashOffset",get:function get(){if(this[_stroke]){return this[_stroke].lineDashOffset;}return 0;}},{key:"fillStyle",get:function get(){if(this[_fillColor]&&this[_fillColor][3]!==0){return Object(_utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__["default"])(this[_fillColor]);}return '';}},{key:"gradient",get:function get(){return this[_gradient];}},{key:"texture",get:function get(){if(this[_uniforms].u_texSampler){return {image:this[_uniforms].u_texSampler._img,options:this[_texOptions]};}return null;}},{key:"enableBlend",get:function get(){if(this[_blend]===true||this[_blend]===false)return this[_blend];return this[_opacity]<1.0||this[_strokeColor]!=null&&this[_strokeColor][3]<1.0||this[_fillColor]!=null&&this[_fillColor][3]<1.0||this[_uniforms].u_colorMatrix!=null&&this[_uniforms].u_colorMatrix[18]<1.0||this[_uniforms].u_radialGradientVector!=null||this.beforeRender||this.afterRender;}},{key:"filterCanvas",get:function get(){return /blur|drop-shadow|url/.test(this.filter);}},{key:"filter",get:function get(){return this[_filter].join(' ');}},{key:"transformMatrix",get:function get(){return this[_transform];}},{key:"invertMatrix",get:function get(){if(!this[_invertTransform]){var m=gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].invert(Array.of(0,0,0,0,0,0),this[_transform]);this[_invertTransform]=m;}return this[_invertTransform];}},{key:"transformScale",get:function get(){var m=this[_transform];return Math.max(Math.hypot(m[0],m[1]),Math.hypot(m[2],m[3]));}},{key:"uniforms",get:function get(){return this[_uniforms];}},{key:"pass",get:function get(){return this[_pass];}},{key:"meshData",get:function get(){var _this=this;// eslint-disable-line complexity
  if(this._updateMatrix){var acc=this.transformScale/this.contours.scale;if(acc>1.5){this.accurate(this.transformScale);}}if(!this[_mesh]){if(!this[_fill]&&!this[_stroke]){this.setFill();}var contours=this[_contours];var meshes={};if(contours&&contours.length){if(this[_fill]){try{var _mesh2=_triangulate_contours__WEBPACK_IMPORTED_MODULE_13___default()(contours,this[_fill]);_mesh2.positions=_mesh2.positions.map(function(p){p.push(_this[_opacity]);return p;});_mesh2.attributes={a_color:Array.from({length:_mesh2.positions.length}).map(function(){return _this[_fillColor].map(function(c){return Math.round(255*c);});})// a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
  };meshes.fill=_mesh2;}catch(ex){// ignore this[_fill]
  }}if(this[_stroke]){var lineDash=this[_stroke].lineDash;var strokeContours=contours;if(lineDash){var lineDashOffset=this[_stroke].lineDashOffset;strokeContours=Object(_utils_contours__WEBPACK_IMPORTED_MODULE_12__["getDashContours"])(contours,lineDash,lineDashOffset);}var _meshes=strokeContours.map(function(lines,i){var closed=lines.length>1&&gl_matrix__WEBPACK_IMPORTED_MODULE_5__["vec2"].equals(lines[0],lines[lines.length-1]);var points=_this[_stroke].build(lines,closed);return _triangulate_contours__WEBPACK_IMPORTED_MODULE_13___default()([points]);});_meshes.forEach(function(mesh){mesh.positions=mesh.positions.map(function(p){p.push(-_this[_opacity]);return p;});mesh.attributes={a_color:Array.from({length:mesh.positions.length}).map(function(){return _this[_strokeColor].map(function(c){return Math.round(255*c);});})};});meshes.stroke=Object(_utils_flatten_meshes__WEBPACK_IMPORTED_MODULE_8__["default"])(_meshes);}}var mesh=Object(_utils_flatten_meshes__WEBPACK_IMPORTED_MODULE_8__["default"])([meshes.fill,meshes.stroke]);mesh.fillPointCount=meshes.fill?meshes.fill.positions.length:0;mesh.enableBlend=this.enableBlend;mesh.position0=mesh.positions.map(function(_ref29){var _ref30=_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref29,3),x=_ref30[0],y=_ref30[1],z=_ref30[2];return [x,y,z];});mesh.uniforms=this[_uniforms];// if(!mesh.uniforms.u_filterFlag) mesh.uniforms.u_filterFlag = 0;
  // if(!mesh.uniforms.u_radialGradientVector) mesh.uniforms.u_radialGradientVector = [0, 0, 0, 0, 0, 0];
  this[_mesh]=mesh;if(!this[_uniforms].u_texSampler);else {this[_applyTexture](mesh,this[_texOptions]);}var transform=this[_transform];if(!Object(_utils_transform__WEBPACK_IMPORTED_MODULE_11__["isUnitTransform"])(transform)){this[_applyTransform](mesh,transform);if(this[_uniforms].u_radialGradientVector)this[_applyGradientTransform]();}if(this.clipPath){this[_applyClipPath]();}if(this[_program])this[_applyProgram](this[_program]);}if(this._updateMatrix){this[_mesh].matrix=this[_transform];this[_applyTransform](this[_mesh],this[_transform]);if(this[_uniforms].u_radialGradientVector)this[_applyGradientTransform]();}return this[_mesh];}}]);return Mesh2D;}();/***/},function(module,exports,__webpack_require__){var objectWithoutPropertiesLoose=__webpack_require__(75);function _objectWithoutProperties(source,excluded){if(source==null)return {};var target=objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key];}}return target;}module.exports=_objectWithoutProperties;/***/},function(module,exports){function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return {};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}module.exports=_objectWithoutPropertiesLoose;/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony import */var _stroke__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(77);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);/* harmony default export */__webpack_exports__["default"]=_stroke__WEBPACK_IMPORTED_MODULE_0__["Stroke"];/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"Stroke",function(){return Stroke;});/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(23);/* harmony import */var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(24);/* harmony import */var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);/* harmony import */var _utils__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(66);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var tmp=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();var lineA=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();var lineB=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();var tangent=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();var miter=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();var MAX_MITER_VALUE=1e20;// infinity * 0 cause NaN, fix #7
  var Stroke=/*#__PURE__*/function(){function Stroke(){var _ref=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref$lineWidth=_ref.lineWidth,lineWidth=_ref$lineWidth===void 0?1:_ref$lineWidth,_ref$lineJoin=_ref.lineJoin,lineJoin=_ref$lineJoin===void 0?'miter':_ref$lineJoin,_ref$miterLimit=_ref.miterLimit,miterLimit=_ref$miterLimit===void 0?10:_ref$miterLimit,_ref$lineCap=_ref.lineCap,lineCap=_ref$lineCap===void 0?'butt':_ref$lineCap,_ref$roundSegments=_ref.roundSegments,roundSegments=_ref$roundSegments===void 0?20:_ref$roundSegments;_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this,Stroke);this.lineWidth=lineWidth;this.lineJoin=lineJoin;this.miterLimit=miterLimit;this.lineCap=lineCap;this.roundSegments=roundSegments;this._normal=null;}_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Stroke,[{key:"build",value:function build(points){var closed=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var total=points.length;points=_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points);if(total<2)return points;if(closed){if(points[0][0]!==points[total-1][0]||points[0][1]!==points[total-1][1]){points.push(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[0]));}points.push(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[1]));}total=points.length;// clear flags
  this._normal=null;var contours={left:[],right:[]};var halfThick=this.lineWidth/2;var cap=this.lineCap;if(!closed&&cap==='square'){Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineA,points[0],points[1]);Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(points[0],points[0],lineA,halfThick);var idx=points.length-1;Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineA,points[idx],points[idx-1]);Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(points[idx],points[idx],lineA,halfThick);}// join each segment
  for(var i=1;i<total;i++){var last=points[i-1];var cur=points[i];var next=points[i+1];this._seg(contours,last,cur,next,halfThick,closed);}if(!closed&&cap==='round'){capRound(contours,this.roundSegments);}var ret=[].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(contours.left),_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(contours.right.reverse()));return ret;}},{key:"_seg",value:function _seg(contours,last,cur,next,halfThick,closed){var joinBevel=this.lineJoin==='bevel';var joinRound=this.lineJoin==='round';// get unit direction of line
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineA,cur,last);// if we don't yet have a normal from previous join,
  // compute based on line start - end
  if(!this._normal){this._normal=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();Object(_utils__WEBPACK_IMPORTED_MODULE_3__["normal"])(this._normal,lineA);}if(!contours.left.length){// start
  extrusions(contours,last,this._normal,halfThick);}if(!next){// no next segment, simple extrusion
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["normal"])(this._normal,lineA);if(!closed){extrusions(contours,cur,this._normal,halfThick);}else {extrusions(contours,last,this._normal,halfThick);}}else {// we have a next segment, start with miter
  // get unit dir of next line
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineB,next,cur);// stores tangent & miter
  var miterLen=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["computeMiter"])(tangent,miter,lineA,lineB,halfThick);// infinity * 0 cause NaN, fix #7
  miterLen=Math.min(miterLen,MAX_MITER_VALUE);// get orientation
  var flip=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["dot"])(tangent,this._normal)<0?-1:1;var bevel=joinBevel||joinRound;if(!bevel&&this.lineJoin==='miter'){var limit=miterLen/halfThick;if(limit>this.miterLimit){// miterLen = this.miterLimit * halfThick;
  bevel=true;}}// let len = Infinity;
  // if(next && !nextnext) len = Math.hypot(next[0] - cur[0], next[1] - cur[1]);
  if(bevel){// next two points in our first segment
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp,cur,this._normal,-halfThick*flip);addPoint(contours,tmp,flip);var maxLen=Infinity;if(last){maxLen=Math.min(maxLen,Math.hypot(cur[0]-last[0],cur[1]-last[1]));}if(next){maxLen=Math.min(maxLen,Math.hypot(next[0]-cur[0],next[1]-cur[1]));}var len=Math.max(halfThick,Math.min(miterLen,maxLen));Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp,cur,miter,len*flip);addPoint(contours,tmp,-flip);if(next){Object(_utils__WEBPACK_IMPORTED_MODULE_3__["normal"])(tmp,lineB);Object(_utils__WEBPACK_IMPORTED_MODULE_3__["copy"])(this._normal,tmp);// store normal for next round
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp,cur,tmp,-halfThick*flip);if(joinRound){var pEnd=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(tmp);var pStart=flip>0?contours.left[contours.left.length-1]:contours.right[contours.right.length-1];var o=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(cur);var p1=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])(),pStart,o);var p2=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])(),pEnd,o);var delta=Math.PI/this.roundSegments;for(var i=0;i<this.roundSegments;i++){Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rotate"])(p1,p1,[0,0],flip*delta);if(Math.sign(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cross"])(tmp,p1,p2)[2])!==flip){break;}else {Object(_utils__WEBPACK_IMPORTED_MODULE_3__["add"])(tmp,p1,o);}addPoint(contours,tmp,flip);}addPoint(contours,pEnd,flip);}else {addPoint(contours,tmp,flip);}}}else {extrusions(contours,cur,miter,miterLen);Object(_utils__WEBPACK_IMPORTED_MODULE_3__["copy"])(this._normal,miter);}}}}]);return Stroke;}();function addPoint(contours,point,flip){if(flip>0){contours.left.push(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(point));}else {contours.right.push(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(point));}}function extrusions(contours,point,normal,scale){var flip=arguments.length>4&&arguments[4]!==undefined?arguments[4]:-1;// next two points to end our segment
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp,point,normal,-scale);addPoint(contours,tmp,-flip);Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp,point,normal,scale);addPoint(contours,tmp,flip);}function capRound(_ref2,roundSegments){var left=_ref2.left,right=_ref2.right;var t=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();var normal=Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();var pStart=left[0];var pEnd=right[0];var center=[0.5*(pStart[0]+pEnd[0]),0.5*(pStart[1]+pEnd[1])];Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(normal,pStart,center);for(var i=1;i<=roundSegments;i++){var rad=-1*Math.PI*i/roundSegments;Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rotate"])(t,normal,[0,0],rad);Object(_utils__WEBPACK_IMPORTED_MODULE_3__["add"])(tmp,center,t);left.unshift(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(tmp));}pStart=right[right.length-1];pEnd=left[left.length-1];center=[0.5*(pStart[0]+pEnd[0]),0.5*(pStart[1]+pEnd[1])];Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(normal,pStart,center);for(var _i=1;_i<=roundSegments;_i++){var _rad=-1*Math.PI*_i/roundSegments;Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rotate"])(t,normal,[0,0],_rad);Object(_utils__WEBPACK_IMPORTED_MODULE_3__["add"])(tmp,center,t);right.push(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(tmp));}}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"isUnitTransform",function(){return isUnitTransform;});__webpack_require__(1).glMatrix.setMatrixArrayType(Array);function isUnitTransform(m){return m[0]===1&&m[1]===0&&m[2]===0&&m[3]===1&&m[4]===0&&m[5]===0;}/***/},function(module,exports,__webpack_require__){__webpack_require__(1).glMatrix.setMatrixArrayType(Array);// https://github.com/mattdesl/triangulate-contours
  /* eslint-disable */var Tess2=__webpack_require__(80);var xtend=__webpack_require__(81);module.exports=function(contours,opt){opt=opt||{};contours=contours.filter(function(c){return c.length>2;});if(contours.length===0){return {positions:[],cells:[]};}if(typeof opt.vertexSize!=='number')opt.vertexSize=contours[0][0].length;//flatten for tess2.js
  contours=contours.map(function(c){return c.reduce(function(a,b){return a.concat(b);});});var windingRule=opt.rule==='evenodd'?Tess2.WINDING_ODD:Tess2.WINDING_NONZERO;// Tesselate
  var res=Tess2.tesselate(xtend({contours:contours,windingRule:windingRule,elementType:Tess2.POLYGONS,polySize:3,vertexSize:2},opt));var positions=[];for(var i=0;i<res.vertices.length;i+=opt.vertexSize){var pos=res.vertices.slice(i,i+opt.vertexSize);positions.push(pos);}var cells=[];for(i=0;i<res.elements.length;i+=3){var a=res.elements[i],b=res.elements[i+1],c=res.elements[i+2];cells.push([a,b,c]);}//return a simplicial complex
  return {positions:positions,cells:cells};};/***/},function(module,exports,__webpack_require__){/* eslint-disabled */ /*
  ** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
  ** Copyright (C) [dates of first publication] Silicon Graphics, Inc.
  ** All Rights Reserved.
  **
  ** Permission is hereby granted, free of charge, to any person obtaining a copy
  ** of this software and associated documentation files (the "Software"), to deal
  ** in the Software without restriction, including without limitation the rights
  ** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  ** of the Software, and to permit persons to whom the Software is furnished to do so,
  ** subject to the following conditions:
  ** 
  ** The above copyright notice including the dates of first publication and either this
  ** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
  ** included in all copies or substantial portions of the Software. 
  **
  ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  ** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  ** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
  ** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
  ** OR OTHER DEALINGS IN THE SOFTWARE.
  ** 
  ** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
  ** be used in advertising or otherwise to promote the sale, use or other dealings in
  ** this Software without prior written authorization from Silicon Graphics, Inc.
  */ /*
  ** Author: Mikko Mononen, Aug 2013.
  ** The code is based on GLU libtess by Eric Veach, July 1994
  */ /* Public API */__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var Tess2={};var Geom={};module.exports=Tess2;Tess2.WINDING_ODD=0;Tess2.WINDING_NONZERO=1;Tess2.WINDING_POSITIVE=2;Tess2.WINDING_NEGATIVE=3;Tess2.WINDING_ABS_GEQ_TWO=4;Tess2.POLYGONS=0;Tess2.CONNECTED_POLYGONS=1;Tess2.BOUNDARY_CONTOURS=2;Tess2.tesselate=function(opts){var debug=opts.debug||false;var tess=new Tesselator();for(var i=0;i<opts.contours.length;i++){tess.addContour(opts.vertexSize||2,opts.contours[i]);}tess.tesselate(opts.windingRule||Tess2.WINDING_ODD,opts.elementType||Tess2.POLYGONS,opts.polySize||3,opts.vertexSize||2,opts.normal||[0,0,1]);return {vertices:tess.vertices,vertexIndices:tess.vertexIndices,vertexCount:tess.vertexCount,elements:tess.elements,elementCount:tess.elementCount,mesh:debug?tess.mesh:undefined};};/* Internal */var assert=function assert(cond){if(!cond){throw "Assertion Failed!";}};/* The mesh structure is similar in spirit, notation, and operations
  * to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
  * for the manipulation of general subdivisions and the computation of
  * Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
  * For a simplified description, see the course notes for CS348a,
  * "Mathematical Foundations of Computer Graphics", available at the
  * Stanford bookstore (and taught during the fall quarter).
  * The implementation also borrows a tiny subset of the graph-based approach
  * use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
  * to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
  *
  * The fundamental data structure is the "half-edge".  Two half-edges
  * go together to make an edge, but they point in opposite directions.
  * Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
  * its origin vertex (Org), the face on its left side (Lface), and the
  * adjacent half-edges in the CCW direction around the origin vertex
  * (Onext) and around the left face (Lnext).  There is also a "next"
  * pointer for the global edge list (see below).
  *
  * The notation used for mesh navigation:
  *  Sym   = the mate of a half-edge (same edge, but opposite direction)
  *  Onext = edge CCW around origin vertex (keep same origin)
  *  Dnext = edge CCW around destination vertex (keep same dest)
  *  Lnext = edge CCW around left face (dest becomes new origin)
  *  Rnext = edge CCW around right face (origin becomes new dest)
  *
  * "prev" means to substitute CW for CCW in the definitions above.
  *
  * The mesh keeps global lists of all vertices, faces, and edges,
  * stored as doubly-linked circular lists with a dummy header node.
  * The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
  *
  * The circular edge list is special; since half-edges always occur
  * in pairs (e and e->Sym), each half-edge stores a pointer in only
  * one direction.  Starting at eHead and following the e->next pointers
  * will visit each *edge* once (ie. e or e->Sym, but not both).
  * e->Sym stores a pointer in the opposite direction, thus it is
  * always true that e->Sym->next->Sym->next == e.
  *
  * Each vertex has a pointer to next and previous vertices in the
  * circular list, and a pointer to a half-edge with this vertex as
  * the origin (NULL if this is the dummy header).  There is also a
  * field "data" for client data.
  *
  * Each face has a pointer to the next and previous faces in the
  * circular list, and a pointer to a half-edge with this face as
  * the left face (NULL if this is the dummy header).  There is also
  * a field "data" for client data.
  *
  * Note that what we call a "face" is really a loop; faces may consist
  * of more than one loop (ie. not simply connected), but there is no
  * record of this in the data structure.  The mesh may consist of
  * several disconnected regions, so it may not be possible to visit
  * the entire mesh by starting at a half-edge and traversing the edge
  * structure.
  *
  * The mesh does NOT support isolated vertices; a vertex is deleted along
  * with its last edge.  Similarly when two faces are merged, one of the
  * faces is deleted (see tessMeshDelete below).  For mesh operations,
  * all face (loop) and vertex pointers must not be NULL.  However, once
  * mesh manipulation is finished, TESSmeshZapFace can be used to delete
  * faces of the mesh, one at a time.  All external faces can be "zapped"
  * before the mesh is returned to the client; then a NULL face indicates
  * a region which is not part of the output polygon.
  */function TESSvertex(){this.next=null;/* next vertex (never NULL) */this.prev=null;/* previous vertex (never NULL) */this.anEdge=null;/* a half-edge with this origin */ /* Internal data (keep hidden) */this.coords=[0,0,0];/* vertex location in 3D */this.s=0.0;this.t=0.0;/* projection onto the sweep plane */this.pqHandle=0;/* to allow deletion from priority queue */this.n=0;/* to allow identify unique vertices */this.idx=0;/* to allow map result to original verts */}function TESSface(){this.next=null;/* next face (never NULL) */this.prev=null;/* previous face (never NULL) */this.anEdge=null;/* a half edge with this left face */ /* Internal data (keep hidden) */this.trail=null;/* "stack" for conversion to strips */this.n=0;/* to allow identiy unique faces */this.marked=false;/* flag for conversion to strips */this.inside=false;/* this face is in the polygon interior */}function TESShalfEdge(side){this.next=null;/* doubly-linked list (prev==Sym->next) */this.Sym=null;/* same edge, opposite direction */this.Onext=null;/* next edge CCW around origin */this.Lnext=null;/* next edge CCW around left face */this.Org=null;/* origin vertex (Overtex too long) */this.Lface=null;/* left face */ /* Internal data (keep hidden) */this.activeRegion=null;/* a region with this upper edge (sweep.c) */this.winding=0;/* change in winding number when crossing
    from the right face to the left face */this.side=side;}TESShalfEdge.prototype={get Rface(){return this.Sym.Lface;},set Rface(v){this.Sym.Lface=v;},get Dst(){return this.Sym.Org;},set Dst(v){this.Sym.Org=v;},get Oprev(){return this.Sym.Lnext;},set Oprev(v){this.Sym.Lnext=v;},get Lprev(){return this.Onext.Sym;},set Lprev(v){this.Onext.Sym=v;},get Dprev(){return this.Lnext.Sym;},set Dprev(v){this.Lnext.Sym=v;},get Rprev(){return this.Sym.Onext;},set Rprev(v){this.Sym.Onext=v;},get Dnext(){return(/*this.Rprev*/this.Sym.Onext.Sym);},/* 3 pointers */set Dnext(v){/*this.Rprev*/this.Sym.Onext.Sym=v;},/* 3 pointers */get Rnext(){return(/*this.Oprev*/this.Sym.Lnext.Sym);},/* 3 pointers */set Rnext(v){/*this.Oprev*/this.Sym.Lnext.Sym=v;}/* 3 pointers */};function TESSmesh(){var v=new TESSvertex();var f=new TESSface();var e=new TESShalfEdge(0);var eSym=new TESShalfEdge(1);v.next=v.prev=v;v.anEdge=null;f.next=f.prev=f;f.anEdge=null;f.trail=null;f.marked=false;f.inside=false;e.next=e;e.Sym=eSym;e.Onext=null;e.Lnext=null;e.Org=null;e.Lface=null;e.winding=0;e.activeRegion=null;eSym.next=eSym;eSym.Sym=e;eSym.Onext=null;eSym.Lnext=null;eSym.Org=null;eSym.Lface=null;eSym.winding=0;eSym.activeRegion=null;this.vHead=v;/* dummy header for vertex list */this.fHead=f;/* dummy header for face list */this.eHead=e;/* dummy header for edge list */this.eHeadSym=eSym;/* and its symmetric counterpart */}/* The mesh operations below have three motivations: completeness,
  * convenience, and efficiency.  The basic mesh operations are MakeEdge,
  * Splice, and Delete.  All the other edge operations can be implemented
  * in terms of these.  The other operations are provided for convenience
  * and/or efficiency.
  *
  * When a face is split or a vertex is added, they are inserted into the
  * global list *before* the existing vertex or face (ie. e->Org or e->Lface).
  * This makes it easier to process all vertices or faces in the global lists
  * without worrying about processing the same data twice.  As a convenience,
  * when a face is split, the "inside" flag is copied from the old face.
  * Other internal data (v->data, v->activeRegion, f->data, f->marked,
  * f->trail, e->winding) is set to zero.
  *
  * ********************** Basic Edge Operations **************************
  *
  * tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
  * The loop (face) consists of the two new half-edges.
  *
  * tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
  * mesh connectivity and topology.  It changes the mesh so that
  *  eOrg->Onext <- OLD( eDst->Onext )
  *  eDst->Onext <- OLD( eOrg->Onext )
  * where OLD(...) means the value before the meshSplice operation.
  *
  * This can have two effects on the vertex structure:
  *  - if eOrg->Org != eDst->Org, the two vertices are merged together
  *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
  * In both cases, eDst->Org is changed and eOrg->Org is untouched.
  *
  * Similarly (and independently) for the face structure,
  *  - if eOrg->Lface == eDst->Lface, one loop is split into two
  *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
  * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
  *
  * tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
  * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
  * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
  * the newly created loop will contain eDel->Dst.  If the deletion of eDel
  * would create isolated vertices, those are deleted as well.
  *
  * ********************** Other Edge Operations **************************
  *
  * tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
  * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
  * eOrg and eNew will have the same left face.
  *
  * tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
  * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
  * eOrg and eNew will have the same left face.
  *
  * tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
  * to eDst->Org, and returns the corresponding half-edge eNew.
  * If eOrg->Lface == eDst->Lface, this splits one loop into two,
  * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
  * loops are merged into one, and the loop eDst->Lface is destroyed.
  *
  * ************************ Other Operations *****************************
  *
  * tessMeshNewMesh() creates a new mesh with no edges, no vertices,
  * and no loops (what we usually call a "face").
  *
  * tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in
  * both meshes, and returns the new mesh (the old meshes are destroyed).
  *
  * tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.
  *
  * tessMeshZapFace( fZap ) destroys a face and removes it from the
  * global face list.  All edges of fZap will have a NULL pointer as their
  * left face.  Any edges which also have a NULL pointer as their right face
  * are deleted entirely (along with any isolated vertices this produces).
  * An entire mesh can be deleted by zapping its faces, one at a time,
  * in any order.  Zapped faces cannot be used in further mesh operations!
  *
  * tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
  */TESSmesh.prototype={/* MakeEdge creates a new pair of half-edges which form their own loop.
    * No vertex or face structures are allocated, but these must be assigned
    * before the current edge operation is completed.
    */ //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
  makeEdge_:function makeEdge_(eNext){var e=new TESShalfEdge(0);var eSym=new TESShalfEdge(1);/* Make sure eNext points to the first edge of the edge pair */if(eNext.Sym.side<eNext.side){eNext=eNext.Sym;}/* Insert in circular doubly-linked list before eNext.
      * Note that the prev pointer is stored in Sym->next.
      */var ePrev=eNext.Sym.next;eSym.next=ePrev;ePrev.Sym.next=e;e.next=eNext;eNext.Sym.next=eSym;e.Sym=eSym;e.Onext=e;e.Lnext=eSym;e.Org=null;e.Lface=null;e.winding=0;e.activeRegion=null;eSym.Sym=e;eSym.Onext=eSym;eSym.Lnext=e;eSym.Org=null;eSym.Lface=null;eSym.winding=0;eSym.activeRegion=null;return e;},/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
    * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
    * a->Onext and b->Onext are exchanged.  This can have various effects
    * depending on whether a and b belong to different face or vertex rings.
    * For more explanation see tessMeshSplice() below.
    */ // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
  splice_:function splice_(a,b){var aOnext=a.Onext;var bOnext=b.Onext;aOnext.Sym.Lnext=b;bOnext.Sym.Lnext=a;a.Onext=bOnext;b.Onext=aOnext;},/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
    * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
    * a place to insert the new vertex in the global vertex list.  We insert
    * the new vertex *before* vNext so that algorithms which walk the vertex
    * list will not see the newly created vertices.
    */ //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
  makeVertex_:function makeVertex_(newVertex,eOrig,vNext){var vNew=newVertex;assert(vNew!==null);/* insert in circular doubly-linked list before vNext */var vPrev=vNext.prev;vNew.prev=vPrev;vPrev.next=vNew;vNew.next=vNext;vNext.prev=vNew;vNew.anEdge=eOrig;/* leave coords, s, t undefined */ /* fix other edges on this vertex loop */var e=eOrig;do{e.Org=vNew;e=e.Onext;}while(e!==eOrig);},/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
    * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
    * a place to insert the new face in the global face list.  We insert
    * the new face *before* fNext so that algorithms which walk the face
    * list will not see the newly created faces.
    */ // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
  makeFace_:function makeFace_(newFace,eOrig,fNext){var fNew=newFace;assert(fNew!==null);/* insert in circular doubly-linked list before fNext */var fPrev=fNext.prev;fNew.prev=fPrev;fPrev.next=fNew;fNew.next=fNext;fNext.prev=fNew;fNew.anEdge=eOrig;fNew.trail=null;fNew.marked=false;/* The new face is marked "inside" if the old one was.  This is a
      * convenience for the common case where a face has been split in two.
      */fNew.inside=fNext.inside;/* fix other edges on this face loop */var e=eOrig;do{e.Lface=fNew;e=e.Lnext;}while(e!==eOrig);},/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
    * and removes from the global edge list.
    */ //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
  killEdge_:function killEdge_(eDel){/* Half-edges are allocated in pairs, see EdgePair above */if(eDel.Sym.side<eDel.side){eDel=eDel.Sym;}/* delete from circular doubly-linked list */var eNext=eDel.next;var ePrev=eDel.Sym.next;eNext.Sym.next=ePrev;ePrev.Sym.next=eNext;},/* KillVertex( vDel ) destroys a vertex and removes it from the global
    * vertex list.  It updates the vertex loop to point to a given new vertex.
    */ //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
  killVertex_:function killVertex_(vDel,newOrg){var eStart=vDel.anEdge;/* change the origin of all affected edges */var e=eStart;do{e.Org=newOrg;e=e.Onext;}while(e!==eStart);/* delete from circular doubly-linked list */var vPrev=vDel.prev;var vNext=vDel.next;vNext.prev=vPrev;vPrev.next=vNext;},/* KillFace( fDel ) destroys a face and removes it from the global face
    * list.  It updates the face loop to point to a given new face.
    */ //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
  killFace_:function killFace_(fDel,newLface){var eStart=fDel.anEdge;/* change the left face of all affected edges */var e=eStart;do{e.Lface=newLface;e=e.Lnext;}while(e!==eStart);/* delete from circular doubly-linked list */var fPrev=fDel.prev;var fNext=fDel.next;fNext.prev=fPrev;fPrev.next=fNext;},/****************** Basic Edge Operations **********************/ /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
    * The loop consists of the two new half-edges.
    */ //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
  makeEdge:function makeEdge(){var newVertex1=new TESSvertex();var newVertex2=new TESSvertex();var newFace=new TESSface();var e=this.makeEdge_(this.eHead);this.makeVertex_(newVertex1,e,this.vHead);this.makeVertex_(newVertex2,e.Sym,this.vHead);this.makeFace_(newFace,e,this.fHead);return e;},/* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
    * mesh connectivity and topology.  It changes the mesh so that
    *	eOrg->Onext <- OLD( eDst->Onext )
    *	eDst->Onext <- OLD( eOrg->Onext )
    * where OLD(...) means the value before the meshSplice operation.
    *
    * This can have two effects on the vertex structure:
    *  - if eOrg->Org != eDst->Org, the two vertices are merged together
    *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
    * In both cases, eDst->Org is changed and eOrg->Org is untouched.
    *
    * Similarly (and independently) for the face structure,
    *  - if eOrg->Lface == eDst->Lface, one loop is split into two
    *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
    * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
    *
    * Some special cases:
    * If eDst == eOrg, the operation has no effect.
    * If eDst == eOrg->Lnext, the new face will have a single edge.
    * If eDst == eOrg->Lprev, the old face will have a single edge.
    * If eDst == eOrg->Onext, the new vertex will have a single edge.
    * If eDst == eOrg->Oprev, the old vertex will have a single edge.
    */ //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
  splice:function splice(eOrg,eDst){var joiningLoops=false;var joiningVertices=false;if(eOrg===eDst)return;if(eDst.Org!==eOrg.Org){/* We are merging two disjoint vertices -- destroy eDst->Org */joiningVertices=true;this.killVertex_(eDst.Org,eOrg.Org);}if(eDst.Lface!==eOrg.Lface){/* We are connecting two disjoint loops -- destroy eDst->Lface */joiningLoops=true;this.killFace_(eDst.Lface,eOrg.Lface);}/* Change the edge structure */this.splice_(eDst,eOrg);if(!joiningVertices){var newVertex=new TESSvertex();/* We split one vertex into two -- the new vertex is eDst->Org.
        * Make sure the old vertex points to a valid half-edge.
        */this.makeVertex_(newVertex,eDst,eOrg.Org);eOrg.Org.anEdge=eOrg;}if(!joiningLoops){var newFace=new TESSface();/* We split one loop into two -- the new loop is eDst->Lface.
        * Make sure the old face points to a valid half-edge.
        */this.makeFace_(newFace,eDst,eOrg.Lface);eOrg.Lface.anEdge=eOrg;}},/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
    * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
    * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
    * the newly created loop will contain eDel->Dst.  If the deletion of eDel
    * would create isolated vertices, those are deleted as well.
    *
    * This function could be implemented as two calls to tessMeshSplice
    * plus a few calls to memFree, but this would allocate and delete
    * unnecessary vertices and faces.
    */ //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
  delete:function _delete(eDel){var eDelSym=eDel.Sym;var joiningLoops=false;/* First step: disconnect the origin vertex eDel->Org.  We make all
      * changes to get a consistent mesh in this "intermediate" state.
      */if(eDel.Lface!==eDel.Rface){/* We are joining two loops into one -- remove the left face */joiningLoops=true;this.killFace_(eDel.Lface,eDel.Rface);}if(eDel.Onext===eDel){this.killVertex_(eDel.Org,null);}else {/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */eDel.Rface.anEdge=eDel.Oprev;eDel.Org.anEdge=eDel.Onext;this.splice_(eDel,eDel.Oprev);if(!joiningLoops){var newFace=new TESSface();/* We are splitting one loop into two -- create a new loop for eDel. */this.makeFace_(newFace,eDel,eDel.Lface);}}/* Claim: the mesh is now in a consistent state, except that eDel->Org
      * may have been deleted.  Now we disconnect eDel->Dst.
      */if(eDelSym.Onext===eDelSym){this.killVertex_(eDelSym.Org,null);this.killFace_(eDelSym.Lface,null);}else {/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */eDel.Lface.anEdge=eDelSym.Oprev;eDelSym.Org.anEdge=eDelSym.Onext;this.splice_(eDelSym,eDelSym.Oprev);}/* Any isolated vertices or faces have already been freed. */this.killEdge_(eDel);},/******************** Other Edge Operations **********************/ /* All these routines can be implemented with the basic edge
    * operations above.  They are provided for convenience and efficiency.
    */ /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
    * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
    * eOrg and eNew will have the same left face.
    */ // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
  addEdgeVertex:function addEdgeVertex(eOrg){var eNew=this.makeEdge_(eOrg);var eNewSym=eNew.Sym;/* Connect the new edge appropriately */this.splice_(eNew,eOrg.Lnext);/* Set the vertex and face information */eNew.Org=eOrg.Dst;var newVertex=new TESSvertex();this.makeVertex_(newVertex,eNewSym,eNew.Org);eNew.Lface=eNewSym.Lface=eOrg.Lface;return eNew;},/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
    * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
    * eOrg and eNew will have the same left face.
    */ // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
  splitEdge:function splitEdge(eOrg,eDst){var tempHalfEdge=this.addEdgeVertex(eOrg);var eNew=tempHalfEdge.Sym;/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */this.splice_(eOrg.Sym,eOrg.Sym.Oprev);this.splice_(eOrg.Sym,eNew);/* Set the vertex and face information */eOrg.Dst=eNew.Org;eNew.Dst.anEdge=eNew.Sym;/* may have pointed to eOrg->Sym */eNew.Rface=eOrg.Rface;eNew.winding=eOrg.winding;/* copy old winding information */eNew.Sym.winding=eOrg.Sym.winding;return eNew;},/* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
    * to eDst->Org, and returns the corresponding half-edge eNew.
    * If eOrg->Lface == eDst->Lface, this splits one loop into two,
    * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
    * loops are merged into one, and the loop eDst->Lface is destroyed.
    *
    * If (eOrg == eDst), the new face will have only two edges.
    * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
    * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
    */ // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
  connect:function connect(eOrg,eDst){var joiningLoops=false;var eNew=this.makeEdge_(eOrg);var eNewSym=eNew.Sym;if(eDst.Lface!==eOrg.Lface){/* We are connecting two disjoint loops -- destroy eDst->Lface */joiningLoops=true;this.killFace_(eDst.Lface,eOrg.Lface);}/* Connect the new edge appropriately */this.splice_(eNew,eOrg.Lnext);this.splice_(eNewSym,eDst);/* Set the vertex and face information */eNew.Org=eOrg.Dst;eNewSym.Org=eDst.Org;eNew.Lface=eNewSym.Lface=eOrg.Lface;/* Make sure the old face points to a valid half-edge */eOrg.Lface.anEdge=eNewSym;if(!joiningLoops){var newFace=new TESSface();/* We split one loop into two -- the new loop is eNew->Lface */this.makeFace_(newFace,eNew,eOrg.Lface);}return eNew;},/* tessMeshZapFace( fZap ) destroys a face and removes it from the
    * global face list.  All edges of fZap will have a NULL pointer as their
    * left face.  Any edges which also have a NULL pointer as their right face
    * are deleted entirely (along with any isolated vertices this produces).
    * An entire mesh can be deleted by zapping its faces, one at a time,
    * in any order.  Zapped faces cannot be used in further mesh operations!
    */zapFace:function zapFace(fZap){var eStart=fZap.anEdge;var e,eNext,eSym;var fPrev,fNext;/* walk around face, deleting edges whose right face is also NULL */eNext=eStart.Lnext;do{e=eNext;eNext=e.Lnext;e.Lface=null;if(e.Rface===null){/* delete the edge -- see TESSmeshDelete above */if(e.Onext===e){this.killVertex_(e.Org,null);}else {/* Make sure that e->Org points to a valid half-edge */e.Org.anEdge=e.Onext;this.splice_(e,e.Oprev);}eSym=e.Sym;if(eSym.Onext===eSym){this.killVertex_(eSym.Org,null);}else {/* Make sure that eSym->Org points to a valid half-edge */eSym.Org.anEdge=eSym.Onext;this.splice_(eSym,eSym.Oprev);}this.killEdge_(e);}}while(e!=eStart);/* delete from circular doubly-linked list */fPrev=fZap.prev;fNext=fZap.next;fNext.prev=fPrev;fPrev.next=fNext;},countFaceVerts_:function countFaceVerts_(f){var eCur=f.anEdge;var n=0;do{n++;eCur=eCur.Lnext;}while(eCur!==f.anEdge);return n;},//int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
  mergeConvexFaces:function mergeConvexFaces(maxVertsPerFace){var f;var eCur,eNext,eSym;var vStart;var curNv,symNv;for(f=this.fHead.next;f!==this.fHead;f=f.next){// Skip faces which are outside the result.
  if(!f.inside)continue;eCur=f.anEdge;vStart=eCur.Org;while(true){eNext=eCur.Lnext;eSym=eCur.Sym;// Try to merge if the neighbour face is valid.
  if(eSym&&eSym.Lface&&eSym.Lface.inside){// Try to merge the neighbour faces if the resulting polygons
  // does not exceed maximum number of vertices.
  curNv=this.countFaceVerts_(f);symNv=this.countFaceVerts_(eSym.Lface);if(curNv+symNv-2<=maxVertsPerFace){// Merge if the resulting poly is convex.
  if(Geom.vertCCW(eCur.Lprev.Org,eCur.Org,eSym.Lnext.Lnext.Org)&&Geom.vertCCW(eSym.Lprev.Org,eSym.Org,eCur.Lnext.Lnext.Org)){eNext=eSym.Lnext;this.delete(eSym);eCur=null;eSym=null;}}}if(eCur&&eCur.Lnext.Org===vStart)break;// Continue to next edge.
  eCur=eNext;}}return true;},/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
    */check:function check(){var fHead=this.fHead;var vHead=this.vHead;var eHead=this.eHead;var f,fPrev,v,vPrev,e,ePrev;fPrev=fHead;for(fPrev=fHead;(f=fPrev.next)!==fHead;fPrev=f){assert(f.prev===fPrev);e=f.anEdge;do{assert(e.Sym!==e);assert(e.Sym.Sym===e);assert(e.Lnext.Onext.Sym===e);assert(e.Onext.Sym.Lnext===e);assert(e.Lface===f);e=e.Lnext;}while(e!==f.anEdge);}assert(f.prev===fPrev&&f.anEdge===null);vPrev=vHead;for(vPrev=vHead;(v=vPrev.next)!==vHead;vPrev=v){assert(v.prev===vPrev);e=v.anEdge;do{assert(e.Sym!==e);assert(e.Sym.Sym===e);assert(e.Lnext.Onext.Sym===e);assert(e.Onext.Sym.Lnext===e);assert(e.Org===v);e=e.Onext;}while(e!==v.anEdge);}assert(v.prev===vPrev&&v.anEdge===null);ePrev=eHead;for(ePrev=eHead;(e=ePrev.next)!==eHead;ePrev=e){assert(e.Sym.next===ePrev.Sym);assert(e.Sym!==e);assert(e.Sym.Sym===e);assert(e.Org!==null);assert(e.Dst!==null);assert(e.Lnext.Onext.Sym===e);assert(e.Onext.Sym.Lnext===e);}assert(e.Sym.next===ePrev.Sym&&e.Sym===this.eHeadSym&&e.Sym.Sym===e&&e.Org===null&&e.Dst===null&&e.Lface===null&&e.Rface===null);}};Geom.vertEq=function(u,v){return u.s===v.s&&u.t===v.t;};/* Returns TRUE if u is lexicographically <= v. */Geom.vertLeq=function(u,v){return u.s<v.s||u.s===v.s&&u.t<=v.t;};/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */Geom.transLeq=function(u,v){return u.t<v.t||u.t===v.t&&u.s<=v.s;};Geom.edgeGoesLeft=function(e){return Geom.vertLeq(e.Dst,e.Org);};Geom.edgeGoesRight=function(e){return Geom.vertLeq(e.Org,e.Dst);};Geom.vertL1dist=function(u,v){return Math.abs(u.s-v.s)+Math.abs(u.t-v.t);};//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  Geom.edgeEval=function(u,v,w){/* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
    * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
    * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
    * If uw is vertical (and thus passes thru v), the result is zero.
    *
    * The calculation is extremely accurate and stable, even when v
    * is very close to u or w.  In particular if we set v->t = 0 and
    * let r be the negated result (this evaluates (uw)(v->s)), then
    * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
    */assert(Geom.vertLeq(u,v)&&Geom.vertLeq(v,w));var gapL=v.s-u.s;var gapR=w.s-v.s;if(gapL+gapR>0.0){if(gapL<gapR){return v.t-u.t+(u.t-w.t)*(gapL/(gapL+gapR));}else {return v.t-w.t+(w.t-u.t)*(gapR/(gapL+gapR));}}/* vertical line */return 0.0;};//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  Geom.edgeSign=function(u,v,w){/* Returns a number whose sign matches EdgeEval(u,v,w) but which
    * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
    * as v is above, on, or below the edge uw.
    */assert(Geom.vertLeq(u,v)&&Geom.vertLeq(v,w));var gapL=v.s-u.s;var gapR=w.s-v.s;if(gapL+gapR>0.0){return (v.t-w.t)*gapL+(v.t-u.t)*gapR;}/* vertical line */return 0.0;};/***********************************************************************
  * Define versions of EdgeSign, EdgeEval with s and t transposed.
  */ //TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  Geom.transEval=function(u,v,w){/* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
    * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
    * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
    * If uw is vertical (and thus passes thru v), the result is zero.
    *
    * The calculation is extremely accurate and stable, even when v
    * is very close to u or w.  In particular if we set v->s = 0 and
    * let r be the negated result (this evaluates (uw)(v->t)), then
    * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
    */assert(Geom.transLeq(u,v)&&Geom.transLeq(v,w));var gapL=v.t-u.t;var gapR=w.t-v.t;if(gapL+gapR>0.0){if(gapL<gapR){return v.s-u.s+(u.s-w.s)*(gapL/(gapL+gapR));}else {return v.s-w.s+(w.s-u.s)*(gapR/(gapL+gapR));}}/* vertical line */return 0.0;};//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  Geom.transSign=function(u,v,w){/* Returns a number whose sign matches TransEval(u,v,w) but which
    * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
    * as v is above, on, or below the edge uw.
    */assert(Geom.transLeq(u,v)&&Geom.transLeq(v,w));var gapL=v.t-u.t;var gapR=w.t-v.t;if(gapL+gapR>0.0){return (v.s-w.s)*gapL+(v.s-u.s)*gapR;}/* vertical line */return 0.0;};//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  Geom.vertCCW=function(u,v,w){/* For almost-degenerate situations, the results are not reliable.
    * Unless the floating-point arithmetic can be performed without
    * rounding errors, *any* implementation will give incorrect results
    * on some degenerate inputs, so the client must have some way to
    * handle this situation.
    */return u.s*(v.t-w.t)+v.s*(w.t-u.t)+w.s*(u.t-v.t)>=0.0;};/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
  * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
  * this in the rare case that one argument is slightly negative.
  * The implementation is extremely stable numerically.
  * In particular it guarantees that the result r satisfies
  * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
  * even when a and b differ greatly in magnitude.
  */Geom.interpolate=function(a,x,b,y){return a=a<0?0:a,b=b<0?0:b,a<=b?b===0?(x+y)/2:x+(y-x)*(a/(a+b)):y+(x-y)*(b/(a+b));};/*
  #ifndef FOR_TRITE_TEST_PROGRAM
  #define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
  #else

  // Claim: the ONLY property the sweep algorithm relies on is that
  // MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
  #include <stdlib.h>
  extern int RandomInterpolate;

  double Interpolate( double a, double x, double b, double y)
  {
    printf("*********************%d\n",RandomInterpolate);
    if( RandomInterpolate ) {
      a = 1.2 * drand48() - 0.1;
      a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
      b = 1.0 - a;
    }
    return RealInterpolate(a,x,b,y);
  }
  #endif*/Geom.intersect=function(o1,d1,o2,d2,v){/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
    * The computed point is guaranteed to lie in the intersection of the
    * bounding rectangles defined by each edge.
    */var z1,z2;var t;/* This is certainly not the most efficient way to find the intersection
    * of two line segments, but it is very numerically stable.
    *
    * Strategy: find the two middle vertices in the VertLeq ordering,
    * and interpolate the intersection s-value from these.  Then repeat
    * using the TransLeq ordering to find the intersection t-value.
    */if(!Geom.vertLeq(o1,d1)){t=o1;o1=d1;d1=t;}//swap( o1, d1 ); }
  if(!Geom.vertLeq(o2,d2)){t=o2;o2=d2;d2=t;}//swap( o2, d2 ); }
  if(!Geom.vertLeq(o1,o2)){t=o1;o1=o2;o2=t;t=d1;d1=d2;d2=t;}//swap( o1, o2 ); swap( d1, d2 ); }
  if(!Geom.vertLeq(o2,d1)){/* Technically, no intersection -- do our best */v.s=(o2.s+d1.s)/2;}else if(Geom.vertLeq(d1,d2)){/* Interpolate between o2 and d1 */z1=Geom.edgeEval(o1,o2,d1);z2=Geom.edgeEval(o2,d1,d2);if(z1+z2<0){z1=-z1;z2=-z2;}v.s=Geom.interpolate(z1,o2.s,z2,d1.s);}else {/* Interpolate between o2 and d2 */z1=Geom.edgeSign(o1,o2,d1);z2=-Geom.edgeSign(o1,d2,d1);if(z1+z2<0){z1=-z1;z2=-z2;}v.s=Geom.interpolate(z1,o2.s,z2,d2.s);}/* Now repeat the process for t */if(!Geom.transLeq(o1,d1)){t=o1;o1=d1;d1=t;}//swap( o1, d1 ); }
  if(!Geom.transLeq(o2,d2)){t=o2;o2=d2;d2=t;}//swap( o2, d2 ); }
  if(!Geom.transLeq(o1,o2)){t=o1;o1=o2;o2=t;t=d1;d1=d2;d2=t;}//swap( o1, o2 ); swap( d1, d2 ); }
  if(!Geom.transLeq(o2,d1)){/* Technically, no intersection -- do our best */v.t=(o2.t+d1.t)/2;}else if(Geom.transLeq(d1,d2)){/* Interpolate between o2 and d1 */z1=Geom.transEval(o1,o2,d1);z2=Geom.transEval(o2,d1,d2);if(z1+z2<0){z1=-z1;z2=-z2;}v.t=Geom.interpolate(z1,o2.t,z2,d1.t);}else {/* Interpolate between o2 and d2 */z1=Geom.transSign(o1,o2,d1);z2=-Geom.transSign(o1,d2,d1);if(z1+z2<0){z1=-z1;z2=-z2;}v.t=Geom.interpolate(z1,o2.t,z2,d2.t);}};function DictNode(){this.key=null;this.next=null;this.prev=null;}function Dict(frame,leq){this.head=new DictNode();this.head.next=this.head;this.head.prev=this.head;this.frame=frame;this.leq=leq;}Dict.prototype={min:function min(){return this.head.next;},max:function max(){return this.head.prev;},insert:function insert(k){return this.insertBefore(this.head,k);},search:function search(key){/* Search returns the node with the smallest key greater than or equal
      * to the given key.  If there is no such key, returns a node whose
      * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
      */var node=this.head;do{node=node.next;}while(node.key!==null&&!this.leq(this.frame,key,node.key));return node;},insertBefore:function insertBefore(node,key){do{node=node.prev;}while(node.key!==null&&!this.leq(this.frame,node.key,key));var newNode=new DictNode();newNode.key=key;newNode.next=node.next;node.next.prev=newNode;newNode.prev=node;node.next=newNode;return newNode;},delete:function _delete(node){node.next.prev=node.prev;node.prev.next=node.next;}};function PQnode(){this.handle=null;}function PQhandleElem(){this.key=null;this.node=null;}function PriorityQ(size,leq){this.size=0;this.max=size;this.nodes=[];this.nodes.length=size+1;var i;for(i=0;i<this.nodes.length;i++){this.nodes[i]=new PQnode();}this.handles=[];this.handles.length=size+1;for(i=0;i<this.handles.length;i++){this.handles[i]=new PQhandleElem();}this.initialized=false;this.freeList=0;this.leq=leq;this.nodes[1].handle=1;/* so that Minimum() returns NULL */this.handles[1].key=null;}PriorityQ.prototype={floatDown_:function floatDown_(curr){var n=this.nodes;var h=this.handles;var hCurr,hChild;var child;hCurr=n[curr].handle;for(;;){child=curr<<1;if(child<this.size&&this.leq(h[n[child+1].handle].key,h[n[child].handle].key)){++child;}assert(child<=this.max);hChild=n[child].handle;if(child>this.size||this.leq(h[hCurr].key,h[hChild].key)){n[curr].handle=hCurr;h[hCurr].node=curr;break;}n[curr].handle=hChild;h[hChild].node=curr;curr=child;}},floatUp_:function floatUp_(curr){var n=this.nodes;var h=this.handles;var hCurr,hParent;var parent;hCurr=n[curr].handle;for(;;){parent=curr>>1;hParent=n[parent].handle;if(parent===0||this.leq(h[hParent].key,h[hCurr].key)){n[curr].handle=hCurr;h[hCurr].node=curr;break;}n[curr].handle=hParent;h[hParent].node=curr;curr=parent;}},init:function init(){/* This method of building a heap is O(n), rather than O(n lg n). */for(var i=this.size;i>=1;--i){this.floatDown_(i);}this.initialized=true;},min:function min(){return this.handles[this.nodes[1].handle].key;},/* really pqHeapInsert */ /* returns INV_HANDLE iff out of memory */ //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
  insert:function insert(keyNew){var curr;var free;curr=++this.size;if(curr*2>this.max){this.max*=2;var i;var s;s=this.nodes.length;this.nodes.length=this.max+1;for(i=s;i<this.nodes.length;i++){this.nodes[i]=new PQnode();}s=this.handles.length;this.handles.length=this.max+1;for(i=s;i<this.handles.length;i++){this.handles[i]=new PQhandleElem();}}if(this.freeList===0){free=curr;}else {free=this.freeList;this.freeList=this.handles[free].node;}this.nodes[curr].handle=free;this.handles[free].node=curr;this.handles[free].key=keyNew;if(this.initialized){this.floatUp_(curr);}return free;},//PQkey pqHeapExtractMin( PriorityQHeap *pq )
  extractMin:function extractMin(){var n=this.nodes;var h=this.handles;var hMin=n[1].handle;var min=h[hMin].key;if(this.size>0){n[1].handle=n[this.size].handle;h[n[1].handle].node=1;h[hMin].key=null;h[hMin].node=this.freeList;this.freeList=hMin;--this.size;if(this.size>0){this.floatDown_(1);}}return min;},delete:function _delete(hCurr){var n=this.nodes;var h=this.handles;var curr;assert(hCurr>=1&&hCurr<=this.max&&h[hCurr].key!==null);curr=h[hCurr].node;n[curr].handle=n[this.size].handle;h[n[curr].handle].node=curr;--this.size;if(curr<=this.size){if(curr<=1||this.leq(h[n[curr>>1].handle].key,h[n[curr].handle].key)){this.floatDown_(curr);}else {this.floatUp_(curr);}}h[hCurr].key=null;h[hCurr].node=this.freeList;this.freeList=hCurr;}};/* For each pair of adjacent edges crossing the sweep line, there is
  * an ActiveRegion to represent the region between them.  The active
  * regions are kept in sorted order in a dynamic dictionary.  As the
  * sweep line crosses each vertex, we update the affected regions.
  */function ActiveRegion(){this.eUp=null;/* upper edge, directed right to left */this.nodeUp=null;/* dictionary node corresponding to eUp */this.windingNumber=0;/* used to determine which regions are
    * inside the polygon */this.inside=false;/* is this region inside the polygon? */this.sentinel=false;/* marks fake edges at t = +/-infinity */this.dirty=false;/* marks regions where the upper or lower
    * edge has changed, but we haven't checked
    * whether they intersect yet */this.fixUpperEdge=false;/* marks temporary edges introduced when
    * we process a "right vertex" (one without
    * any edges leaving to the right) */}var Sweep={};Sweep.regionBelow=function(r){return r.nodeUp.prev.key;};Sweep.regionAbove=function(r){return r.nodeUp.next.key;};Sweep.debugEvent=function(tess){// empty
  };/*
  * Invariants for the Edge Dictionary.
  * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
  *   at any valid location of the sweep event
  * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
  *   share a common endpoint
  * - for each e, e->Dst has been processed, but not e->Org
  * - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
  *   where "event" is the current sweep line event.
  * - no edge e has zero length
  *
  * Invariants for the Mesh (the processed portion).
  * - the portion of the mesh left of the sweep line is a planar graph,
  *   ie. there is *some* way to embed it in the plane
  * - no processed edge has zero length
  * - no two processed vertices have identical coordinates
  * - each "inside" region is monotone, ie. can be broken into two chains
  *   of monotonically increasing vertices according to VertLeq(v1,v2)
  *   - a non-invariant: these chains may intersect (very slightly)
  *
  * Invariants for the Sweep.
  * - if none of the edges incident to the event vertex have an activeRegion
  *   (ie. none of these edges are in the edge dictionary), then the vertex
  *   has only right-going edges.
  * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
  *   by ConnectRightVertex), then it is the only right-going edge from
  *   its associated vertex.  (This says that these edges exist only
  *   when it is necessary.)
  */ /* When we merge two edges into one, we need to compute the combined
  * winding of the new edge.
  */Sweep.addWinding=function(eDst,eSrc){eDst.winding+=eSrc.winding;eDst.Sym.winding+=eSrc.Sym.winding;};//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )
  Sweep.edgeLeq=function(tess,reg1,reg2){/*
    * Both edges must be directed from right to left (this is the canonical
    * direction for the upper edge of each region).
    *
    * The strategy is to evaluate a "t" value for each edge at the
    * current sweep line position, given by tess->event.  The calculations
    * are designed to be very stable, but of course they are not perfect.
    *
    * Special case: if both edge destinations are at the sweep event,
    * we sort the edges by slope (they would otherwise compare equally).
    */var ev=tess.event;var t1,t2;var e1=reg1.eUp;var e2=reg2.eUp;if(e1.Dst===ev){if(e2.Dst===ev){/* Two edges right of the sweep line which meet at the sweep event.
        * Sort them by slope.
        */if(Geom.vertLeq(e1.Org,e2.Org)){return Geom.edgeSign(e2.Dst,e1.Org,e2.Org)<=0;}return Geom.edgeSign(e1.Dst,e2.Org,e1.Org)>=0;}return Geom.edgeSign(e2.Dst,ev,e2.Org)<=0;}if(e2.Dst===ev){return Geom.edgeSign(e1.Dst,ev,e1.Org)>=0;}/* General case - compute signed distance *from* e1, e2 to event */var t1=Geom.edgeEval(e1.Dst,ev,e1.Org);var t2=Geom.edgeEval(e2.Dst,ev,e2.Org);return t1>=t2;};//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )
  Sweep.deleteRegion=function(tess,reg){if(reg.fixUpperEdge){/* It was created with zero winding number, so it better be
      * deleted with zero winding number (ie. it better not get merged
      * with a real edge).
      */assert(reg.eUp.winding===0);}reg.eUp.activeRegion=null;tess.dict.delete(reg.nodeUp);};//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )
  Sweep.fixUpperEdge=function(tess,reg,newEdge){/*
    * Replace an upper edge which needs fixing (see ConnectRightVertex).
    */assert(reg.fixUpperEdge);tess.mesh.delete(reg.eUp);reg.fixUpperEdge=false;reg.eUp=newEdge;newEdge.activeRegion=reg;};//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )
  Sweep.topLeftRegion=function(tess,reg){var org=reg.eUp.Org;var e;/* Find the region above the uppermost edge with the same origin */do{reg=Sweep.regionAbove(reg);}while(reg.eUp.Org===org);/* If the edge above was a temporary edge introduced by ConnectRightVertex,
    * now is the time to fix it.
    */if(reg.fixUpperEdge){e=tess.mesh.connect(Sweep.regionBelow(reg).eUp.Sym,reg.eUp.Lnext);if(e===null)return null;Sweep.fixUpperEdge(tess,reg,e);reg=Sweep.regionAbove(reg);}return reg;};//static ActiveRegion *TopRightRegion( ActiveRegion *reg )
  Sweep.topRightRegion=function(reg){var dst=reg.eUp.Dst;/* Find the region above the uppermost edge with the same destination */do{reg=Sweep.regionAbove(reg);}while(reg.eUp.Dst===dst);return reg;};//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )
  Sweep.addRegionBelow=function(tess,regAbove,eNewUp){/*
    * Add a new active region to the sweep line, *somewhere* below "regAbove"
    * (according to where the new edge belongs in the sweep-line dictionary).
    * The upper edge of the new region will be "eNewUp".
    * Winding number and "inside" flag are not updated.
    */var regNew=new ActiveRegion();regNew.eUp=eNewUp;regNew.nodeUp=tess.dict.insertBefore(regAbove.nodeUp,regNew);//	if (regNew->nodeUp == NULL) longjmp(tess->env,1);
  regNew.fixUpperEdge=false;regNew.sentinel=false;regNew.dirty=false;eNewUp.activeRegion=regNew;return regNew;};//static int IsWindingInside( TESStesselator *tess, int n )
  Sweep.isWindingInside=function(tess,n){switch(tess.windingRule){case Tess2.WINDING_ODD:return (n&1)!==0;case Tess2.WINDING_NONZERO:return n!==0;case Tess2.WINDING_POSITIVE:return n>0;case Tess2.WINDING_NEGATIVE:return n<0;case Tess2.WINDING_ABS_GEQ_TWO:return n>=2||n<=-2;}assert(false);return false;};//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )
  Sweep.computeWinding=function(tess,reg){reg.windingNumber=Sweep.regionAbove(reg).windingNumber+reg.eUp.winding;reg.inside=Sweep.isWindingInside(tess,reg.windingNumber);};//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )
  Sweep.finishRegion=function(tess,reg){/*
    * Delete a region from the sweep line.  This happens when the upper
    * and lower chains of a region meet (at a vertex on the sweep line).
    * The "inside" flag is copied to the appropriate mesh face (we could
    * not do this before -- since the structure of the mesh is always
    * changing, this face may not have even existed until now).
    */var e=reg.eUp;var f=e.Lface;f.inside=reg.inside;f.anEdge=e;/* optimization for tessMeshTessellateMonoRegion() */Sweep.deleteRegion(tess,reg);};//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )
  Sweep.finishLeftRegions=function(tess,regFirst,regLast){/*
    * We are given a vertex with one or more left-going edges.  All affected
    * edges should be in the edge dictionary.  Starting at regFirst->eUp,
    * we walk down deleting all regions where both edges have the same
    * origin vOrg.  At the same time we copy the "inside" flag from the
    * active region to the face, since at this point each face will belong
    * to at most one region (this was not necessarily true until this point
    * in the sweep).  The walk stops at the region above regLast; if regLast
    * is NULL we walk as far as possible.  At the same time we relink the
    * mesh if necessary, so that the ordering of edges around vOrg is the
    * same as in the dictionary.
    */var e,ePrev;var reg=null;var regPrev=regFirst;var ePrev=regFirst.eUp;while(regPrev!==regLast){regPrev.fixUpperEdge=false;/* placement was OK */reg=Sweep.regionBelow(regPrev);e=reg.eUp;if(e.Org!=ePrev.Org){if(!reg.fixUpperEdge){/* Remove the last left-going edge.  Even though there are no further
          * edges in the dictionary with this origin, there may be further
          * such edges in the mesh (if we are adding left edges to a vertex
          * that has already been processed).  Thus it is important to call
          * FinishRegion rather than just DeleteRegion.
          */Sweep.finishRegion(tess,regPrev);break;}/* If the edge below was a temporary edge introduced by
        * ConnectRightVertex, now is the time to fix it.
        */e=tess.mesh.connect(ePrev.Lprev,e.Sym);//			if (e == NULL) longjmp(tess->env,1);
  Sweep.fixUpperEdge(tess,reg,e);}/* Relink edges so that ePrev->Onext == e */if(ePrev.Onext!==e){tess.mesh.splice(e.Oprev,e);tess.mesh.splice(ePrev,e);}Sweep.finishRegion(tess,regPrev);/* may change reg->eUp */ePrev=reg.eUp;regPrev=reg;}return ePrev;};//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )
  Sweep.addRightEdges=function(tess,regUp,eFirst,eLast,eTopLeft,cleanUp){/*
    * Purpose: insert right-going edges into the edge dictionary, and update
    * winding numbers and mesh connectivity appropriately.  All right-going
    * edges share a common origin vOrg.  Edges are inserted CCW starting at
    * eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
    * left-going edges already processed, then eTopLeft must be the edge
    * such that an imaginary upward vertical segment from vOrg would be
    * contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
    * should be NULL.
    */var reg,regPrev;var e,ePrev;var firstTime=true;/* Insert the new right-going edges in the dictionary */e=eFirst;do{assert(Geom.vertLeq(e.Org,e.Dst));Sweep.addRegionBelow(tess,regUp,e.Sym);e=e.Onext;}while(e!==eLast);/* Walk *all* right-going edges from e->Org, in the dictionary order,
    * updating the winding numbers of each region, and re-linking the mesh
    * edges to match the dictionary ordering (if necessary).
    */if(eTopLeft===null){eTopLeft=Sweep.regionBelow(regUp).eUp.Rprev;}regPrev=regUp;ePrev=eTopLeft;for(;;){reg=Sweep.regionBelow(regPrev);e=reg.eUp.Sym;if(e.Org!==ePrev.Org)break;if(e.Onext!==ePrev){/* Unlink e from its current position, and relink below ePrev */tess.mesh.splice(e.Oprev,e);tess.mesh.splice(ePrev.Oprev,e);}/* Compute the winding number and "inside" flag for the new regions */reg.windingNumber=regPrev.windingNumber-e.winding;reg.inside=Sweep.isWindingInside(tess,reg.windingNumber);/* Check for two outgoing edges with same slope -- process these
      * before any intersection tests (see example in tessComputeInterior).
      */regPrev.dirty=true;if(!firstTime&&Sweep.checkForRightSplice(tess,regPrev)){Sweep.addWinding(e,ePrev);Sweep.deleteRegion(tess,regPrev);tess.mesh.delete(ePrev);}firstTime=false;regPrev=reg;ePrev=e;}regPrev.dirty=true;assert(regPrev.windingNumber-e.winding===reg.windingNumber);if(cleanUp){/* Check for intersections between newly adjacent edges. */Sweep.walkDirtyRegions(tess,regPrev);}};//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )
  Sweep.spliceMergeVertices=function(tess,e1,e2){/*
    * Two vertices with idential coordinates are combined into one.
    * e1->Org is kept, while e2->Org is discarded.
    */tess.mesh.splice(e1,e2);};//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )
  Sweep.vertexWeights=function(isect,org,dst){/*
    * Find some weights which describe how the intersection vertex is
    * a linear combination of "org" and "dest".  Each of the two edges
    * which generated "isect" is allocated 50% of the weight; each edge
    * splits the weight between its org and dst according to the
    * relative distance to "isect".
    */var t1=Geom.vertL1dist(org,isect);var t2=Geom.vertL1dist(dst,isect);var w0=0.5*t2/(t1+t2);var w1=0.5*t1/(t1+t2);isect.coords[0]+=w0*org.coords[0]+w1*dst.coords[0];isect.coords[1]+=w0*org.coords[1]+w1*dst.coords[1];isect.coords[2]+=w0*org.coords[2]+w1*dst.coords[2];};//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )
  Sweep.getIntersectData=function(tess,isect,orgUp,dstUp,orgLo,dstLo){/*
    * We've computed a new intersection point, now we need a "data" pointer
    * from the user so that we can refer to this new vertex in the
    * rendering callbacks.
    */isect.coords[0]=isect.coords[1]=isect.coords[2]=0;isect.idx=-1;Sweep.vertexWeights(isect,orgUp,dstUp);Sweep.vertexWeights(isect,orgLo,dstLo);};//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )
  Sweep.checkForRightSplice=function(tess,regUp){/*
    * Check the upper and lower edge of "regUp", to make sure that the
    * eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
    * origin is leftmost).
    *
    * The main purpose is to splice right-going edges with the same
    * dest vertex and nearly identical slopes (ie. we can't distinguish
    * the slopes numerically).  However the splicing can also help us
    * to recover from numerical errors.  For example, suppose at one
    * point we checked eUp and eLo, and decided that eUp->Org is barely
    * above eLo.  Then later, we split eLo into two edges (eg. from
    * a splice operation like this one).  This can change the result of
    * our test so that now eUp->Org is incident to eLo, or barely below it.
    * We must correct this condition to maintain the dictionary invariants.
    *
    * One possibility is to check these edges for intersection again
    * (ie. CheckForIntersect).  This is what we do if possible.  However
    * CheckForIntersect requires that tess->event lies between eUp and eLo,
    * so that it has something to fall back on when the intersection
    * calculation gives us an unusable answer.  So, for those cases where
    * we can't check for intersection, this routine fixes the problem
    * by just splicing the offending vertex into the other edge.
    * This is a guaranteed solution, no matter how degenerate things get.
    * Basically this is a combinatorial solution to a numerical problem.
    */var regLo=Sweep.regionBelow(regUp);var eUp=regUp.eUp;var eLo=regLo.eUp;if(Geom.vertLeq(eUp.Org,eLo.Org)){if(Geom.edgeSign(eLo.Dst,eUp.Org,eLo.Org)>0)return false;/* eUp->Org appears to be below eLo */if(!Geom.vertEq(eUp.Org,eLo.Org)){/* Splice eUp->Org into eLo */tess.mesh.splitEdge(eLo.Sym);tess.mesh.splice(eUp,eLo.Oprev);regUp.dirty=regLo.dirty=true;}else if(eUp.Org!==eLo.Org){/* merge the two vertices, discarding eUp->Org */tess.pq.delete(eUp.Org.pqHandle);Sweep.spliceMergeVertices(tess,eLo.Oprev,eUp);}}else {if(Geom.edgeSign(eUp.Dst,eLo.Org,eUp.Org)<0)return false;/* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */Sweep.regionAbove(regUp).dirty=regUp.dirty=true;tess.mesh.splitEdge(eUp.Sym);tess.mesh.splice(eLo.Oprev,eUp);}return true;};//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )
  Sweep.checkForLeftSplice=function(tess,regUp){/*
    * Check the upper and lower edge of "regUp", to make sure that the
    * eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
    * destination is rightmost).
    *
    * Theoretically, this should always be true.  However, splitting an edge
    * into two pieces can change the results of previous tests.  For example,
    * suppose at one point we checked eUp and eLo, and decided that eUp->Dst
    * is barely above eLo.  Then later, we split eLo into two edges (eg. from
    * a splice operation like this one).  This can change the result of
    * the test so that now eUp->Dst is incident to eLo, or barely below it.
    * We must correct this condition to maintain the dictionary invariants
    * (otherwise new edges might get inserted in the wrong place in the
    * dictionary, and bad stuff will happen).
    *
    * We fix the problem by just splicing the offending vertex into the
    * other edge.
    */var regLo=Sweep.regionBelow(regUp);var eUp=regUp.eUp;var eLo=regLo.eUp;var e;assert(!Geom.vertEq(eUp.Dst,eLo.Dst));if(Geom.vertLeq(eUp.Dst,eLo.Dst)){if(Geom.edgeSign(eUp.Dst,eLo.Dst,eUp.Org)<0)return false;/* eLo->Dst is above eUp, so splice eLo->Dst into eUp */Sweep.regionAbove(regUp).dirty=regUp.dirty=true;e=tess.mesh.splitEdge(eUp);tess.mesh.splice(eLo.Sym,e);e.Lface.inside=regUp.inside;}else {if(Geom.edgeSign(eLo.Dst,eUp.Dst,eLo.Org)>0)return false;/* eUp->Dst is below eLo, so splice eUp->Dst into eLo */regUp.dirty=regLo.dirty=true;e=tess.mesh.splitEdge(eLo);tess.mesh.splice(eUp.Lnext,eLo.Sym);e.Rface.inside=regUp.inside;}return true;};//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )
  Sweep.checkForIntersect=function(tess,regUp){/*
    * Check the upper and lower edges of the given region to see if
    * they intersect.  If so, create the intersection and add it
    * to the data structures.
    *
    * Returns TRUE if adding the new intersection resulted in a recursive
    * call to AddRightEdges(); in this case all "dirty" regions have been
    * checked for intersections, and possibly regUp has been deleted.
    */var regLo=Sweep.regionBelow(regUp);var eUp=regUp.eUp;var eLo=regLo.eUp;var orgUp=eUp.Org;var orgLo=eLo.Org;var dstUp=eUp.Dst;var dstLo=eLo.Dst;var tMinUp,tMaxLo;var isect=new TESSvertex(),orgMin;var e;assert(!Geom.vertEq(dstLo,dstUp));assert(Geom.edgeSign(dstUp,tess.event,orgUp)<=0);assert(Geom.edgeSign(dstLo,tess.event,orgLo)>=0);assert(orgUp!==tess.event&&orgLo!==tess.event);assert(!regUp.fixUpperEdge&&!regLo.fixUpperEdge);if(orgUp===orgLo)return false;/* right endpoints are the same */tMinUp=Math.min(orgUp.t,dstUp.t);tMaxLo=Math.max(orgLo.t,dstLo.t);if(tMinUp>tMaxLo)return false;/* t ranges do not overlap */if(Geom.vertLeq(orgUp,orgLo)){if(Geom.edgeSign(dstLo,orgUp,orgLo)>0)return false;}else {if(Geom.edgeSign(dstUp,orgLo,orgUp)<0)return false;}/* At this point the edges intersect, at least marginally */Sweep.debugEvent(tess);Geom.intersect(dstUp,orgUp,dstLo,orgLo,isect);/* The following properties are guaranteed: */assert(Math.min(orgUp.t,dstUp.t)<=isect.t);assert(isect.t<=Math.max(orgLo.t,dstLo.t));assert(Math.min(dstLo.s,dstUp.s)<=isect.s);assert(isect.s<=Math.max(orgLo.s,orgUp.s));if(Geom.vertLeq(isect,tess.event)){/* The intersection point lies slightly to the left of the sweep line,
      * so move it until it''s slightly to the right of the sweep line.
      * (If we had perfect numerical precision, this would never happen
      * in the first place).  The easiest and safest thing to do is
      * replace the intersection by tess->event.
      */isect.s=tess.event.s;isect.t=tess.event.t;}/* Similarly, if the computed intersection lies to the right of the
    * rightmost origin (which should rarely happen), it can cause
    * unbelievable inefficiency on sufficiently degenerate inputs.
    * (If you have the test program, try running test54.d with the
    * "X zoom" option turned on).
    */orgMin=Geom.vertLeq(orgUp,orgLo)?orgUp:orgLo;if(Geom.vertLeq(orgMin,isect)){isect.s=orgMin.s;isect.t=orgMin.t;}if(Geom.vertEq(isect,orgUp)||Geom.vertEq(isect,orgLo)){/* Easy case -- intersection at one of the right endpoints */Sweep.checkForRightSplice(tess,regUp);return false;}if(!Geom.vertEq(dstUp,tess.event)&&Geom.edgeSign(dstUp,tess.event,isect)>=0||!Geom.vertEq(dstLo,tess.event)&&Geom.edgeSign(dstLo,tess.event,isect)<=0){/* Very unusual -- the new upper or lower edge would pass on the
      * wrong side of the sweep event, or through it.  This can happen
      * due to very small numerical errors in the intersection calculation.
      */if(dstLo===tess.event){/* Splice dstLo into eUp, and process the new region(s) */tess.mesh.splitEdge(eUp.Sym);tess.mesh.splice(eLo.Sym,eUp);regUp=Sweep.topLeftRegion(tess,regUp);//			if (regUp == NULL) longjmp(tess->env,1);
  eUp=Sweep.regionBelow(regUp).eUp;Sweep.finishLeftRegions(tess,Sweep.regionBelow(regUp),regLo);Sweep.addRightEdges(tess,regUp,eUp.Oprev,eUp,eUp,true);return true;}if(dstUp===tess.event){/* Splice dstUp into eLo, and process the new region(s) */tess.mesh.splitEdge(eLo.Sym);tess.mesh.splice(eUp.Lnext,eLo.Oprev);regLo=regUp;regUp=Sweep.topRightRegion(regUp);e=Sweep.regionBelow(regUp).eUp.Rprev;regLo.eUp=eLo.Oprev;eLo=Sweep.finishLeftRegions(tess,regLo,null);Sweep.addRightEdges(tess,regUp,eLo.Onext,eUp.Rprev,e,true);return true;}/* Special case: called from ConnectRightVertex.  If either
      * edge passes on the wrong side of tess->event, split it
      * (and wait for ConnectRightVertex to splice it appropriately).
      */if(Geom.edgeSign(dstUp,tess.event,isect)>=0){Sweep.regionAbove(regUp).dirty=regUp.dirty=true;tess.mesh.splitEdge(eUp.Sym);eUp.Org.s=tess.event.s;eUp.Org.t=tess.event.t;}if(Geom.edgeSign(dstLo,tess.event,isect)<=0){regUp.dirty=regLo.dirty=true;tess.mesh.splitEdge(eLo.Sym);eLo.Org.s=tess.event.s;eLo.Org.t=tess.event.t;}/* leave the rest for ConnectRightVertex */return false;}/* General case -- split both edges, splice into new vertex.
    * When we do the splice operation, the order of the arguments is
    * arbitrary as far as correctness goes.  However, when the operation
    * creates a new face, the work done is proportional to the size of
    * the new face.  We expect the faces in the processed part of
    * the mesh (ie. eUp->Lface) to be smaller than the faces in the
    * unprocessed original contours (which will be eLo->Oprev->Lface).
    */tess.mesh.splitEdge(eUp.Sym);tess.mesh.splitEdge(eLo.Sym);tess.mesh.splice(eLo.Oprev,eUp);eUp.Org.s=isect.s;eUp.Org.t=isect.t;eUp.Org.pqHandle=tess.pq.insert(eUp.Org);Sweep.getIntersectData(tess,eUp.Org,orgUp,dstUp,orgLo,dstLo);Sweep.regionAbove(regUp).dirty=regUp.dirty=regLo.dirty=true;return false;};//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )
  Sweep.walkDirtyRegions=function(tess,regUp){/*
    * When the upper or lower edge of any region changes, the region is
    * marked "dirty".  This routine walks through all the dirty regions
    * and makes sure that the dictionary invariants are satisfied
    * (see the comments at the beginning of this file).  Of course
    * new dirty regions can be created as we make changes to restore
    * the invariants.
    */var regLo=Sweep.regionBelow(regUp);var eUp,eLo;for(;;){/* Find the lowest dirty region (we walk from the bottom up). */while(regLo.dirty){regUp=regLo;regLo=Sweep.regionBelow(regLo);}if(!regUp.dirty){regLo=regUp;regUp=Sweep.regionAbove(regUp);if(regUp===null||!regUp.dirty){/* We've walked all the dirty regions */return;}}regUp.dirty=false;eUp=regUp.eUp;eLo=regLo.eUp;if(eUp.Dst!==eLo.Dst){/* Check that the edge ordering is obeyed at the Dst vertices. */if(Sweep.checkForLeftSplice(tess,regUp)){/* If the upper or lower edge was marked fixUpperEdge, then
          * we no longer need it (since these edges are needed only for
          * vertices which otherwise have no right-going edges).
          */if(regLo.fixUpperEdge){Sweep.deleteRegion(tess,regLo);tess.mesh.delete(eLo);regLo=Sweep.regionBelow(regUp);eLo=regLo.eUp;}else if(regUp.fixUpperEdge){Sweep.deleteRegion(tess,regUp);tess.mesh.delete(eUp);regUp=Sweep.regionAbove(regLo);eUp=regUp.eUp;}}}if(eUp.Org!==eLo.Org){if(eUp.Dst!==eLo.Dst&&!regUp.fixUpperEdge&&!regLo.fixUpperEdge&&(eUp.Dst===tess.event||eLo.Dst===tess.event)){/* When all else fails in CheckForIntersect(), it uses tess->event
          * as the intersection location.  To make this possible, it requires
          * that tess->event lie between the upper and lower edges, and also
          * that neither of these is marked fixUpperEdge (since in the worst
          * case it might splice one of these edges into tess->event, and
          * violate the invariant that fixable edges are the only right-going
          * edge from their associated vertex).
          */if(Sweep.checkForIntersect(tess,regUp)){/* WalkDirtyRegions() was called recursively; we're done */return;}}else {/* Even though we can't use CheckForIntersect(), the Org vertices
          * may violate the dictionary edge ordering.  Check and correct this.
          */Sweep.checkForRightSplice(tess,regUp);}}if(eUp.Org===eLo.Org&&eUp.Dst===eLo.Dst){/* A degenerate loop consisting of only two edges -- delete it. */Sweep.addWinding(eLo,eUp);Sweep.deleteRegion(tess,regUp);tess.mesh.delete(eUp);regUp=Sweep.regionAbove(regLo);}}};//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )
  Sweep.connectRightVertex=function(tess,regUp,eBottomLeft){/*
    * Purpose: connect a "right" vertex vEvent (one where all edges go left)
    * to the unprocessed portion of the mesh.  Since there are no right-going
    * edges, two regions (one above vEvent and one below) are being merged
    * into one.  "regUp" is the upper of these two regions.
    *
    * There are two reasons for doing this (adding a right-going edge):
    *  - if the two regions being merged are "inside", we must add an edge
    *    to keep them separated (the combined region would not be monotone).
    *  - in any case, we must leave some record of vEvent in the dictionary,
    *    so that we can merge vEvent with features that we have not seen yet.
    *    For example, maybe there is a vertical edge which passes just to
    *    the right of vEvent; we would like to splice vEvent into this edge.
    *
    * However, we don't want to connect vEvent to just any vertex.  We don''t
    * want the new edge to cross any other edges; otherwise we will create
    * intersection vertices even when the input data had no self-intersections.
    * (This is a bad thing; if the user's input data has no intersections,
    * we don't want to generate any false intersections ourselves.)
    *
    * Our eventual goal is to connect vEvent to the leftmost unprocessed
    * vertex of the combined region (the union of regUp and regLo).
    * But because of unseen vertices with all right-going edges, and also
    * new vertices which may be created by edge intersections, we don''t
    * know where that leftmost unprocessed vertex is.  In the meantime, we
    * connect vEvent to the closest vertex of either chain, and mark the region
    * as "fixUpperEdge".  This flag says to delete and reconnect this edge
    * to the next processed vertex on the boundary of the combined region.
    * Quite possibly the vertex we connected to will turn out to be the
    * closest one, in which case we won''t need to make any changes.
    */var eNew;var eTopLeft=eBottomLeft.Onext;var regLo=Sweep.regionBelow(regUp);var eUp=regUp.eUp;var eLo=regLo.eUp;var degenerate=false;if(eUp.Dst!==eLo.Dst){Sweep.checkForIntersect(tess,regUp);}/* Possible new degeneracies: upper or lower edge of regUp may pass
    * through vEvent, or may coincide with new intersection vertex
    */if(Geom.vertEq(eUp.Org,tess.event)){tess.mesh.splice(eTopLeft.Oprev,eUp);regUp=Sweep.topLeftRegion(tess,regUp);eTopLeft=Sweep.regionBelow(regUp).eUp;Sweep.finishLeftRegions(tess,Sweep.regionBelow(regUp),regLo);degenerate=true;}if(Geom.vertEq(eLo.Org,tess.event)){tess.mesh.splice(eBottomLeft,eLo.Oprev);eBottomLeft=Sweep.finishLeftRegions(tess,regLo,null);degenerate=true;}if(degenerate){Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);return;}/* Non-degenerate situation -- need to add a temporary, fixable edge.
    * Connect to the closer of eLo->Org, eUp->Org.
    */if(Geom.vertLeq(eLo.Org,eUp.Org)){eNew=eLo.Oprev;}else {eNew=eUp;}eNew=tess.mesh.connect(eBottomLeft.Lprev,eNew);/* Prevent cleanup, otherwise eNew might disappear before we've even
    * had a chance to mark it as a temporary edge.
    */Sweep.addRightEdges(tess,regUp,eNew,eNew.Onext,eNew.Onext,false);eNew.Sym.activeRegion.fixUpperEdge=true;Sweep.walkDirtyRegions(tess,regUp);};/* Because vertices at exactly the same location are merged together
  * before we process the sweep event, some degenerate cases can't occur.
  * However if someone eventually makes the modifications required to
  * merge features which are close together, the cases below marked
  * TOLERANCE_NONZERO will be useful.  They were debugged before the
  * code to merge identical vertices in the main loop was added.
  */ //#define TOLERANCE_NONZERO	FALSE
  //static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )
  Sweep.connectLeftDegenerate=function(tess,regUp,vEvent){/*
    * The event vertex lies exacty on an already-processed edge or vertex.
    * Adding the new vertex involves splicing it into the already-processed
    * part of the mesh.
    */var e,eTopLeft,eTopRight,eLast;var reg;e=regUp.eUp;if(Geom.vertEq(e.Org,vEvent)){/* e->Org is an unprocessed vertex - just combine them, and wait
      * for e->Org to be pulled from the queue
      */assert(false/*TOLERANCE_NONZERO*/);Sweep.spliceMergeVertices(tess,e,vEvent.anEdge);return;}if(!Geom.vertEq(e.Dst,vEvent)){/* General case -- splice vEvent into edge e which passes through it */tess.mesh.splitEdge(e.Sym);if(regUp.fixUpperEdge){/* This edge was fixable -- delete unused portion of original edge */tess.mesh.delete(e.Onext);regUp.fixUpperEdge=false;}tess.mesh.splice(vEvent.anEdge,e);Sweep.sweepEvent(tess,vEvent);/* recurse */return;}/* vEvent coincides with e->Dst, which has already been processed.
    * Splice in the additional right-going edges.
    */assert(false/*TOLERANCE_NONZERO*/);regUp=Sweep.topRightRegion(regUp);reg=Sweep.regionBelow(regUp);eTopRight=reg.eUp.Sym;eTopLeft=eLast=eTopRight.Onext;if(reg.fixUpperEdge){/* Here e->Dst has only a single fixable edge going right.
      * We can delete it since now we have some real right-going edges.
      */assert(eTopLeft!==eTopRight);/* there are some left edges too */Sweep.deleteRegion(tess,reg);tess.mesh.delete(eTopRight);eTopRight=eTopLeft.Oprev;}tess.mesh.splice(vEvent.anEdge,eTopRight);if(!Geom.edgeGoesLeft(eTopLeft)){/* e->Dst had no left-going edges -- indicate this to AddRightEdges() */eTopLeft=null;}Sweep.addRightEdges(tess,regUp,eTopRight.Onext,eLast,eTopLeft,true);};//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )
  Sweep.connectLeftVertex=function(tess,vEvent){/*
    * Purpose: connect a "left" vertex (one where both edges go right)
    * to the processed portion of the mesh.  Let R be the active region
    * containing vEvent, and let U and L be the upper and lower edge
    * chains of R.  There are two possibilities:
    *
    * - the normal case: split R into two regions, by connecting vEvent to
    *   the rightmost vertex of U or L lying to the left of the sweep line
    *
    * - the degenerate case: if vEvent is close enough to U or L, we
    *   merge vEvent into that edge chain.  The subcases are:
    *	- merging with the rightmost vertex of U or L
    *	- merging with the active edge of U or L
    *	- merging with an already-processed portion of U or L
    */var regUp,regLo,reg;var eUp,eLo,eNew;var tmp=new ActiveRegion();/* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */ /* Get a pointer to the active region containing vEvent */tmp.eUp=vEvent.anEdge.Sym;/* __GL_DICTLISTKEY */ /* tessDictListSearch */regUp=tess.dict.search(tmp).key;regLo=Sweep.regionBelow(regUp);if(!regLo){// This may happen if the input polygon is coplanar.
  return;}eUp=regUp.eUp;eLo=regLo.eUp;/* Try merging with U or L first */if(Geom.edgeSign(eUp.Dst,vEvent,eUp.Org)===0.0){Sweep.connectLeftDegenerate(tess,regUp,vEvent);return;}/* Connect vEvent to rightmost processed vertex of either chain.
    * e->Dst is the vertex that we will connect to vEvent.
    */reg=Geom.vertLeq(eLo.Dst,eUp.Dst)?regUp:regLo;if(regUp.inside||reg.fixUpperEdge){if(reg===regUp){eNew=tess.mesh.connect(vEvent.anEdge.Sym,eUp.Lnext);}else {var tempHalfEdge=tess.mesh.connect(eLo.Dnext,vEvent.anEdge);eNew=tempHalfEdge.Sym;}if(reg.fixUpperEdge){Sweep.fixUpperEdge(tess,reg,eNew);}else {Sweep.computeWinding(tess,Sweep.addRegionBelow(tess,regUp,eNew));}Sweep.sweepEvent(tess,vEvent);}else {/* The new vertex is in a region which does not belong to the polygon.
      * We don''t need to connect this vertex to the rest of the mesh.
      */Sweep.addRightEdges(tess,regUp,vEvent.anEdge,vEvent.anEdge,null,true);}};//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )
  Sweep.sweepEvent=function(tess,vEvent){/*
    * Does everything necessary when the sweep line crosses a vertex.
    * Updates the mesh and the edge dictionary.
    */tess.event=vEvent;/* for access in EdgeLeq() */Sweep.debugEvent(tess);/* Check if this vertex is the right endpoint of an edge that is
    * already in the dictionary.  In this case we don't need to waste
    * time searching for the location to insert new edges.
    */var e=vEvent.anEdge;while(e.activeRegion===null){e=e.Onext;if(e===vEvent.anEdge){/* All edges go right -- not incident to any processed edges */Sweep.connectLeftVertex(tess,vEvent);return;}}/* Processing consists of two phases: first we "finish" all the
    * active regions where both the upper and lower edges terminate
    * at vEvent (ie. vEvent is closing off these regions).
    * We mark these faces "inside" or "outside" the polygon according
    * to their winding number, and delete the edges from the dictionary.
    * This takes care of all the left-going edges from vEvent.
    */var regUp=Sweep.topLeftRegion(tess,e.activeRegion);assert(regUp!==null);//	if (regUp == NULL) longjmp(tess->env,1);
  var reg=Sweep.regionBelow(regUp);var eTopLeft=reg.eUp;var eBottomLeft=Sweep.finishLeftRegions(tess,reg,null);/* Next we process all the right-going edges from vEvent.  This
    * involves adding the edges to the dictionary, and creating the
    * associated "active regions" which record information about the
    * regions between adjacent dictionary edges.
    */if(eBottomLeft.Onext===eTopLeft){/* No right-going edges -- add a temporary "fixable" edge */Sweep.connectRightVertex(tess,regUp,eBottomLeft);}else {Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);}};/* Make the sentinel coordinates big enough that they will never be
  * merged with real input features.
  */ //static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )
  Sweep.addSentinel=function(tess,smin,smax,t){/*
    * We add two sentinel edges above and below all other edges,
    * to avoid special cases at the top and bottom.
    */var reg=new ActiveRegion();var e=tess.mesh.makeEdge();//	if (e == NULL) longjmp(tess->env,1);
  e.Org.s=smax;e.Org.t=t;e.Dst.s=smin;e.Dst.t=t;tess.event=e.Dst;/* initialize it */reg.eUp=e;reg.windingNumber=0;reg.inside=false;reg.fixUpperEdge=false;reg.sentinel=true;reg.dirty=false;reg.nodeUp=tess.dict.insert(reg);//	if (reg->nodeUp == NULL) longjmp(tess->env,1);
  };//static void InitEdgeDict( TESStesselator *tess )
  Sweep.initEdgeDict=function(tess){/*
    * We maintain an ordering of edge intersections with the sweep line.
    * This order is maintained in a dynamic dictionary.
    */tess.dict=new Dict(tess,Sweep.edgeLeq);//	if (tess->dict == NULL) longjmp(tess->env,1);
  var w=tess.bmax[0]-tess.bmin[0];var h=tess.bmax[1]-tess.bmin[1];var smin=tess.bmin[0]-w;var smax=tess.bmax[0]+w;var tmin=tess.bmin[1]-h;var tmax=tess.bmax[1]+h;Sweep.addSentinel(tess,smin,smax,tmin);Sweep.addSentinel(tess,smin,smax,tmax);};Sweep.doneEdgeDict=function(tess){var reg;var fixedEdges=0;while((reg=tess.dict.min().key)!==null){/*
      * At the end of all processing, the dictionary should contain
      * only the two sentinel edges, plus at most one "fixable" edge
      * created by ConnectRightVertex().
      */if(!reg.sentinel){assert(reg.fixUpperEdge);assert(++fixedEdges===1);}assert(reg.windingNumber===0);Sweep.deleteRegion(tess,reg);/*    tessMeshDelete( reg->eUp );*/}//	dictDeleteDict( &tess->alloc, tess->dict );
  };Sweep.removeDegenerateEdges=function(tess){/*
    * Remove zero-length edges, and contours with fewer than 3 vertices.
    */var e,eNext,eLnext;var eHead=tess.mesh.eHead;/*LINTED*/for(e=eHead.next;e!==eHead;e=eNext){eNext=e.next;eLnext=e.Lnext;if(Geom.vertEq(e.Org,e.Dst)&&e.Lnext.Lnext!==e){/* Zero-length edge, contour has at least 3 edges */Sweep.spliceMergeVertices(tess,eLnext,e);/* deletes e->Org */tess.mesh.delete(e);/* e is a self-loop */e=eLnext;eLnext=e.Lnext;}if(eLnext.Lnext===e){/* Degenerate contour (one or two edges) */if(eLnext!==e){if(eLnext===eNext||eLnext===eNext.Sym){eNext=eNext.next;}tess.mesh.delete(eLnext);}if(e===eNext||e===eNext.Sym){eNext=eNext.next;}tess.mesh.delete(e);}}};Sweep.initPriorityQ=function(tess){/*
    * Insert all vertices into the priority queue which determines the
    * order in which vertices cross the sweep line.
    */var pq;var v,vHead;var vertexCount=0;vHead=tess.mesh.vHead;for(v=vHead.next;v!==vHead;v=v.next){vertexCount++;}/* Make sure there is enough space for sentinels. */vertexCount+=8;//MAX( 8, tess->alloc.extraVertices );
  pq=tess.pq=new PriorityQ(vertexCount,Geom.vertLeq);//	if (pq == NULL) return 0;
  vHead=tess.mesh.vHead;for(v=vHead.next;v!==vHead;v=v.next){v.pqHandle=pq.insert(v);//		if (v.pqHandle == INV_HANDLE)
  //			break;
  }if(v!==vHead){return false;}pq.init();return true;};Sweep.donePriorityQ=function(tess){tess.pq=null;};Sweep.removeDegenerateFaces=function(tess,mesh){/*
    * Delete any degenerate faces with only two edges.  WalkDirtyRegions()
    * will catch almost all of these, but it won't catch degenerate faces
    * produced by splice operations on already-processed edges.
    * The two places this can happen are in FinishLeftRegions(), when
    * we splice in a "temporary" edge produced by ConnectRightVertex(),
    * and in CheckForLeftSplice(), where we splice already-processed
    * edges to ensure that our dictionary invariants are not violated
    * by numerical errors.
    *
    * In both these cases it is *very* dangerous to delete the offending
    * edge at the time, since one of the routines further up the stack
    * will sometimes be keeping a pointer to that edge.
    */var f,fNext;var e;/*LINTED*/for(f=mesh.fHead.next;f!==mesh.fHead;f=fNext){fNext=f.next;e=f.anEdge;assert(e.Lnext!==e);if(e.Lnext.Lnext===e){/* A face with only two edges */Sweep.addWinding(e.Onext,e);tess.mesh.delete(e);}}return true;};Sweep.computeInterior=function(tess){/*
    * tessComputeInterior( tess ) computes the planar arrangement specified
    * by the given contours, and further subdivides this arrangement
    * into regions.  Each region is marked "inside" if it belongs
    * to the polygon, according to the rule given by tess->windingRule.
    * Each interior region is guaranteed be monotone.
    */var v,vNext;/* Each vertex defines an event for our sweep line.  Start by inserting
    * all the vertices in a priority queue.  Events are processed in
    * lexicographic order, ie.
    *
    *	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
    */Sweep.removeDegenerateEdges(tess);if(!Sweep.initPriorityQ(tess))return false;/* if error */Sweep.initEdgeDict(tess);while((v=tess.pq.extractMin())!==null){for(;;){vNext=tess.pq.min();if(vNext===null||!Geom.vertEq(vNext,v))break;/* Merge together all vertices at exactly the same location.
        * This is more efficient than processing them one at a time,
        * simplifies the code (see ConnectLeftDegenerate), and is also
        * important for correct handling of certain degenerate cases.
        * For example, suppose there are two identical edges A and B
        * that belong to different contours (so without this code they would
        * be processed by separate sweep events).  Suppose another edge C
        * crosses A and B from above.  When A is processed, we split it
        * at its intersection point with C.  However this also splits C,
        * so when we insert B we may compute a slightly different
        * intersection point.  This might leave two edges with a small
        * gap between them.  This kind of error is especially obvious
        * when using boundary extraction (TESS_BOUNDARY_ONLY).
        */vNext=tess.pq.extractMin();Sweep.spliceMergeVertices(tess,v.anEdge,vNext.anEdge);}Sweep.sweepEvent(tess,v);}/* Set tess->event for debugging purposes */tess.event=tess.dict.min().key.eUp.Org;Sweep.debugEvent(tess);Sweep.doneEdgeDict(tess);Sweep.donePriorityQ(tess);if(!Sweep.removeDegenerateFaces(tess,tess.mesh))return false;tess.mesh.check();return true;};function Tesselator(){/*** state needed for collecting the input data ***/this.mesh=null;/* stores the input contours, and eventually
    the tessellation itself */ /*** state needed for projecting onto the sweep plane ***/this.normal=[0.0,0.0,0.0];/* user-specified normal (if provided) */this.sUnit=[0.0,0.0,0.0];/* unit vector in s-direction (debugging) */this.tUnit=[0.0,0.0,0.0];/* unit vector in t-direction (debugging) */this.bmin=[0.0,0.0];this.bmax=[0.0,0.0];/*** state needed for the line sweep ***/this.windingRule=Tess2.WINDING_ODD;/* rule for determining polygon interior */this.dict=null;/* edge dictionary for sweep line */this.pq=null;/* priority queue of vertex events */this.event=null;/* current sweep event being processed */this.vertexIndexCounter=0;this.vertices=[];this.vertexIndices=[];this.vertexCount=0;this.elements=[];this.elementCount=0;}Tesselator.prototype={dot_:function dot_(u,v){return u[0]*v[0]+u[1]*v[1]+u[2]*v[2];},normalize_:function normalize_(v){var len=v[0]*v[0]+v[1]*v[1]+v[2]*v[2];assert(len>0.0);len=Math.sqrt(len);v[0]/=len;v[1]/=len;v[2]/=len;},longAxis_:function longAxis_(v){var i=0;if(Math.abs(v[1])>Math.abs(v[0])){i=1;}if(Math.abs(v[2])>Math.abs(v[i])){i=2;}return i;},computeNormal_:function computeNormal_(norm){var v,v1,v2;var c,tLen2,maxLen2;var maxVal=[0,0,0],minVal=[0,0,0],d1=[0,0,0],d2=[0,0,0],tNorm=[0,0,0];var maxVert=[null,null,null],minVert=[null,null,null];var vHead=this.mesh.vHead;var i;v=vHead.next;for(i=0;i<3;++i){c=v.coords[i];minVal[i]=c;minVert[i]=v;maxVal[i]=c;maxVert[i]=v;}for(v=vHead.next;v!==vHead;v=v.next){for(i=0;i<3;++i){c=v.coords[i];if(c<minVal[i]){minVal[i]=c;minVert[i]=v;}if(c>maxVal[i]){maxVal[i]=c;maxVert[i]=v;}}}/* Find two vertices separated by at least 1/sqrt(3) of the maximum
      * distance between any two vertices
      */i=0;if(maxVal[1]-minVal[1]>maxVal[0]-minVal[0]){i=1;}if(maxVal[2]-minVal[2]>maxVal[i]-minVal[i]){i=2;}if(minVal[i]>=maxVal[i]){/* All vertices are the same -- normal doesn't matter */norm[0]=0;norm[1]=0;norm[2]=1;return;}/* Look for a third vertex which forms the triangle with maximum area
      * (Length of normal == twice the triangle area)
      */maxLen2=0;v1=minVert[i];v2=maxVert[i];d1[0]=v1.coords[0]-v2.coords[0];d1[1]=v1.coords[1]-v2.coords[1];d1[2]=v1.coords[2]-v2.coords[2];for(v=vHead.next;v!==vHead;v=v.next){d2[0]=v.coords[0]-v2.coords[0];d2[1]=v.coords[1]-v2.coords[1];d2[2]=v.coords[2]-v2.coords[2];tNorm[0]=d1[1]*d2[2]-d1[2]*d2[1];tNorm[1]=d1[2]*d2[0]-d1[0]*d2[2];tNorm[2]=d1[0]*d2[1]-d1[1]*d2[0];tLen2=tNorm[0]*tNorm[0]+tNorm[1]*tNorm[1]+tNorm[2]*tNorm[2];if(tLen2>maxLen2){maxLen2=tLen2;norm[0]=tNorm[0];norm[1]=tNorm[1];norm[2]=tNorm[2];}}if(maxLen2<=0){/* All points lie on a single line -- any decent normal will do */norm[0]=norm[1]=norm[2]=0;norm[this.longAxis_(d1)]=1;}},checkOrientation_:function checkOrientation_(){var area;var f,fHead=this.mesh.fHead;var v,vHead=this.mesh.vHead;var e;/* When we compute the normal automatically, we choose the orientation
      * so that the the sum of the signed areas of all contours is non-negative.
      */area=0;for(f=fHead.next;f!==fHead;f=f.next){e=f.anEdge;if(e.winding<=0)continue;do{area+=(e.Org.s-e.Dst.s)*(e.Org.t+e.Dst.t);e=e.Lnext;}while(e!==f.anEdge);}if(area<0){/* Reverse the orientation by flipping all the t-coordinates */for(v=vHead.next;v!==vHead;v=v.next){v.t=-v.t;}this.tUnit[0]=-this.tUnit[0];this.tUnit[1]=-this.tUnit[1];this.tUnit[2]=-this.tUnit[2];}},/*	#ifdef FOR_TRITE_TEST_PROGRAM
      #include <stdlib.h>
      extern int RandomSweep;
      #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
      #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
      #else
      #if defined(SLANTED_SWEEP) */ /* The "feature merging" is not intended to be complete.  There are
    * special cases where edges are nearly parallel to the sweep line
    * which are not implemented.  The algorithm should still behave
    * robustly (ie. produce a reasonable tesselation) in the presence
    * of such edges, however it may miss features which could have been
    * merged.  We could minimize this effect by choosing the sweep line
    * direction to be something unusual (ie. not parallel to one of the
    * coordinate axes).
    */ /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
      #define S_UNIT_Y	(TESSreal)0.86052074622010633
      #else
      #define S_UNIT_X	(TESSreal)1.0
      #define S_UNIT_Y	(TESSreal)0.0
      #endif
      #endif*/ /* Determine the polygon normal and project vertices onto the plane
    * of the polygon.
    */projectPolygon_:function projectPolygon_(){var v,vHead=this.mesh.vHead;var norm=[0,0,0];var sUnit,tUnit;var i,first,computedNormal=false;norm[0]=this.normal[0];norm[1]=this.normal[1];norm[2]=this.normal[2];if(norm[0]===0.0&&norm[1]===0.0&&norm[2]===0.0){this.computeNormal_(norm);computedNormal=true;}sUnit=this.sUnit;tUnit=this.tUnit;i=this.longAxis_(norm);/*	#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)
          // Choose the initial sUnit vector to be approximately perpendicular
          // to the normal.
          
          Normalize( norm );
      
          sUnit[i] = 0;
          sUnit[(i+1)%3] = S_UNIT_X;
          sUnit[(i+2)%3] = S_UNIT_Y;
      
          // Now make it exactly perpendicular 
          w = Dot( sUnit, norm );
          sUnit[0] -= w * norm[0];
          sUnit[1] -= w * norm[1];
          sUnit[2] -= w * norm[2];
          Normalize( sUnit );
      
          // Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame 
          tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
          tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
          tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
          Normalize( tUnit );
        #else*/ /* Project perpendicular to a coordinate axis -- better numerically */sUnit[i]=0;sUnit[(i+1)%3]=1.0;sUnit[(i+2)%3]=0.0;tUnit[i]=0;tUnit[(i+1)%3]=0.0;tUnit[(i+2)%3]=norm[i]>0?1.0:-1.0;//	#endif
  /* Project the vertices onto the sweep plane */for(v=vHead.next;v!==vHead;v=v.next){v.s=this.dot_(v.coords,sUnit);v.t=this.dot_(v.coords,tUnit);}if(computedNormal){this.checkOrientation_();}/* Compute ST bounds. */first=true;for(v=vHead.next;v!==vHead;v=v.next){if(first){this.bmin[0]=this.bmax[0]=v.s;this.bmin[1]=this.bmax[1]=v.t;first=false;}else {if(v.s<this.bmin[0])this.bmin[0]=v.s;if(v.s>this.bmax[0])this.bmax[0]=v.s;if(v.t<this.bmin[1])this.bmin[1]=v.t;if(v.t>this.bmax[1])this.bmax[1]=v.t;}}},addWinding_:function addWinding_(eDst,eSrc){eDst.winding+=eSrc.winding;eDst.Sym.winding+=eSrc.Sym.winding;},/* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
    * (what else would it do??)  The region must consist of a single
    * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
    * case means that any vertical line intersects the interior of the
    * region in a single interval.  
    *
    * Tessellation consists of adding interior edges (actually pairs of
    * half-edges), to split the region into non-overlapping triangles.
    *
    * The basic idea is explained in Preparata and Shamos (which I don''t
    * have handy right now), although their implementation is more
    * complicated than this one.  The are two edge chains, an upper chain
    * and a lower chain.  We process all vertices from both chains in order,
    * from right to left.
    *
    * The algorithm ensures that the following invariant holds after each
    * vertex is processed: the untessellated region consists of two
    * chains, where one chain (say the upper) is a single edge, and
    * the other chain is concave.  The left vertex of the single edge
    * is always to the left of all vertices in the concave chain.
    *
    * Each step consists of adding the rightmost unprocessed vertex to one
    * of the two chains, and forming a fan of triangles from the rightmost
    * of two chain endpoints.  Determining whether we can add each triangle
    * to the fan is a simple orientation test.  By making the fan as large
    * as possible, we restore the invariant (check it yourself).
    */ //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
  tessellateMonoRegion_:function tessellateMonoRegion_(mesh,face){var up,lo;/* All edges are oriented CCW around the boundary of the region.
      * First, find the half-edge whose origin vertex is rightmost.
      * Since the sweep goes from left to right, face->anEdge should
      * be close to the edge we want.
      */up=face.anEdge;assert(up.Lnext!==up&&up.Lnext.Lnext!==up);for(;Geom.vertLeq(up.Dst,up.Org);up=up.Lprev){}for(;Geom.vertLeq(up.Org,up.Dst);up=up.Lnext){}lo=up.Lprev;while(up.Lnext!==lo){if(Geom.vertLeq(up.Dst,lo.Org)){/* up->Dst is on the left.  It is safe to form triangles from lo->Org.
          * The EdgeGoesLeft test guarantees progress even when some triangles
          * are CW, given that the upper and lower chains are truly monotone.
          */while(lo.Lnext!==up&&(Geom.edgeGoesLeft(lo.Lnext)||Geom.edgeSign(lo.Org,lo.Dst,lo.Lnext.Dst)<=0.0)){var tempHalfEdge=mesh.connect(lo.Lnext,lo);//if (tempHalfEdge == NULL) return 0;
  lo=tempHalfEdge.Sym;}lo=lo.Lprev;}else {/* lo->Org is on the left.  We can make CCW triangles from up->Dst. */while(lo.Lnext!==up&&(Geom.edgeGoesRight(up.Lprev)||Geom.edgeSign(up.Dst,up.Org,up.Lprev.Org)>=0.0)){var tempHalfEdge=mesh.connect(up,up.Lprev);//if (tempHalfEdge == NULL) return 0;
  up=tempHalfEdge.Sym;}up=up.Lnext;}}/* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
      * can be tessellated in a fan from this leftmost vertex.
      */assert(lo.Lnext!==up);while(lo.Lnext.Lnext!==up){var tempHalfEdge=mesh.connect(lo.Lnext,lo);//if (tempHalfEdge == NULL) return 0;
  lo=tempHalfEdge.Sym;}return true;},/* tessMeshTessellateInterior( mesh ) tessellates each region of
    * the mesh which is marked "inside" the polygon.  Each such region
    * must be monotone.
    */ //int tessMeshTessellateInterior( TESSmesh *mesh )
  tessellateInterior_:function tessellateInterior_(mesh){var f,next;/*LINTED*/for(f=mesh.fHead.next;f!==mesh.fHead;f=next){/* Make sure we don''t try to tessellate the new triangles. */next=f.next;if(f.inside){if(!this.tessellateMonoRegion_(mesh,f))return false;}}return true;},/* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
    * which are not marked "inside" the polygon.  Since further mesh operations
    * on NULL faces are not allowed, the main purpose is to clean up the
    * mesh so that exterior loops are not represented in the data structure.
    */ //void tessMeshDiscardExterior( TESSmesh *mesh )
  discardExterior_:function discardExterior_(mesh){var f,next;/*LINTED*/for(f=mesh.fHead.next;f!==mesh.fHead;f=next){/* Since f will be destroyed, save its next pointer. */next=f.next;if(!f.inside){mesh.zapFace(f);}}},/* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
    * winding numbers on all edges so that regions marked "inside" the
    * polygon have a winding number of "value", and regions outside
    * have a winding number of 0.
    *
    * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
    * separate an interior region from an exterior one.
    */ //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
  setWindingNumber_:function setWindingNumber_(mesh,value,keepOnlyBoundary){var e,eNext;for(e=mesh.eHead.next;e!==mesh.eHead;e=eNext){eNext=e.next;if(e.Rface.inside!==e.Lface.inside){/* This is a boundary edge (one side is interior, one is exterior). */e.winding=e.Lface.inside?value:-value;}else {/* Both regions are interior, or both are exterior. */if(!keepOnlyBoundary){e.winding=0;}else {mesh.delete(e);}}}},getNeighbourFace_:function getNeighbourFace_(edge){if(!edge.Rface)return -1;if(!edge.Rface.inside)return -1;return edge.Rface.n;},outputPolymesh_:function outputPolymesh_(mesh,elementType,polySize,vertexSize){var v;var f;var edge;var maxFaceCount=0;var maxVertexCount=0;var faceVerts,i;// Try to merge as many polygons as possible
  if(polySize>3){mesh.mergeConvexFaces(polySize);}// Mark unused
  for(v=mesh.vHead.next;v!==mesh.vHead;v=v.next){v.n=-1;}// Create unique IDs for all vertices and faces.
  for(f=mesh.fHead.next;f!==mesh.fHead;f=f.next){f.n=-1;if(!f.inside)continue;edge=f.anEdge;faceVerts=0;do{v=edge.Org;if(v.n===-1){v.n=maxVertexCount;maxVertexCount++;}faceVerts++;edge=edge.Lnext;}while(edge!==f.anEdge);assert(faceVerts<=polySize);f.n=maxFaceCount;++maxFaceCount;}this.elementCount=maxFaceCount;if(elementType===Tess2.CONNECTED_POLYGONS)maxFaceCount*=2;/*		tess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                    sizeof(TESSindex) * maxFaceCount * polySize );
          if (!tess->elements)
          {
            tess->outOfMemory = 1;
            return;
          }*/this.elements=[];this.elements.length=maxFaceCount*polySize;this.vertexCount=maxVertexCount;/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
                                   sizeof(TESSreal) * tess->vertexCount * vertexSize );
          if (!tess->vertices)
          {
            tess->outOfMemory = 1;
            return;
          }*/this.vertices=[];this.vertices.length=maxVertexCount*vertexSize;/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                        sizeof(TESSindex) * tess->vertexCount );
          if (!tess->vertexIndices)
          {
            tess->outOfMemory = 1;
            return;
          }*/this.vertexIndices=[];this.vertexIndices.length=maxVertexCount;// Output vertices.
  for(v=mesh.vHead.next;v!==mesh.vHead;v=v.next){if(v.n!==-1){// Store coordinate
  var idx=v.n*vertexSize;this.vertices[idx+0]=v.coords[0];this.vertices[idx+1]=v.coords[1];if(vertexSize>2)this.vertices[idx+2]=v.coords[2];// Store vertex index.
  this.vertexIndices[v.n]=v.idx;}}// Output indices.
  var nel=0;for(f=mesh.fHead.next;f!==mesh.fHead;f=f.next){if(!f.inside)continue;// Store polygon
  edge=f.anEdge;faceVerts=0;do{v=edge.Org;this.elements[nel++]=v.n;faceVerts++;edge=edge.Lnext;}while(edge!==f.anEdge);// Fill unused.
  for(i=faceVerts;i<polySize;++i){this.elements[nel++]=-1;}// Store polygon connectivity
  if(elementType===Tess2.CONNECTED_POLYGONS){edge=f.anEdge;do{this.elements[nel++]=this.getNeighbourFace_(edge);edge=edge.Lnext;}while(edge!==f.anEdge);// Fill unused.
  for(i=faceVerts;i<polySize;++i){this.elements[nel++]=-1;}}}},//	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
  outputContours_:function outputContours_(mesh,vertexSize){var f;var edge;var start;var startVert=0;var vertCount=0;this.vertexCount=0;this.elementCount=0;for(f=mesh.fHead.next;f!==mesh.fHead;f=f.next){if(!f.inside)continue;start=edge=f.anEdge;do{this.vertexCount++;edge=edge.Lnext;}while(edge!==start);this.elementCount++;}/*		tess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                    sizeof(TESSindex) * tess->elementCount * 2 );
          if (!tess->elements)
          {
            tess->outOfMemory = 1;
            return;
          }*/this.elements=[];this.elements.length=this.elementCount*2;/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
                                    sizeof(TESSreal) * tess->vertexCount * vertexSize );
          if (!tess->vertices)
          {
            tess->outOfMemory = 1;
            return;
          }*/this.vertices=[];this.vertices.length=this.vertexCount*vertexSize;/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                        sizeof(TESSindex) * tess->vertexCount );
          if (!tess->vertexIndices)
          {
            tess->outOfMemory = 1;
            return;
          }*/this.vertexIndices=[];this.vertexIndices.length=this.vertexCount;var nv=0;var nvi=0;var nel=0;startVert=0;for(f=mesh.fHead.next;f!==mesh.fHead;f=f.next){if(!f.inside)continue;vertCount=0;start=edge=f.anEdge;do{this.vertices[nv++]=edge.Org.coords[0];this.vertices[nv++]=edge.Org.coords[1];if(vertexSize>2)this.vertices[nv++]=edge.Org.coords[2];this.vertexIndices[nvi++]=edge.Org.idx;vertCount++;edge=edge.Lnext;}while(edge!==start);this.elements[nel++]=startVert;this.elements[nel++]=vertCount;startVert+=vertCount;}},addContour:function addContour(size,vertices){var e;var i;if(this.mesh===null)this.mesh=new TESSmesh();/*	 	if ( tess->mesh == NULL ) {
            tess->outOfMemory = 1;
            return;
          }*/if(size<2)size=2;if(size>3)size=3;e=null;for(i=0;i<vertices.length;i+=size){if(e===null){/* Make a self-loop (one vertex, one edge). */e=this.mesh.makeEdge();/*				if ( e == NULL ) {
                    tess->outOfMemory = 1;
                    return;
                  }*/this.mesh.splice(e,e.Sym);}else {/* Create a new vertex and edge which immediately follow e
          * in the ordering around the left face.
          */this.mesh.splitEdge(e);e=e.Lnext;}/* The new vertex is now e->Org. */e.Org.coords[0]=vertices[i+0];e.Org.coords[1]=vertices[i+1];if(size>2)e.Org.coords[2]=vertices[i+2];else e.Org.coords[2]=0.0;/* Store the insertion number so that the vertex can be later recognized. */e.Org.idx=this.vertexIndexCounter++;/* The winding of an edge says how the winding number changes as we
        * cross from the edge''s right face to its left face.  We add the
        * vertices in such an order that a CCW contour will add +1 to
        * the winding number of the region inside the contour.
        */e.winding=1;e.Sym.winding=-1;}},//	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
  tesselate:function tesselate(windingRule,elementType,polySize,vertexSize,normal){this.vertices=[];this.elements=[];this.vertexIndices=[];this.vertexIndexCounter=0;if(normal){this.normal[0]=normal[0];this.normal[1]=normal[1];this.normal[2]=normal[2];}this.windingRule=windingRule;if(vertexSize<2)vertexSize=2;if(vertexSize>3)vertexSize=3;/*		if (setjmp(tess->env) != 0) { 
            // come back here if out of memory
            return 0;
          }*/if(!this.mesh){return false;}/* Determine the polygon normal and project vertices onto the plane
      * of the polygon.
      */this.projectPolygon_();/* tessComputeInterior( tess ) computes the planar arrangement specified
      * by the given contours, and further subdivides this arrangement
      * into regions.  Each region is marked "inside" if it belongs
      * to the polygon, according to the rule given by tess->windingRule.
      * Each interior region is guaranteed be monotone.
      */Sweep.computeInterior(this);var mesh=this.mesh;/* If the user wants only the boundary contours, we throw away all edges
      * except those which separate the interior from the exterior.
      * Otherwise we tessellate all the regions marked "inside".
      */if(elementType===Tess2.BOUNDARY_CONTOURS){this.setWindingNumber_(mesh,1,true);}else {this.tessellateInterior_(mesh);}//		if (rc == 0) longjmp(tess->env,1);  /* could've used a label */
  mesh.check();if(elementType===Tess2.BOUNDARY_CONTOURS){this.outputContours_(mesh,vertexSize);/* output contours */}else {this.outputPolymesh_(mesh,elementType,polySize,vertexSize);/* output polygons */}//			tess.mesh = null;
  return true;}};/***/},function(module,exports){module.exports=extend;var hasOwnProperty=Object.prototype.hasOwnProperty;function extend(){var target={};for(var i=0;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"createShaders",function(){return createShaders;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"applyShader",function(){return applyShader;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"createCloudShaders",function(){return createCloudShaders;});/* harmony export (binding) */__webpack_require__.d(__webpack_exports__,"applyCloudShader",function(){return applyCloudShader;});/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(19);/* harmony import */var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default=/*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);/* harmony import */var _shader_vert__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(83);/* harmony import */var _shader_frag__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(84);/* harmony import */var _shader_cloud_vert__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(85);/* harmony import */var _shader_cloud_frag__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(86);__webpack_require__(1).glMatrix.setMatrixArrayType(Array);var _shaders=Symbol('shaders');function createShaders(renderer){renderer[_shaders]=[];for(var i=0;i<16;i++){var defines=[];var hasTexture=!!(i&0x1);var hasFilter=!!(i&0x2);var hasGradient=!!(i&0x4);var hasClipPath=!!(i&0x8);if(hasTexture)defines.push('#define TEXTURE 1');if(hasFilter)defines.push('#define FILTER 1');if(hasGradient)defines.push('#define GRADIENT 1');if(hasClipPath)defines.push('#define CLIPPATH 1');var prefix="".concat(defines.join('\n'),"\n");var samplerDef=[];if(hasTexture){samplerDef.push('uniform sampler2D u_texSampler;');}if(hasClipPath){samplerDef.push('uniform sampler2D u_clipSampler;');}// renderer.createProgram(prefix + samplerDef.join('\n') + fragShader, prefix + vertShader);
  renderer[_shaders][i]=[prefix+samplerDef.join('\n')+_shader_frag__WEBPACK_IMPORTED_MODULE_2__["default"],prefix+_shader_vert__WEBPACK_IMPORTED_MODULE_1__["default"]];}}function applyShader(renderer){var _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref$hasTexture=_ref.hasTexture,hasTexture=_ref$hasTexture===void 0?false:_ref$hasTexture,_ref$hasFilter=_ref.hasFilter,hasFilter=_ref$hasFilter===void 0?false:_ref$hasFilter,_ref$hasGradient=_ref.hasGradient,hasGradient=_ref$hasGradient===void 0?false:_ref$hasGradient,_ref$hasClipPath=_ref.hasClipPath,hasClipPath=_ref$hasClipPath===void 0?false:_ref$hasClipPath;var idx=hasTexture|hasFilter<<1|hasGradient<<2|hasClipPath<<3;var program=renderer[_shaders][idx];if(Array.isArray(program)){program=renderer.createProgram.apply(renderer,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(program));renderer[_shaders][idx]=program;}if(renderer.program!==program){renderer.useProgram(program,{a_color:{type:'UNSIGNED_BYTE',normalize:true}});}}var cloudShaders=[];function createCloudShaders(renderer){for(var i=0;i<64;i++){var defines=[];var hasTexture=!!(i&0x1);var hasFilter=!!(i&0x2);var hasGradient=!!(i&0x4);var hasCloudColor=!!(i&0x8);var hasCloudFilter=!!(i&0x10);var hasClipPath=!!(i&0x20);if(hasTexture)defines.push('#define TEXTURE 1');if(hasFilter)defines.push('#define FILTER 1');if(hasGradient)defines.push('#define GRADIENT 1');if(hasCloudColor)defines.push('#define CLOUDCOLOR 1');if(hasCloudFilter)defines.push('#define CLOUDFILTER 1');if(hasClipPath)defines.push('#define CLIPPATH 1');var prefix="".concat(defines.join('\n'),"\n");var samplerDef=[];if(hasTexture){samplerDef.push('uniform sampler2D u_texSampler;');for(var j=0;j<12;j++){samplerDef.push("uniform sampler2D u_texFrame".concat(j,";"));}}if(hasClipPath){samplerDef.push('uniform sampler2D u_clipSampler;');}cloudShaders[i]=[prefix+samplerDef.join('\n')+_shader_cloud_frag__WEBPACK_IMPORTED_MODULE_4__["default"],prefix+_shader_cloud_vert__WEBPACK_IMPORTED_MODULE_3__["default"]];// renderer.createProgram(prefix + samplerDef.join('\n') + fragShaderCloud, prefix + vertShaderCloud);
  }}function applyCloudShader(renderer){var _ref2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref2$hasTexture=_ref2.hasTexture,hasTexture=_ref2$hasTexture===void 0?false:_ref2$hasTexture,_ref2$hasFilter=_ref2.hasFilter,hasFilter=_ref2$hasFilter===void 0?false:_ref2$hasFilter,_ref2$hasGradient=_ref2.hasGradient,hasGradient=_ref2$hasGradient===void 0?false:_ref2$hasGradient,_ref2$hasCloudColor=_ref2.hasCloudColor,hasCloudColor=_ref2$hasCloudColor===void 0?false:_ref2$hasCloudColor,_ref2$hasCloudFilter=_ref2.hasCloudFilter,hasCloudFilter=_ref2$hasCloudFilter===void 0?false:_ref2$hasCloudFilter,_ref2$hasClipPath=_ref2.hasClipPath,hasClipPath=_ref2$hasClipPath===void 0?false:_ref2$hasClipPath;var idx=hasTexture|hasFilter<<1|hasGradient<<2|hasCloudColor<<3|hasCloudFilter<<4|hasClipPath<<5;var program=cloudShaders[idx];if(Array.isArray(program)){program=renderer.createProgram.apply(renderer,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(program));cloudShaders[idx]=program;}if(renderer.program!==program){renderer.useProgram(program,{a_color:{type:'UNSIGNED_BYTE',normalize:true},a_fillCloudColor:{type:'UNSIGNED_BYTE',normalize:true},a_strokeCloudColor:{type:'UNSIGNED_BYTE',normalize:true},a_frameIndex:{type:'UNSIGNED_BYTE',normalize:false}});}}/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony default export */__webpack_exports__["default"]="attribute vec3 a_vertexPosition;\nattribute vec4 a_color;\nvarying vec4 vColor;\nvarying float flagBackground;\nuniform vec2 u_resolution;\nuniform mat3 viewMatrix;\nuniform mat3 projectionMatrix;\n\n#ifdef TEXTURE\nattribute vec3 a_vertexTextureCoord;\nvarying vec3 vTextureCoord;\nattribute vec4 a_sourceRect;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nattribute vec2 a_clipUV;\nvarying vec2 vClipUV;\n#endif\n\n#ifdef GRADIENT\nuniform float u_radialGradientVector[6];\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\n#endif\n\nvoid main() {\n  gl_PointSize = 1.0;\n\n  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);\n  gl_Position = vec4(pos.xy, 1.0, 1.0);\n\n#ifdef GRADIENT\n  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);\n  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);\n  float h = u_resolution.y;\n  vg1.y = h - vg1.y;\n  vg2.y = h - vg2.y;\n  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);\n  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);\n#endif\n  \n  flagBackground = a_vertexPosition.z;\n  vColor = a_color;\n\n#ifdef TEXTURE\n  vTextureCoord = a_vertexTextureCoord;\n  vSourceRect = a_sourceRect;\n#endif\n\n#ifdef CLIPPATH\n  vClipUV = a_clipUV;\n#endif\n}";/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony default export */__webpack_exports__["default"]="precision mediump float;\n\nvarying vec4 vColor;\nvarying float flagBackground;\n\n#ifdef TEXTURE\nvarying vec3 vTextureCoord;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nvarying vec2 vClipUV;\n#endif\n\n#ifdef FILTER\nuniform int u_filterFlag;\nuniform float u_colorMatrix[20];\n#endif\n\n#ifdef GRADIENT\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\nuniform float u_colorSteps[40];\nuniform int u_gradientType;\n// uniform float u_radialGradientVector[6];\n\nvoid gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {\n  float t;\n  // center circle radius\n  float cr = gv1.z;\n  // focal circle radius\n  float fr = gv2.z;\n\n  if(cr > 0.0 || fr > 0.0) {\n    // radial gradient\n    vec2 center = gv1.xy;\n    vec2 focal = gv2.xy;\n    float x = focal.x - gl_FragCoord.x;\n    float y = focal.y - gl_FragCoord.y;\n    float dx = focal.x - center.x;\n    float dy = focal.y - center.y;\n    float dr = cr - fr;\n    float a = dx * dx + dy * dy - dr * dr;\n    float b = -2.0 * (y * dy + x * dx + fr * dr);\n    float c = x * x + y * y - fr * fr;\n    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));\n  } else {\n    // linear gradient\n    vec2 v1 = gl_FragCoord.xy - gv1.xy;\n    vec2 v2 = gv2.xy - gv1.xy;\n    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);\n  }\n\n  vec4 colors[8];\n  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);\n  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);\n  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);\n  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);\n  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);\n  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);\n  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);\n  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);\n  \n  float steps[8];\n  steps[0] = colorSteps[0];\n  steps[1] = colorSteps[5];\n  steps[2] = colorSteps[10];\n  steps[3] = colorSteps[15];\n  steps[4] = colorSteps[20];\n  steps[5] = colorSteps[25];\n  steps[6] = colorSteps[30];\n  steps[7] = colorSteps[35];\n\n  color = colors[0];\n  for (int i = 1; i < 8; i++) {\n    if (steps[i] < 0.0 || steps[i] > 1.0) {\n      break;\n    }\n    if(steps[i] == steps[i - 1]) {\n      color = colors[i];\n    } else {\n      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));\n    }\n    if (steps[i] >= t) {\n      break;\n    }\n  }\n}\n#endif\n\n#ifdef FILTER\nvoid transformColor(inout vec4 color, in float colorMatrix[20]) {\n  float r = color.r, g = color.g, b = color.b, a = color.a;\n  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];\n  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];\n  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];\n  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];\n}\n#endif\n\nvoid main() {\n  vec4 color = vColor;\n  float opacity = abs(flagBackground);\n\n#ifdef GRADIENT\n  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {\n    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);\n  }\n#endif\n\n  if(opacity < 1.0) {\n    color.a *= opacity;\n  }\n\n#ifdef TEXTURE\n  if(flagBackground > 0.0) {\n    vec3 texCoord = vTextureCoord;\n\n    if(texCoord.z == 1.0) {\n      texCoord = fract(texCoord);\n    }\n\n    if(texCoord.x <= 1.0 && texCoord.x >= 0.0\n      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {\n      if(vSourceRect.z > 0.0) {\n        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;\n        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);\n      }\n      vec4 texColor = texture2D(u_texSampler, texCoord.xy);\n      float alpha = texColor.a;\n      if(opacity < 1.0) {\n        texColor.a *= opacity;\n        alpha *= mix(0.465, 1.0, opacity);\n      }\n      // color = mix(color, texColor, texColor.a);\n      color.rgb = mix(color.rgb, texColor.rgb, alpha);\n      // color.rgb = mix(texColor.rgb, color.rgb, color.a);\n      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));\n      color.a = texColor.a + (1.0 - texColor.a) * color.a;\n    }\n  }\n#endif\n\n#ifdef FILTER\n  if(u_filterFlag > 0) {\n    transformColor(color, u_colorMatrix);\n  }\n#endif\n\n#ifdef CLIPPATH\n  float clip = texture2D(u_clipSampler, vClipUV).r;\n  color *= clip;\n#endif\n\n  gl_FragColor = color;\n}";/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony default export */__webpack_exports__["default"]="attribute vec3 a_vertexPosition;\nattribute vec4 a_color;\nvarying vec4 vColor;\nvarying float flagBackground;\nattribute vec3 a_transform0;\nattribute vec3 a_transform1;\nuniform vec2 u_resolution;\nuniform mat3 viewMatrix;\nuniform mat3 projectionMatrix;\n\n#ifdef TEXTURE\nattribute vec3 a_vertexTextureCoord;\nvarying vec3 vTextureCoord;\nattribute float a_frameIndex;\nvarying float frameIndex;\nattribute vec4 a_sourceRect;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nattribute vec2 a_clipUV;\nvarying vec2 vClipUV;\n#endif\n\n#ifdef CLOUDFILTER\nattribute vec4 a_colorCloud0;\nattribute vec4 a_colorCloud1;\nattribute vec4 a_colorCloud2;\nattribute vec4 a_colorCloud3;\nattribute vec4 a_colorCloud4;\nvarying vec4 colorCloud0;\nvarying vec4 colorCloud1;\nvarying vec4 colorCloud2;\nvarying vec4 colorCloud3;\nvarying vec4 colorCloud4;\n#endif\n\n#ifdef CLOUDCOLOR\nattribute vec4 a_fillCloudColor;\nattribute vec4 a_strokeCloudColor;\n#endif\n\n#ifdef GRADIENT\nuniform float u_radialGradientVector[6];\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\n#endif\n\nvoid main() {\n  gl_PointSize = 1.0;\n\n  mat3 modelMatrix = mat3(\n    a_transform0.x, a_transform1.x, 0, \n    a_transform0.y, a_transform1.y, 0,\n    a_transform0.z, a_transform1.z, 1\n  );\n\n  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);\n  gl_Position = vec4(pos.xy, 1.0, 1.0);\n\n#ifdef GRADIENT\n  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);\n  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);\n  float h = u_resolution.y;\n  vg1.y = h - vg1.y;\n  vg2.y = h - vg2.y;\n  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);\n  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);\n#endif\n  \n  flagBackground = a_vertexPosition.z;\n\n#ifdef CLOUDCOLOR\n  if(flagBackground > 0.0) {\n    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);\n  } else {\n    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);\n  }\n#else\n  vColor = a_color;\n#endif\n\n#ifdef TEXTURE\n  vTextureCoord = a_vertexTextureCoord;\n  frameIndex = a_frameIndex;\n  vSourceRect = a_sourceRect;\n#endif\n\n#ifdef CLIPPATH\n  vClipUV = a_clipUV;\n#endif\n\n#ifdef CLOUDFILTER\n  colorCloud0 = a_colorCloud0;\n  colorCloud1 = a_colorCloud1;\n  colorCloud2 = a_colorCloud2;\n  colorCloud3 = a_colorCloud3;\n  colorCloud4 = a_colorCloud4;\n#endif\n}";/***/},function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);/* harmony default export */__webpack_exports__["default"]="precision mediump float;\n\nvarying vec4 vColor;\nvarying float flagBackground;\n\n#ifdef TEXTURE\nvarying float frameIndex;\nvarying vec3 vTextureCoord;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nvarying vec2 vClipUV;\n#endif\n\n#ifdef FILTER\nuniform int u_filterFlag;\nuniform float u_colorMatrix[20];\n#endif\n\n#ifdef CLOUDFILTER\nvarying vec4 colorCloud0;\nvarying vec4 colorCloud1;\nvarying vec4 colorCloud2;\nvarying vec4 colorCloud3;\nvarying vec4 colorCloud4;\n#endif\n\n#ifdef GRADIENT\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\nuniform float u_colorSteps[40];\nuniform int u_gradientType;\n\nvoid gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {\n  float t;\n  // center circle radius\n  float cr = gv1.z;\n  // focal circle radius\n  float fr = gv2.z;\n\n  if(cr > 0.0 || fr > 0.0) {\n    // radial gradient\n    vec2 center = gv1.xy;\n    vec2 focal = gv2.xy;\n    float x = focal.x - gl_FragCoord.x;\n    float y = focal.y - gl_FragCoord.y;\n    float dx = focal.x - center.x;\n    float dy = focal.y - center.y;\n    float dr = cr - fr;\n    float a = dx * dx + dy * dy - dr * dr;\n    float b = -2.0 * (y * dy + x * dx + fr * dr);\n    float c = x * x + y * y - fr * fr;\n    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));\n  } else {\n    // linear gradient\n    vec2 v1 = gl_FragCoord.xy - gv1.xy;\n    vec2 v2 = gv2.xy - gv1.xy;\n    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);\n  }\n\n  vec4 colors[8];\n  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);\n  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);\n  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);\n  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);\n  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);\n  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);\n  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);\n  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);\n  \n  float steps[8];\n  steps[0] = colorSteps[0];\n  steps[1] = colorSteps[5];\n  steps[2] = colorSteps[10];\n  steps[3] = colorSteps[15];\n  steps[4] = colorSteps[20];\n  steps[5] = colorSteps[25];\n  steps[6] = colorSteps[30];\n  steps[7] = colorSteps[35];\n\n  color = colors[0];\n  for (int i = 1; i < 8; i++) {\n    if (steps[i] < 0.0 || steps[i] > 1.0) {\n      break;\n    }\n    if(steps[i] == steps[i - 1]) {\n      color = colors[i];\n    } else {\n      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));\n    }\n    if (steps[i] >= t) {\n      break;\n    }\n  }\n}\n#endif\n\nvoid transformColor(inout vec4 color, in float colorMatrix[20]) {\n  float r = color.r, g = color.g, b = color.b, a = color.a;\n  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];\n  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];\n  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];\n  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];\n}\n\n#ifdef CLOUDFILTER\nvoid buildCloudColor(inout float colorCloudMatrix[20]) {\n  colorCloudMatrix[0] = colorCloud0[0];\n  colorCloudMatrix[1] = colorCloud1[0];\n  colorCloudMatrix[2] = colorCloud2[0];\n  colorCloudMatrix[3] = colorCloud3[0];\n  colorCloudMatrix[4] = colorCloud4[0];\n\n  colorCloudMatrix[5] = colorCloud0[1];\n  colorCloudMatrix[6] = colorCloud1[1];\n  colorCloudMatrix[7] = colorCloud2[1];\n  colorCloudMatrix[8] = colorCloud3[1];\n  colorCloudMatrix[9] = colorCloud4[1];\n\n  colorCloudMatrix[10] = colorCloud0[2];\n  colorCloudMatrix[11] = colorCloud1[2];\n  colorCloudMatrix[12] = colorCloud2[2];\n  colorCloudMatrix[13] = colorCloud3[2];\n  colorCloudMatrix[14] = colorCloud4[2];\n\n  colorCloudMatrix[15] = colorCloud0[3];\n  colorCloudMatrix[16] = colorCloud1[3];\n  colorCloudMatrix[17] = colorCloud2[3];\n  colorCloudMatrix[18] = colorCloud3[3];\n  colorCloudMatrix[19] = colorCloud4[3];\n}\n#endif\n\nvoid main() {\n  vec4 color = vColor;\n  float opacity = abs(flagBackground);\n\n#ifdef GRADIENT\n  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {\n    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);\n  }\n#endif\n\n  if(opacity < 1.0) {\n    color.a *= opacity;\n  }\n\n#ifdef TEXTURE\n  if(flagBackground > 0.0) {\n    vec3 texCoord = vTextureCoord;\n\n    if(texCoord.z == 1.0) {\n      texCoord = fract(texCoord);\n    }\n\n    if(texCoord.x <= 1.0 && texCoord.x >= 0.0\n      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {\n      if(vSourceRect.z > 0.0) {\n        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;\n        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);\n      }\n      if(frameIndex < 0.0) {\n        vec4 texColor = texture2D(u_texSampler, texCoord.xy);\n        color = mix(color, texColor, texColor.a);\n      } else {\n        int index = int(floor(clamp(0.0, 11.0, frameIndex)));\n        vec4 texColor;\n        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);\n        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);\n        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);\n        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);\n        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);\n        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);\n        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);\n        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);\n        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);\n        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);\n        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);\n        else texColor = texture2D(u_texFrame11, texCoord.xy);\n        float alpha = texColor.a;\n        if(opacity < 1.0) {\n          texColor.a *= opacity;\n          alpha *= mix(0.465, 1.0, opacity);\n        }\n        // color = mix(color, texColor, texColor.a);\n        color.rgb = mix(color.rgb, texColor.rgb, alpha);\n        // color.rgb = mix(texColor.rgb, color.rgb, color.a);\n        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));\n        color.a = texColor.a + (1.0 - texColor.a) * color.a;\n      }\n    }\n  }\n#endif\n\n#ifdef FILTER\n  if(u_filterFlag > 0) {\n    transformColor(color, u_colorMatrix);\n  }\n#endif\n\n#ifdef CLOUDFILTER\n  float colorCloudMatrix[20];\n  buildCloudColor(colorCloudMatrix);\n  transformColor(color, colorCloudMatrix);\n#endif\n\n#ifdef CLIPPATH\n  float clip = texture2D(u_clipSampler, vClipUV).r;\n  color *= clip;\n#endif\n\n  gl_FragColor = color;\n}";/***/}]));});});unwrapExports(mesh);

  var arrayWithHoles = createCommonjsModule(function (module) {
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(arrayWithHoles);

  var iterableToArrayLimit = createCommonjsModule(function (module) {
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(iterableToArrayLimit);

  var arrayLikeToArray = createCommonjsModule(function (module) {
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }

    module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(arrayLikeToArray);

  var unsupportedIterableToArray = createCommonjsModule(function (module) {
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
    }

    module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(unsupportedIterableToArray);

  var nonIterableRest = createCommonjsModule(function (module) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(nonIterableRest);

  var slicedToArray$1 = createCommonjsModule(function (module) {
    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }

    module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(slicedToArray$1);

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  var RANDOM = Math.random;
  /**
   * Sets the type of array used when creating new vectors and matrices
   *
   * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
   */

  function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
  }
  var degree = Math.PI / 180;
  /**
   * Convert Degree To Radian
   *
   * @param {Number} a Angle in Degrees
   */

  function toRadian(a) {
    return a * degree;
  }
  /**
   * Tests whether or not the arguments have approximately the same value, within an absolute
   * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
   * than or equal to 1.0, and a relative tolerance is used for larger values)
   *
   * @param {Number} a The first number to test.
   * @param {Number} b The second number to test.
   * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
   */

  function equals$a(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
  }
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  var common = /*#__PURE__*/Object.freeze({
    __proto__: null,
    EPSILON: EPSILON,
    get ARRAY_TYPE () { return ARRAY_TYPE; },
    RANDOM: RANDOM,
    setMatrixArrayType: setMatrixArrayType,
    toRadian: toRadian,
    equals: equals$a
  });

  /**
   * 2x2 Matrix
   * @module mat2
   */

  /**
   * Creates a new identity mat2
   *
   * @returns {mat2} a new 2x2 matrix
   */

  function create$8() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat2} a matrix to clone
   * @returns {mat2} a new 2x2 matrix
   */

  function clone$8(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Copy the values from one mat2 to another
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */

  function copy$a(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set a mat2 to the identity matrix
   *
   * @param {mat2} out the receiving matrix
   * @returns {mat2} out
   */

  function identity$5(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Create a new mat2 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out A new 2x2 matrix
   */

  function fromValues$8(m00, m01, m10, m11) {
    var out = new ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Set the components of a mat2 to the given values
   *
   * @param {mat2} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out
   */

  function set$8(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Transpose the values of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */

  function transpose$2(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
      var a1 = a[1];
      out[1] = a[2];
      out[2] = a1;
    } else {
      out[0] = a[0];
      out[1] = a[2];
      out[2] = a[1];
      out[3] = a[3];
    }

    return out;
  }
  /**
   * Inverts a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */

  function invert$5(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3]; // Calculate the determinant

    var det = a0 * a3 - a2 * a1;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the source matrix
   * @returns {mat2} out
   */

  function adjoint$2(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
  }
  /**
   * Calculates the determinant of a mat2
   *
   * @param {ReadonlyMat2} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$3(a) {
    return a[0] * a[3] - a[2] * a[1];
  }
  /**
   * Multiplies two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @returns {mat2} out
   */

  function multiply$8(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
  }
  /**
   * Rotates a mat2 by the given angle
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function rotate$4(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
  }
  /**
   * Scales the mat2 by the dimensions in the given vec2
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the matrix to rotate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat2} out
   **/

  function scale$8(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function fromRotation$4(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat2} out
   */

  function fromScaling$3(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2
   *
   * @param {ReadonlyMat2} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$8(a) {
    return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  /**
   * Returns Frobenius norm of a mat2
   *
   * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$3(a) {
    return Math.hypot(a[0], a[1], a[2], a[3]);
  }
  /**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @param {ReadonlyMat2} L the lower triangular matrix
   * @param {ReadonlyMat2} D the diagonal matrix
   * @param {ReadonlyMat2} U the upper triangular matrix
   * @param {ReadonlyMat2} a the input matrix to factorize
   */

  function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [L, D, U];
  }
  /**
   * Adds two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @returns {mat2} out
   */

  function add$8(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @returns {mat2} out
   */

  function subtract$6(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat2} a The first matrix.
   * @param {ReadonlyMat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat2} a The first matrix.
   * @param {ReadonlyMat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$9(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2} out the receiving matrix
   * @param {ReadonlyMat2} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2} out
   */

  function multiplyScalar$3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two mat2's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2} out the receiving vector
   * @param {ReadonlyMat2} a the first operand
   * @param {ReadonlyMat2} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2} out
   */

  function multiplyScalarAndAdd$3(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Alias for {@link mat2.multiply}
   * @function
   */

  var mul$8 = multiply$8;
  /**
   * Alias for {@link mat2.subtract}
   * @function
   */

  var sub$7 = subtract$6;

  var mat2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$8,
    clone: clone$8,
    copy: copy$a,
    identity: identity$5,
    fromValues: fromValues$8,
    set: set$8,
    transpose: transpose$2,
    invert: invert$5,
    adjoint: adjoint$2,
    determinant: determinant$3,
    multiply: multiply$8,
    rotate: rotate$4,
    scale: scale$8,
    fromRotation: fromRotation$4,
    fromScaling: fromScaling$3,
    str: str$8,
    frob: frob$3,
    LDU: LDU,
    add: add$8,
    subtract: subtract$6,
    exactEquals: exactEquals$8,
    equals: equals$9,
    multiplyScalar: multiplyScalar$3,
    multiplyScalarAndAdd: multiplyScalarAndAdd$3,
    mul: mul$8,
    sub: sub$7
  });

  /**
   * 2x3 Matrix
   * @module mat2d
   * @description
   * A mat2d contains six elements defined as:
   * <pre>
   * [a, b,
   *  c, d,
   *  tx, ty]
   * </pre>
   * This is a short form for the 3x3 matrix:
   * <pre>
   * [a, b, 0,
   *  c, d, 0,
   *  tx, ty, 1]
   * </pre>
   * The last column is ignored so the array is shorter and operations are faster.
   */

  /**
   * Creates a new identity mat2d
   *
   * @returns {mat2d} a new 2x3 matrix
   */

  function create$7() {
    var out = new ARRAY_TYPE(6);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[4] = 0;
      out[5] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2d initialized with values from an existing matrix
   *
   * @param {ReadonlyMat2d} a matrix to clone
   * @returns {mat2d} a new 2x3 matrix
   */

  function clone$7(a) {
    var out = new ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Copy the values from one mat2d to another
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the source matrix
   * @returns {mat2d} out
   */

  function copy$9(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Set a mat2d to the identity matrix
   *
   * @param {mat2d} out the receiving matrix
   * @returns {mat2d} out
   */

  function identity$4(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Create a new mat2d with the given values
   *
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} A new mat2d
   */

  function fromValues$7(a, b, c, d, tx, ty) {
    var out = new ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Set the components of a mat2d to the given values
   *
   * @param {mat2d} out the receiving matrix
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} out
   */

  function set$7(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Inverts a mat2d
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the source matrix
   * @returns {mat2d} out
   */

  function invert$4(out, a) {
    var aa = a[0],
        ab = a[1],
        ac = a[2],
        ad = a[3];
    var atx = a[4],
        aty = a[5];
    var det = aa * ad - ab * ac;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
  }
  /**
   * Calculates the determinant of a mat2d
   *
   * @param {ReadonlyMat2d} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$2(a) {
    return a[0] * a[3] - a[1] * a[2];
  }
  /**
   * Multiplies two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @returns {mat2d} out
   */

  function multiply$7(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
  }
  /**
   * Rotates a mat2d by the given angle
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function rotate$3(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Scales the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to translate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat2d} out
   **/

  function scale$7(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Translates the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to translate
   * @param {ReadonlyVec2} v the vec2 to translate the matrix by
   * @returns {mat2d} out
   **/

  function translate$3(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.rotate(dest, dest, rad);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function fromRotation$3(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.scale(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat2d} out
   */

  function fromScaling$2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.translate(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {ReadonlyVec2} v Translation vector
   * @returns {mat2d} out
   */

  function fromTranslation$3(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2d
   *
   * @param {ReadonlyMat2d} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$7(a) {
    return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
  }
  /**
   * Returns Frobenius norm of a mat2d
   *
   * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$2(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
  }
  /**
   * Adds two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @returns {mat2d} out
   */

  function add$7(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @returns {mat2d} out
   */

  function subtract$5(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2d} out
   */

  function multiplyScalar$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
  }
  /**
   * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2d} out the receiving vector
   * @param {ReadonlyMat2d} a the first operand
   * @param {ReadonlyMat2d} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2d} out
   */

  function multiplyScalarAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat2d} a The first matrix.
   * @param {ReadonlyMat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$7(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat2d} a The first matrix.
   * @param {ReadonlyMat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$8(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
  }
  /**
   * Alias for {@link mat2d.multiply}
   * @function
   */

  var mul$7 = multiply$7;
  /**
   * Alias for {@link mat2d.subtract}
   * @function
   */

  var sub$6 = subtract$5;

  var mat2d = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$7,
    clone: clone$7,
    copy: copy$9,
    identity: identity$4,
    fromValues: fromValues$7,
    set: set$7,
    invert: invert$4,
    determinant: determinant$2,
    multiply: multiply$7,
    rotate: rotate$3,
    scale: scale$7,
    translate: translate$3,
    fromRotation: fromRotation$3,
    fromScaling: fromScaling$2,
    fromTranslation: fromTranslation$3,
    str: str$7,
    frob: frob$2,
    add: add$7,
    subtract: subtract$5,
    multiplyScalar: multiplyScalar$2,
    multiplyScalarAndAdd: multiplyScalarAndAdd$2,
    exactEquals: exactEquals$7,
    equals: equals$8,
    mul: mul$7,
    sub: sub$6
  });

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$6() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {ReadonlyMat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Creates a new mat3 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat3} a matrix to clone
   * @returns {mat3} a new 3x3 matrix
   */

  function clone$6(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function copy$8(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */

  function fromValues$6(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */

  function set$6(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */

  function identity$3(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function transpose$1(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }

    return out;
  }
  /**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function invert$3(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function adjoint$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  /**
   * Calculates the determinant of a mat3
   *
   * @param {ReadonlyMat3} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$1(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function multiply$6(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  /**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to translate
   * @param {ReadonlyVec2} v vector to translate by
   * @returns {mat3} out
   */

  function translate$2(out, a, v) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        x = v[0],
        y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  /**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function rotate$2(out, a, rad) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  /**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/

  function scale$6(out, a, v) {
    var x = v[0],
        y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Translation vector
   * @returns {mat3} out
   */

  function fromTranslation$2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function fromRotation$2(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat3} out
   */

  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the values from a mat2d into a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to copy
   * @returns {mat3} out
   **/

  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  /**
   * Calculates a 3x3 matrix from the given quaternion
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat3} out
   */

  function fromQuat$1(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  /**
   * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
   *
   * @returns {mat3} out
   */

  function normalFromMat4(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   *
   * @param {mat3} out mat3 frustum matrix will be written into
   * @param {number} width Width of your gl context
   * @param {number} height Height of gl context
   * @returns {mat3} out
   */

  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat3
   *
   * @param {ReadonlyMat3} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$6(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
  /**
   * Returns Frobenius norm of a mat3
   *
   * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$1(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  /**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function add$6(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function subtract$4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat3} out
   */

  function multiplyScalar$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  /**
   * Adds two mat3's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat3} out the receiving vector
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat3} out
   */

  function multiplyScalarAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat3} a The first matrix.
   * @param {ReadonlyMat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$6(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat3} a The first matrix.
   * @param {ReadonlyMat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$7(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7],
        a8 = a[8];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
  }
  /**
   * Alias for {@link mat3.multiply}
   * @function
   */

  var mul$6 = multiply$6;
  /**
   * Alias for {@link mat3.subtract}
   * @function
   */

  var sub$5 = subtract$4;

  var mat3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$6,
    fromMat4: fromMat4$1,
    clone: clone$6,
    copy: copy$8,
    fromValues: fromValues$6,
    set: set$6,
    identity: identity$3,
    transpose: transpose$1,
    invert: invert$3,
    adjoint: adjoint$1,
    determinant: determinant$1,
    multiply: multiply$6,
    translate: translate$2,
    rotate: rotate$2,
    scale: scale$6,
    fromTranslation: fromTranslation$2,
    fromRotation: fromRotation$2,
    fromScaling: fromScaling$1,
    fromMat2d: fromMat2d,
    fromQuat: fromQuat$1,
    normalFromMat4: normalFromMat4,
    projection: projection,
    str: str$6,
    frob: frob$1,
    add: add$6,
    subtract: subtract$4,
    multiplyScalar: multiplyScalar$1,
    multiplyScalarAndAdd: multiplyScalarAndAdd$1,
    exactEquals: exactEquals$6,
    equals: equals$7,
    mul: mul$6,
    sub: sub$5
  });

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$5() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone$5(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function copy$7(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */

  function fromValues$5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set$5(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function invert$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {ReadonlyMat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function multiply$5(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to translate
   * @param {ReadonlyVec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate$1(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {ReadonlyVec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$5(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate$1(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX$3(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY$3(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ$3(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation$1(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation$1(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {ReadonlyQuat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */

  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }

    fromRotationTranslation$1(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation$1(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */

  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Alias for {@link mat4.perspectiveNO}
   * @function
   */

  var perspective = perspectiveNO;
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspectiveZO(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }

    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Alias for {@link mat4.orthoNO}
   * @function
   */

  var ortho = orthoNO;
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function orthoZO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity$2(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat4
   *
   * @param {ReadonlyMat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$5(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  }
  /**
   * Returns Frobenius norm of a mat4
   *
   * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function add$5(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function subtract$3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */

  function multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$5(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$6(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul$5 = multiply$5;
  /**
   * Alias for {@link mat4.subtract}
   * @function
   */

  var sub$4 = subtract$3;

  var mat4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$5,
    clone: clone$5,
    copy: copy$7,
    fromValues: fromValues$5,
    set: set$5,
    identity: identity$2,
    transpose: transpose,
    invert: invert$2,
    adjoint: adjoint,
    determinant: determinant,
    multiply: multiply$5,
    translate: translate$1,
    scale: scale$5,
    rotate: rotate$1,
    rotateX: rotateX$3,
    rotateY: rotateY$3,
    rotateZ: rotateZ$3,
    fromTranslation: fromTranslation$1,
    fromScaling: fromScaling,
    fromRotation: fromRotation$1,
    fromXRotation: fromXRotation,
    fromYRotation: fromYRotation,
    fromZRotation: fromZRotation,
    fromRotationTranslation: fromRotationTranslation$1,
    fromQuat2: fromQuat2,
    getTranslation: getTranslation$1,
    getScaling: getScaling,
    getRotation: getRotation,
    fromRotationTranslationScale: fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
    fromQuat: fromQuat,
    frustum: frustum,
    perspectiveNO: perspectiveNO,
    perspective: perspective,
    perspectiveZO: perspectiveZO,
    perspectiveFromFieldOfView: perspectiveFromFieldOfView,
    orthoNO: orthoNO,
    ortho: ortho,
    orthoZO: orthoZO,
    lookAt: lookAt,
    targetTo: targetTo,
    str: str$5,
    frob: frob,
    add: add$5,
    subtract: subtract$3,
    multiplyScalar: multiplyScalar,
    multiplyScalarAndAdd: multiplyScalarAndAdd,
    exactEquals: exactEquals$5,
    equals: equals$6,
    mul: mul$5,
    sub: sub$4
  });

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$4() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   *
   * @param {ReadonlyVec3} a vector to clone
   * @returns {vec3} a new 3D vector
   */

  function clone$4(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$4(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues$4(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the source vector
   * @returns {vec3} out
   */

  function copy$6(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$4(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function add$4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function multiply$4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Divides two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function divide$4(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Math.ceil the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to ceil
   * @returns {vec3} out
   */

  function ceil$3(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  /**
   * Math.floor the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to floor
   * @returns {vec3} out
   */

  function floor$3(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  /**
   * Returns the minimum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function min$4(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  /**
   * Returns the maximum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function max$3(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  /**
   * Math.round the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to round
   * @returns {vec3} out
   */

  function round$2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */

  function scaleAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Calculates the squared length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$4(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Negates the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to negate
   * @returns {vec3} out
   */

  function negate$2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to invert
   * @returns {vec3} out
   */

  function inverse$2(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize$4(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$5(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function cross$3(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp$4(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Performs a hermite interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {ReadonlyVec3} c the third operand
   * @param {ReadonlyVec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Performs a bezier interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {ReadonlyVec3} c the third operand
   * @param {ReadonlyVec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec3} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec3} out
   */

  function random$3(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    var z = RANDOM() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4$2(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyQuat} q quaternion to transform with
   * @returns {vec3} out
   */

  function transformQuat$1(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3];
    var x = a[0],
        y = a[1],
        z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);

    var uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

    var uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);

    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param {vec3} out The receiving vec3
   * @param {ReadonlyVec3} a The vec3 point to rotate
   * @param {ReadonlyVec3} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec3} out
   */

  function rotateX$2(out, a, b, rad) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param {vec3} out The receiving vec3
   * @param {ReadonlyVec3} a The vec3 point to rotate
   * @param {ReadonlyVec3} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec3} out
   */

  function rotateY$2(out, a, b, rad) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param {vec3} out The receiving vec3
   * @param {ReadonlyVec3} a The vec3 point to rotate
   * @param {ReadonlyVec3} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec3} out
   */

  function rotateZ$2(out, a, b, rad) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2]; //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @param {ReadonlyVec3} a The first operand
   * @param {ReadonlyVec3} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle$2(a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        bx = b[0],
        by = b[1],
        bz = b[2],
        mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
        mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
        mag = mag1 * mag2,
        cosine = mag && dot$5(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  /**
   * Set the components of a vec3 to zero
   *
   * @param {vec3} out the receiving vector
   * @returns {vec3} out
   */

  function zero$2(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {ReadonlyVec3} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$4(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$5(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.subtract}
   * @function
   */

  var sub$3 = subtract$2;
  /**
   * Alias for {@link vec3.multiply}
   * @function
   */

  var mul$4 = multiply$4;
  /**
   * Alias for {@link vec3.divide}
   * @function
   */

  var div$3 = divide$4;
  /**
   * Alias for {@link vec3.distance}
   * @function
   */

  var dist$2 = distance$2;
  /**
   * Alias for {@link vec3.squaredDistance}
   * @function
   */

  var sqrDist$2 = squaredDistance$2;
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len$4 = length$4;
  /**
   * Alias for {@link vec3.squaredLength}
   * @function
   */

  var sqrLen$4 = squaredLength$4;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$2 = function () {
    var vec = create$4();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  var vec3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$4,
    clone: clone$4,
    length: length$4,
    fromValues: fromValues$4,
    copy: copy$6,
    set: set$4,
    add: add$4,
    subtract: subtract$2,
    multiply: multiply$4,
    divide: divide$4,
    ceil: ceil$3,
    floor: floor$3,
    min: min$4,
    max: max$3,
    round: round$2,
    scale: scale$4,
    scaleAndAdd: scaleAndAdd$2,
    distance: distance$2,
    squaredDistance: squaredDistance$2,
    squaredLength: squaredLength$4,
    negate: negate$2,
    inverse: inverse$2,
    normalize: normalize$4,
    dot: dot$5,
    cross: cross$3,
    lerp: lerp$4,
    hermite: hermite,
    bezier: bezier,
    random: random$3,
    transformMat4: transformMat4$2,
    transformMat3: transformMat3$1,
    transformQuat: transformQuat$1,
    rotateX: rotateX$2,
    rotateY: rotateY$2,
    rotateZ: rotateZ$2,
    angle: angle$2,
    zero: zero$2,
    str: str$4,
    exactEquals: exactEquals$4,
    equals: equals$5,
    sub: sub$3,
    mul: mul$4,
    div: div$3,
    dist: dist$2,
    sqrDist: sqrDist$2,
    len: len$4,
    sqrLen: sqrLen$4,
    forEach: forEach$2
  });

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$3() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec4 initialized with values from an existing vector
   *
   * @param {ReadonlyVec4} a vector to clone
   * @returns {vec4} a new 4D vector
   */

  function clone$3(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */

  function fromValues$3(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the source vector
   * @returns {vec4} out
   */

  function copy$5(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to the given values
   *
   * @param {vec4} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} out
   */

  function set$3(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Adds two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function add$3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Multiplies two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function multiply$3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  /**
   * Divides two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function divide$3(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  /**
   * Math.ceil the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to ceil
   * @returns {vec4} out
   */

  function ceil$2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  /**
   * Math.floor the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to floor
   * @returns {vec4} out
   */

  function floor$2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  /**
   * Returns the minimum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function min$3(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  /**
   * Returns the maximum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function max$2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  /**
   * Math.round the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to round
   * @returns {vec4} out
   */

  function round$1(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  /**
   * Scales a vec4 by a scalar number
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec4} out
   */

  function scale$3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two vec4's after scaling the second operand by a scalar value
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec4} out
   */

  function scaleAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Calculates the squared euclidian distance between two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Calculates the length of a vec4
   *
   * @param {ReadonlyVec4} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$3(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Calculates the squared length of a vec4
   *
   * @param {ReadonlyVec4} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$3(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Negates the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to negate
   * @returns {vec4} out
   */

  function negate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to invert
   * @returns {vec4} out
   */

  function inverse$1(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$3(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   *
   * @param {ReadonlyVec4} result the receiving vector
   * @param {ReadonlyVec4} U the first vector
   * @param {ReadonlyVec4} V the second vector
   * @param {ReadonlyVec4} W the third vector
   * @returns {vec4} result
   */

  function cross$2(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0],
        B = v[0] * w[2] - v[2] * w[0],
        C = v[0] * w[3] - v[3] * w[0],
        D = v[1] * w[2] - v[2] * w[1],
        E = v[1] * w[3] - v[3] * w[1],
        F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec4} out
   */

  function lerp$3(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec4} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec4} out
   */

  function random$2(out, scale) {
    scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;

    var v1, v2, v3, v4;
    var s1, s2;

    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);

    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);

    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale * v1;
    out[1] = scale * v2;
    out[2] = scale * v3 * d;
    out[3] = scale * v4 * d;
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Transforms the vec4 with a quat
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyQuat} q quaternion to transform with
   * @returns {vec4} out
   */

  function transformQuat(out, a, q) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3]; // calculate quat * vec

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to zero
   *
   * @param {vec4} out the receiving vector
   * @returns {vec4} out
   */

  function zero$1(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {ReadonlyVec4} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$3(a) {
    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec4} a The first vector.
   * @param {ReadonlyVec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec4} a The first vector.
   * @param {ReadonlyVec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$4(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Alias for {@link vec4.subtract}
   * @function
   */

  var sub$2 = subtract$1;
  /**
   * Alias for {@link vec4.multiply}
   * @function
   */

  var mul$3 = multiply$3;
  /**
   * Alias for {@link vec4.divide}
   * @function
   */

  var div$2 = divide$3;
  /**
   * Alias for {@link vec4.distance}
   * @function
   */

  var dist$1 = distance$1;
  /**
   * Alias for {@link vec4.squaredDistance}
   * @function
   */

  var sqrDist$1 = squaredDistance$1;
  /**
   * Alias for {@link vec4.length}
   * @function
   */

  var len$3 = length$3;
  /**
   * Alias for {@link vec4.squaredLength}
   * @function
   */

  var sqrLen$3 = squaredLength$3;
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$3();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  var vec4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$3,
    clone: clone$3,
    fromValues: fromValues$3,
    copy: copy$5,
    set: set$3,
    add: add$3,
    subtract: subtract$1,
    multiply: multiply$3,
    divide: divide$3,
    ceil: ceil$2,
    floor: floor$2,
    min: min$3,
    max: max$2,
    round: round$1,
    scale: scale$3,
    scaleAndAdd: scaleAndAdd$1,
    distance: distance$1,
    squaredDistance: squaredDistance$1,
    length: length$3,
    squaredLength: squaredLength$3,
    negate: negate$1,
    inverse: inverse$1,
    normalize: normalize$3,
    dot: dot$4,
    cross: cross$2,
    lerp: lerp$3,
    random: random$2,
    transformMat4: transformMat4$1,
    transformQuat: transformQuat,
    zero: zero$1,
    str: str$3,
    exactEquals: exactEquals$3,
    equals: equals$4,
    sub: sub$2,
    mul: mul$3,
    div: div$2,
    dist: dist$1,
    sqrDist: sqrDist$1,
    len: len$3,
    sqrLen: sqrLen$3,
    forEach: forEach$1
  });

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$2() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Set a quat to the identity quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function identity$1(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyVec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {ReadonlyQuat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */

  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      // If s is zero, return any axis (no rotation - axis does not matter)
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }

    return rad;
  }
  /**
   * Gets the angular distance between two unit quaternions
   *
   * @param  {ReadonlyQuat} a     Origin unit quaternion
   * @param  {ReadonlyQuat} b     Destination unit quaternion
   * @return {Number}     Angle, in radians, between the two quaternions
   */

  function getAngle(a, b) {
    var dotproduct = dot$3(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {quat} out
   */

  function multiply$2(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the X axis
   *
   * @param {quat} out quat receiving operation result
   * @param {ReadonlyQuat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateX$1(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Y axis
   *
   * @param {quat} out quat receiving operation result
   * @param {ReadonlyQuat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateY$1(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var by = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Z axis
   *
   * @param {quat} out quat receiving operation result
   * @param {ReadonlyQuat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateZ$1(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bz = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate W component of
   * @returns {quat} out
   */

  function calculateW(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
  }
  /**
   * Calculate the exponential of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate the exponential of
   * @returns {quat} out
   */

  function exp(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var et = Math.exp(w);
    var s = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x * s;
    out[1] = y * s;
    out[2] = z * s;
    out[3] = et * Math.cos(r);
    return out;
  }
  /**
   * Calculate the natural logarithm of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate the exponential of
   * @returns {quat} out
   */

  function ln(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x * t;
    out[1] = y * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
    return out;
  }
  /**
   * Calculate the scalar power of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate the exponential of
   * @param {Number} b amount to scale the quaternion by
   * @returns {quat} out
   */

  function pow(out, a, b) {
    ln(out, a);
    scale$2(out, out, b);
    exp(out, out);
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Generates a random unit quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function random$1(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
    return out;
  }
  /**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate inverse of
   * @returns {quat} out
   */

  function invert$1(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate conjugate of
   * @returns {quat} out
   */

  function conjugate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyMat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Returns a string representation of a quatenion
   *
   * @param {ReadonlyQuat} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$2(a) {
    return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {ReadonlyQuat} a quaternion to clone
   * @returns {quat} a new quaternion
   * @function
   */

  var clone$2 = clone$3;
  /**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */

  var fromValues$2 = fromValues$3;
  /**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the source quaternion
   * @returns {quat} out
   * @function
   */

  var copy$4 = copy$5;
  /**
   * Set the components of a quat to the given values
   *
   * @param {quat} out the receiving quaternion
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} out
   * @function
   */

  var set$2 = set$3;
  /**
   * Adds two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {quat} out
   * @function
   */

  var add$2 = add$3;
  /**
   * Alias for {@link quat.multiply}
   * @function
   */

  var mul$2 = multiply$2;
  /**
   * Scales a quat by a scalar number
   *
   * @param {quat} out the receiving vector
   * @param {ReadonlyQuat} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {quat} out
   * @function
   */

  var scale$2 = scale$3;
  /**
   * Calculates the dot product of two quat's
   *
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$3 = dot$4;
  /**
   * Performs a linear interpolation between two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   * @function
   */

  var lerp$2 = lerp$3;
  /**
   * Calculates the length of a quat
   *
   * @param {ReadonlyQuat} a vector to calculate length of
   * @returns {Number} length of a
   */

  var length$2 = length$3;
  /**
   * Alias for {@link quat.length}
   * @function
   */

  var len$2 = length$2;
  /**
   * Calculates the squared length of a quat
   *
   * @param {ReadonlyQuat} a vector to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$2 = squaredLength$3;
  /**
   * Alias for {@link quat.squaredLength}
   * @function
   */

  var sqrLen$2 = squaredLength$2;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$3;
  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyQuat} a The first quaternion.
   * @param {ReadonlyQuat} b The second quaternion.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var exactEquals$2 = exactEquals$3;
  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   *
   * @param {ReadonlyQuat} a The first vector.
   * @param {ReadonlyQuat} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var equals$3 = equals$4;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {ReadonlyVec3} a the initial vector
   * @param {ReadonlyVec3} b the destination vector
   * @returns {quat} out
   */

  var rotationTo = function () {
    var tmpvec3 = create$4();
    var xUnitVec3 = fromValues$4(1, 0, 0);
    var yUnitVec3 = fromValues$4(0, 1, 0);
    return function (out, a, b) {
      var dot = dot$5(a, b);

      if (dot < -0.999999) {
        cross$3(tmpvec3, xUnitVec3, a);
        if (len$4(tmpvec3) < 0.000001) cross$3(tmpvec3, yUnitVec3, a);
        normalize$4(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross$3(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot;
        return normalize$2(out, out);
      }
    };
  }();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {ReadonlyQuat} c the third operand
   * @param {ReadonlyQuat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  var sqlerp = function () {
    var temp1 = create$2();
    var temp2 = create$2();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {ReadonlyVec3} view  the vector representing the viewing direction
   * @param {ReadonlyVec3} right the vector representing the local "right" direction
   * @param {ReadonlyVec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  var setAxes = function () {
    var matr = create$6();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  }();

  var quat = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$2,
    identity: identity$1,
    setAxisAngle: setAxisAngle,
    getAxisAngle: getAxisAngle,
    getAngle: getAngle,
    multiply: multiply$2,
    rotateX: rotateX$1,
    rotateY: rotateY$1,
    rotateZ: rotateZ$1,
    calculateW: calculateW,
    exp: exp,
    ln: ln,
    pow: pow,
    slerp: slerp,
    random: random$1,
    invert: invert$1,
    conjugate: conjugate$1,
    fromMat3: fromMat3,
    fromEuler: fromEuler,
    str: str$2,
    clone: clone$2,
    fromValues: fromValues$2,
    copy: copy$4,
    set: set$2,
    add: add$2,
    mul: mul$2,
    scale: scale$2,
    dot: dot$3,
    lerp: lerp$2,
    length: length$2,
    len: len$2,
    squaredLength: squaredLength$2,
    sqrLen: sqrLen$2,
    normalize: normalize$2,
    exactEquals: exactEquals$2,
    equals: equals$3,
    rotationTo: rotationTo,
    sqlerp: sqlerp,
    setAxes: setAxes
  });

  /**
   * Dual Quaternion<br>
   * Format: [real, dual]<br>
   * Quaternion format: XYZW<br>
   * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
   * @module quat2
   */

  /**
   * Creates a new identity dual quat
   *
   * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
   */

  function create$1() {
    var dq = new ARRAY_TYPE(8);

    if (ARRAY_TYPE != Float32Array) {
      dq[0] = 0;
      dq[1] = 0;
      dq[2] = 0;
      dq[4] = 0;
      dq[5] = 0;
      dq[6] = 0;
      dq[7] = 0;
    }

    dq[3] = 1;
    return dq;
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {ReadonlyQuat2} a dual quaternion to clone
   * @returns {quat2} new dual quaternion
   * @function
   */

  function clone$1(a) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
  }
  /**
   * Creates a new dual quat initialized with the given values
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromValues$1(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
  }
  /**
   * Creates a new dual quat from the given values (quat and translation)
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component (translation)
   * @param {Number} y2 Y component (translation)
   * @param {Number} z2 Z component (translation)
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5,
        ay = y2 * 0.5,
        az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
  }
  /**
   * Creates a dual quat from a quaternion and a translation
   *
   * @param {ReadonlyQuat2} dual quaternion receiving operation result
   * @param {ReadonlyQuat} q a normalized quaternion
   * @param {ReadonlyVec3} t tranlation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotationTranslation(out, q, t) {
    var ax = t[0] * 0.5,
        ay = t[1] * 0.5,
        az = t[2] * 0.5,
        bx = q[0],
        by = q[1],
        bz = q[2],
        bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Creates a dual quat from a translation
   *
   * @param {ReadonlyQuat2} dual quaternion receiving operation result
   * @param {ReadonlyVec3} t translation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromTranslation(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a dual quat from a quaternion
   *
   * @param {ReadonlyQuat2} dual quaternion receiving operation result
   * @param {ReadonlyQuat} q the quaternion
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotation(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a new dual quat from a matrix (4x4)
   *
   * @param {quat2} out the dual quaternion
   * @param {ReadonlyMat4} a the matrix
   * @returns {quat2} dual quat receiving operation result
   * @function
   */

  function fromMat4(out, a) {
    //TODO Optimize this
    var outer = create$2();
    getRotation(outer, a);
    var t = new ARRAY_TYPE(3);
    getTranslation$1(t, a);
    fromRotationTranslation(out, outer, t);
    return out;
  }
  /**
   * Copy the values from one dual quat to another
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the source dual quaternion
   * @returns {quat2} out
   * @function
   */

  function copy$3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Set a dual quat to the identity dual quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @returns {quat2} out
   */

  function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Set the components of a dual quat to the given values
   *
   * @param {quat2} out the receiving quaternion
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} out
   * @function
   */

  function set$1(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
  }
  /**
   * Gets the real part of a dual quat
   * @param  {quat} out real part
   * @param  {ReadonlyQuat2} a Dual Quaternion
   * @return {quat} real part
   */

  var getReal = copy$4;
  /**
   * Gets the dual part of a dual quat
   * @param  {quat} out dual part
   * @param  {ReadonlyQuat2} a Dual Quaternion
   * @return {quat} dual part
   */

  function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
  }
  /**
   * Set the real component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {ReadonlyQuat} q a quaternion representing the real part
   * @returns {quat2} out
   * @function
   */

  var setReal = copy$4;
  /**
   * Set the dual component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {ReadonlyQuat} q a quaternion representing the dual part
   * @returns {quat2} out
   * @function
   */

  function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
  }
  /**
   * Gets the translation of a normalized dual quat
   * @param  {vec3} out translation
   * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
   * @return {vec3} translation
   */

  function getTranslation(out, a) {
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
  }
  /**
   * Translates a dual quat by the given vector
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to translate
   * @param {ReadonlyVec3} v vector to translate by
   * @returns {quat2} out
   */

  function translate(out, a, v) {
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3],
        bx1 = v[0] * 0.5,
        by1 = v[1] * 0.5,
        bz1 = v[2] * 0.5,
        ax2 = a[4],
        ay2 = a[5],
        az2 = a[6],
        aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
  }
  /**
   * Rotates a dual quat around the X axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateX(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateX$1(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Y axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateY(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateY$1(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Z axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateZ(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateZ$1(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (a * q)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {ReadonlyQuat} q quaternion to rotate by
   * @returns {quat2} out
   */

  function rotateByQuatAppend(out, a, q) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (q * a)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat} q quaternion to rotate by
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @returns {quat2} out
   */

  function rotateByQuatPrepend(out, q, a) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        bx = a[0],
        by = a[1],
        bz = a[2],
        bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
  }
  /**
   * Rotates a dual quat around a given axis. Does the normalisation automatically
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the dual quaternion to rotate
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @param {Number} rad how far the rotation should be
   * @returns {quat2} out
   */

  function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < EPSILON) {
      return copy$3(out, a);
    }

    var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Adds two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @returns {quat2} out
   * @function
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
  }
  /**
   * Multiplies two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @returns {quat2} out
   */

  function multiply$1(out, a, b) {
    var ax0 = a[0],
        ay0 = a[1],
        az0 = a[2],
        aw0 = a[3],
        bx1 = b[4],
        by1 = b[5],
        bz1 = b[6],
        bw1 = b[7],
        ax1 = a[4],
        ay1 = a[5],
        az1 = a[6],
        aw1 = a[7],
        bx0 = b[0],
        by0 = b[1],
        bz0 = b[2],
        bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
  }
  /**
   * Alias for {@link quat2.multiply}
   * @function
   */

  var mul$1 = multiply$1;
  /**
   * Scales a dual quat by a scalar number
   *
   * @param {quat2} out the receiving dual quat
   * @param {ReadonlyQuat2} a the dual quat to scale
   * @param {Number} b amount to scale the dual quat by
   * @returns {quat2} out
   * @function
   */

  function scale$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
  }
  /**
   * Calculates the dot product of two dual quat's (The dot product of the real parts)
   *
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$2 = dot$3;
  /**
   * Performs a linear interpolation between two dual quats's
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
   *
   * @param {quat2} out the receiving dual quat
   * @param {ReadonlyQuat2} a the first operand
   * @param {ReadonlyQuat2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat2} out
   */

  function lerp$1(out, a, b, t) {
    var mt = 1 - t;
    if (dot$2(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
  }
  /**
   * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a dual quat to calculate inverse of
   * @returns {quat2} out
   */

  function invert(out, a) {
    var sqlen = squaredLength$1(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
  }
  /**
   * Calculates the conjugate of a dual quat
   * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
   *
   * @param {quat2} out the receiving quaternion
   * @param {ReadonlyQuat2} a quat to calculate conjugate of
   * @returns {quat2} out
   */

  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Calculates the length of a dual quat
   *
   * @param {ReadonlyQuat2} a dual quat to calculate length of
   * @returns {Number} length of a
   * @function
   */

  var length$1 = length$2;
  /**
   * Alias for {@link quat2.length}
   * @function
   */

  var len$1 = length$1;
  /**
   * Calculates the squared length of a dual quat
   *
   * @param {ReadonlyQuat2} a dual quat to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$1 = squaredLength$2;
  /**
   * Alias for {@link quat2.squaredLength}
   * @function
   */

  var sqrLen$1 = squaredLength$1;
  /**
   * Normalize a dual quat
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {ReadonlyQuat2} a dual quaternion to normalize
   * @returns {quat2} out
   * @function
   */

  function normalize$1(out, a) {
    var magnitude = squaredLength$1(a);

    if (magnitude > 0) {
      magnitude = Math.sqrt(magnitude);
      var a0 = a[0] / magnitude;
      var a1 = a[1] / magnitude;
      var a2 = a[2] / magnitude;
      var a3 = a[3] / magnitude;
      var b0 = a[4];
      var b1 = a[5];
      var b2 = a[6];
      var b3 = a[7];
      var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
      out[0] = a0;
      out[1] = a1;
      out[2] = a2;
      out[3] = a3;
      out[4] = (b0 - a0 * a_dot_b) / magnitude;
      out[5] = (b1 - a1 * a_dot_b) / magnitude;
      out[6] = (b2 - a2 * a_dot_b) / magnitude;
      out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }

    return out;
  }
  /**
   * Returns a string representation of a dual quatenion
   *
   * @param {ReadonlyQuat2} a dual quaternion to represent as a string
   * @returns {String} string representation of the dual quat
   */

  function str$1(a) {
    return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
  }
  /**
   * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyQuat2} a the first dual quaternion.
   * @param {ReadonlyQuat2} b the second dual quaternion.
   * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
   */

  function exactEquals$1(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
  }
  /**
   * Returns whether or not the dual quaternions have approximately the same elements in the same position.
   *
   * @param {ReadonlyQuat2} a the first dual quat.
   * @param {ReadonlyQuat2} b the second dual quat.
   * @returns {Boolean} true if the dual quats are equal, false otherwise.
   */

  function equals$2(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
  }

  var quat2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create$1,
    clone: clone$1,
    fromValues: fromValues$1,
    fromRotationTranslationValues: fromRotationTranslationValues,
    fromRotationTranslation: fromRotationTranslation,
    fromTranslation: fromTranslation,
    fromRotation: fromRotation,
    fromMat4: fromMat4,
    copy: copy$3,
    identity: identity,
    set: set$1,
    getReal: getReal,
    getDual: getDual,
    setReal: setReal,
    setDual: setDual,
    getTranslation: getTranslation,
    translate: translate,
    rotateX: rotateX,
    rotateY: rotateY,
    rotateZ: rotateZ,
    rotateByQuatAppend: rotateByQuatAppend,
    rotateByQuatPrepend: rotateByQuatPrepend,
    rotateAroundAxis: rotateAroundAxis,
    add: add$1,
    multiply: multiply$1,
    mul: mul$1,
    scale: scale$1,
    dot: dot$2,
    lerp: lerp$1,
    invert: invert,
    conjugate: conjugate,
    length: length$1,
    len: len$1,
    squaredLength: squaredLength$1,
    sqrLen: sqrLen$1,
    normalize: normalize$1,
    str: str$1,
    exactEquals: exactEquals$1,
    equals: equals$2
  });

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec2 initialized with values from an existing vector
   *
   * @param {ReadonlyVec2} a vector to clone
   * @returns {vec2} a new 2D vector
   */

  function clone(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Creates a new vec2 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} a new 2D vector
   */

  function fromValues(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Copy the values from one vec2 to another
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the source vector
   * @returns {vec2} out
   */

  function copy$2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Set the components of a vec2 to the given values
   *
   * @param {vec2} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} out
   */

  function set(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  /**
   * Multiplies two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  /**
   * Divides two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function divide$2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  /**
   * Math.ceil the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to ceil
   * @returns {vec2} out
   */

  function ceil$1(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  /**
   * Math.floor the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to floor
   * @returns {vec2} out
   */

  function floor$1(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  /**
   * Returns the minimum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function min$2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  /**
   * Returns the maximum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function max$1(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  /**
   * Math.round the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to round
   * @returns {vec2} out
   */

  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  /**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */

  function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  /**
   * Adds two vec2's after scaling the second operand by a scalar value
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec2} out
   */

  function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the squared euclidian distance between two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x * x + y * y;
  }
  /**
   * Calculates the length of a vec2
   *
   * @param {ReadonlyVec2} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0],
        y = a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the squared length of a vec2
   *
   * @param {ReadonlyVec2} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength(a) {
    var x = a[0],
        y = a[1];
    return x * x + y * y;
  }
  /**
   * Negates the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to negate
   * @returns {vec2} out
   */

  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to invert
   * @returns {vec2} out
   */

  function inverse(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
  }
  /**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to normalize
   * @returns {vec2} out
   */

  function normalize(out, a) {
    var x = a[0],
        y = a[1];
    var len = x * x + y * y;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$1(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Computes the cross product of two vec2's
   * Note that the cross product must by definition produce a 3D vector
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec3} out
   */

  function cross$1(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec2} out
   */

  function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec2} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec2} out
   */

  function random(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat2} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2d
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat2d} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2d(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Transforms the vec2 with a mat4
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  /**
   * Rotate a 2D vector
   * @param {vec2} out The receiving vec2
   * @param {ReadonlyVec2} a The vec2 point to rotate
   * @param {ReadonlyVec2} b The origin of the rotation
   * @param {Number} rad The angle of rotation in radians
   * @returns {vec2} out
   */

  function rotate(out, a, b, rad) {
    //Translate point to the origin
    var p0 = a[0] - b[0],
        p1 = a[1] - b[1],
        sinC = Math.sin(rad),
        cosC = Math.cos(rad); //perform rotation and translate to correct position

    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {ReadonlyVec2} a The first operand
   * @param {ReadonlyVec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle$1(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1],
        // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
        // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  /**
   * Set the components of a vec2 to zero
   *
   * @param {vec2} out the receiving vector
   * @returns {vec2} out
   */

  function zero(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {ReadonlyVec2} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str(a) {
    return "vec2(" + a[0] + ", " + a[1] + ")";
  }
  /**
   * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec2} a The first vector.
   * @param {ReadonlyVec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec2} a The first vector.
   * @param {ReadonlyVec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1];
    var b0 = b[0],
        b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
  }
  /**
   * Alias for {@link vec2.length}
   * @function
   */

  var len = length;
  /**
   * Alias for {@link vec2.subtract}
   * @function
   */

  var sub$1 = subtract;
  /**
   * Alias for {@link vec2.multiply}
   * @function
   */

  var mul = multiply;
  /**
   * Alias for {@link vec2.divide}
   * @function
   */

  var div$1 = divide$2;
  /**
   * Alias for {@link vec2.distance}
   * @function
   */

  var dist = distance;
  /**
   * Alias for {@link vec2.squaredDistance}
   * @function
   */

  var sqrDist = squaredDistance;
  /**
   * Alias for {@link vec2.squaredLength}
   * @function
   */

  var sqrLen = squaredLength;
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  var vec2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create,
    clone: clone,
    fromValues: fromValues,
    copy: copy$2,
    set: set,
    add: add,
    subtract: subtract,
    multiply: multiply,
    divide: divide$2,
    ceil: ceil$1,
    floor: floor$1,
    min: min$2,
    max: max$1,
    round: round,
    scale: scale,
    scaleAndAdd: scaleAndAdd,
    distance: distance,
    squaredDistance: squaredDistance,
    length: length,
    squaredLength: squaredLength,
    negate: negate,
    inverse: inverse,
    normalize: normalize,
    dot: dot$1,
    cross: cross$1,
    lerp: lerp,
    random: random,
    transformMat2: transformMat2,
    transformMat2d: transformMat2d,
    transformMat3: transformMat3,
    transformMat4: transformMat4,
    rotate: rotate,
    angle: angle$1,
    zero: zero,
    str: str,
    exactEquals: exactEquals,
    equals: equals$1,
    len: len,
    sub: sub$1,
    mul: mul,
    div: div$1,
    dist: dist,
    sqrDist: sqrDist,
    sqrLen: sqrLen,
    forEach: forEach
  });

  var esm$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    glMatrix: common,
    mat2: mat2,
    mat2d: mat2d,
    mat3: mat3,
    mat4: mat4,
    quat: quat,
    quat2: quat2,
    vec2: vec2,
    vec3: vec3,
    vec4: vec4
  });

  var animationFrame = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cancelAnimationFrame = exports.requestAnimationFrame = void 0;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function nowtime() {
      if (typeof performance !== 'undefined' && performance.now) {
        return performance.now();
      }

      if (typeof process !== 'undefined' && process.hrtime) {
        var _process$hrtime = process.hrtime(),
            _process$hrtime2 = (0, _slicedToArray2.default)(_process$hrtime, 2),
            s = _process$hrtime2[0],
            ns = _process$hrtime2[1];

        return s * 1e3 + ns * 1e-6;
      }

      return Date.now ? Date.now() : new Date().getTime();
    }

    var requestAnimationFrame, // eslint-disable-line import/no-mutable-exports
    cancelAnimationFrame;
    exports.cancelAnimationFrame = cancelAnimationFrame;
    exports.requestAnimationFrame = requestAnimationFrame;

    if (typeof commonjsGlobal !== 'undefined' && typeof commonjsGlobal.requestAnimationFrame === 'function') {
      exports.requestAnimationFrame = requestAnimationFrame = commonjsGlobal.requestAnimationFrame;
      exports.cancelAnimationFrame = cancelAnimationFrame = commonjsGlobal.cancelAnimationFrame;
    } else {
      exports.requestAnimationFrame = requestAnimationFrame = function requestAnimationFrame(fn) {
        return setTimeout(function () {
          fn(nowtime());
        }, 16);
      };

      exports.cancelAnimationFrame = cancelAnimationFrame = function cancelAnimationFrame(id) {
        return clearTimeout(id);
      };
    }
  });
  unwrapExports(animationFrame);
  animationFrame.cancelAnimationFrame;
  animationFrame.requestAnimationFrame;

  var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }

    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  unwrapExports(_typeof_1);

  var arrayWithoutHoles = createCommonjsModule(function (module) {
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return arrayLikeToArray(arr);
    }

    module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(arrayWithoutHoles);

  var iterableToArray = createCommonjsModule(function (module) {
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(iterableToArray);

  var nonIterableSpread = createCommonjsModule(function (module) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(nonIterableSpread);

  var toConsumableArray$1 = createCommonjsModule(function (module) {
    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
    }

    module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(toConsumableArray$1);

  var classCallCheck$1 = createCommonjsModule(function (module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(classCallCheck$1);

  var createClass$1 = createCommonjsModule(function (module) {
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(createClass$1);

  var defineProperty$3 = createCommonjsModule(function (module) {
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(defineProperty$3);

  var attribute_value = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sizeToPixel = sizeToPixel;
    exports.toString = toString;
    exports.toNumber = toNumber;
    exports.toArray = toArray;
    exports.compareValue = compareValue;
    esm$1.glMatrix.setMatrixArrayType(Array);

    function sizeToPixel(value, defaultWidth) {
      // eslint-disable-line complexity
      var matched = value.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);

      if (matched) {
        value = {
          size: parseFloat(matched[1]),
          unit: matched[2]
        };
      } else {
        value = {
          size: parseFloat(value),
          unit: 'px'
        };
      }

      var _value = value,
          size = _value.size,
          unit = _value.unit;

      if (unit === 'pt') {
        size /= 0.75;
      } else if (unit === 'pc') {
        size *= 16;
      } else if (unit === 'in') {
        size *= 96;
      } else if (unit === 'cm') {
        size *= 96.0 / 2.54;
      } else if (unit === 'mm') {
        size *= 96.0 / 25.4;
      } else if (unit === 'em' || unit === 'rem' || unit === 'ex') {
        if (!defaultWidth && typeof getComputedStyle === 'function' && typeof document !== 'undefined') {
          var root = getComputedStyle(document.documentElement).fontSize;
          if (!root) defaultWidth = 16;else defaultWidth = sizeToPixel(root, 16);
        }

        size *= defaultWidth;
        if (unit === 'ex') size /= 2;
      } else if (unit === 'q') {
        size *= 96.0 / 25.4 / 4;
      } else if (unit === 'vw' || unit === 'vh') {
        /* istanbul ignore else */
        if (typeof document !== 'undefined') {
          /* istanbul ignore next */
          var val = unit === 'vw' ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
          size *= val / 100;
        }
      } else if (unit === 'vmax' || unit === 'vmin') {
        /* istanbul ignore else */
        if (typeof document !== 'undefined') {
          /* istanbul ignore next */
          var width = window.innerWidth || document.documentElement.clientWidth;
          /* istanbul ignore next */

          var height = window.innerHeight || document.documentElement.clientHeight;

          if (unit === 'vmax') {
            size *= Math.max(width, height) / 100;
          } else {
            size *= Math.min(width, height) / 100;
          }
        }
      }

      return size;
    }

    function toString(value) {
      if (value == null) return value;
      return String(value);
    }

    function toNumber(value) {
      if (value == null) return value;

      if (typeof value === 'string') {
        value = sizeToPixel(value);
      }

      if (!Number.isFinite(value)) throw new TypeError('Invalid value');
      return value;
    }

    function toArray(value) {
      var parseNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (value === '') return null;
      if (typeof value === 'string') value = value.split(/[\s,]+/g);

      if (Array.isArray(value)) {
        if (parseNumber) value = value.map(toNumber);
        if (value.length === 1) return value[0];
      }

      return value;
    }

    function compareValue(oldValue, newValue) {
      if (Array.isArray(oldValue) && Array.isArray(newValue)) {
        if (oldValue.length !== newValue.length) return false;

        for (var i = 0; i < oldValue.length; i++) {
          if (oldValue[i] !== newValue[i]) return false;
        }

        return true;
      }

      return oldValue == null && newValue == null || oldValue === newValue;
    }
  });
  unwrapExports(attribute_value);
  attribute_value.sizeToPixel;
  attribute_value.toNumber;
  attribute_value.toArray;
  attribute_value.compareValue;

  var node$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    var _setDefault = Symbol.for('spritejs_setAttributeDefault');

    var _declareAlias = Symbol.for('spritejs_declareAlias');

    var _setAttribute = Symbol.for('spritejs_setAttribute');

    var _getAttribute = Symbol.for('spritejs_getAttribute');

    var attributes = Symbol.for('spritejs_attributes');
    var changedAttrs = Symbol.for('spritejs_changedAttrs');

    var _subject = Symbol('subject');

    var _attr = Symbol('attr');

    var _default = Symbol('default');

    var _alias = Symbol('alias');

    function getMatrix(transformMap, _ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          ox = _ref2[0],
          oy = _ref2[1];

      var m = esm$1.mat2d.fromValues(1, 0, 0, 1, 0, 0);

      (0, _toConsumableArray2.default)(transformMap).forEach(function (_ref3) {
        var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        if (ox || oy) m = esm$1.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), m, [ox, oy]);

        if (key === 'matrix') {
          m = esm$1.mat2d.multiply(m, m, value);
        } else if (key === 'offsetTranslate') {
          m[4] += value[0];
          m[5] += value[1];
        } else if (key === 'offsetRotate') {
          m = esm$1.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), m, value);
        } else if (key === 'skew') {
          var _value = (0, _slicedToArray2.default)(value, 2),
              x = _value[0],
              y = _value[1];

          m = esm$1.mat2d.multiply(m, m, esm$1.mat2d.fromValues(1, Math.tan(y), Math.tan(x), 1, 0, 0));
        } else {
          esm$1.mat2d[key](m, m, value);
        }

        if (ox || oy) m = esm$1.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      });
      return m;
    }

    var _transformMatrix = Symbol('transformMatrix');

    var _transforms = Symbol('transforms');

    var _changedAttrs = Symbol('changedAttrs');

    var _lastChangedAttr = Symbol('lastChangedAttr');

    var _offsetFigure = Symbol('offsetFigure');

    function setTransform(attr, type, value) {
      var oldValue = attr[_attr][type];

      var changed = attr[_setAttribute](type, value, false);

      if (changed || attr[_lastChangedAttr] !== type) {
        var transformMap = attr[_transforms];

        if (transformMap.has(type)) {
          transformMap.delete(type);
        }

        if (value) {
          if (type === 'rotate') value = Math.PI * value / 180;

          if (type === 'scale') {
            value = value.map(function (v) {
              var t = 1e-5;

              if (Math.abs(v) > t) {
                return v;
              }

              return 1 / v > 0 ? t : -t;
            });
          }

          transformMap.set(type, value);
        }

        attr[_transformMatrix] = null;

        attr[_subject].onPropertyChange(type, value, oldValue, attr);
      }
    }

    function updateOffset(attr) {
      var offsetFigure = attr[_offsetFigure];
      var distance = attr.offsetDistance * offsetFigure.getTotalLength();
      var point = offsetFigure.getPointAtLength(distance);

      if (point) {
        var transformMap = attr[_transforms];
        var rotateValue = attr.offsetRotate;

        if (rotateValue === 'auto') {
          rotateValue = point.angle;
        } else if (rotateValue === 'reverse') {
          /* istanbul ignore next */
          rotateValue = Math.PI + point.angle;
        } else {
          rotateValue = Math.PI * rotateValue / 180;
        }

        transformMap.set('offsetRotate', rotateValue);
        transformMap.set('offsetTranslate', [point.x, point.y]);
        attr[_transformMatrix] = null;
      }
    } // 规范：属性只能是原始类型或元素是原始类型的数组


    var Node = /*#__PURE__*/function () {
      (0, _createClass2.default)(Node, null, [{
        key: "setDefault",
        value: function setDefault(attr) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return attr[_setDefault].apply(attr, args);
        }
      }, {
        key: "declareAlias",
        value: function declareAlias(attr) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return attr[_declareAlias].apply(attr, args);
        }
      }, {
        key: "setAttribute",
        value: function setAttribute(attr) {
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }

          return attr[_setAttribute].apply(attr, args);
        }
      }, {
        key: "getAttribute",
        value: function getAttribute(attr) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return attr[_getAttribute].apply(attr, args);
        }
      }, {
        key: "getAttributes",
        value: function getAttributes(attr) {
          return attr[attributes];
        }
      }, {
        key: "getChangedAttributes",
        value: function getChangedAttributes(attr) {
          return attr[changedAttrs];
        }
      }]);

      function Node(subject) {
        var _this = this;

        (0, _classCallCheck2.default)(this, Node);
        this[_subject] = subject;
        this[_attr] = {};
        this[_transformMatrix] = esm$1.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        this[_transforms] = new Map();
        this[_default] = {};
        this[_alias] = [];
        Object.defineProperty(subject, 'transformMatrix', {
          get: function get() {
            if (!_this[_transformMatrix]) {
              _this[_transformMatrix] = getMatrix(_this[_transforms], _this.transformOrigin);
            }

            return (0, _toConsumableArray2.default)(_this[_transformMatrix]);
          }
        });

        this[_setDefault]({
          id: '',
          name: '',
          className: '',

          /* class */
          x: 0,
          y: 0,

          /* pos */
          transformOrigin: [0, 0],
          transform: '',
          translate: [0, 0],
          rotate: 0,
          scale: [1, 1],
          skew: [0, 0],
          opacity: 1,
          zIndex: 0,
          offsetPath: undefined,
          offsetDistance: 0,
          offsetRotate: 'auto',
          pointerEvents: 'visible',
          // none | visible | visibleFill | visibleStroke | all
          filter: 'none',
          display: ''
        });

        this[_declareAlias]('class', 'pos');

        this[_changedAttrs] = new Set();
        this[_offsetFigure] = new mesh.Figure2D({
          scale: 5,
          simplify: 0
        });
      }

      (0, _createClass2.default)(Node, [{
        key: _setDefault,
        value: function value(attrs) {
          Object.assign(this[_default], attrs);
          Object.assign(this[_attr], attrs);
        }
      }, {
        key: _declareAlias,
        value: function value() {
          var _this$_alias;

          (_this$_alias = this[_alias]).push.apply(_this$_alias, arguments);
        }
      }, {
        key: _setAttribute,
        value: function value(key, _value2) {
          var notice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var oldValue = this[_attr][key];
          var subject = this[_subject];
          if (_value2 == null) _value2 = this[_default][key];

          if (!(0, attribute_value.compareValue)(oldValue, _value2)) {
            this[_attr][key] = _value2;
            if (this[_changedAttrs].has(key)) this[_changedAttrs].delete(key);

            this[_changedAttrs].add(key);

            this[_lastChangedAttr] = key;
            if (notice) subject.onPropertyChange(key, _value2, oldValue, this);
            return true;
          }

          return false;
        }
      }, {
        key: _getAttribute,
        value: function value(key) {
          return this[_attr][key];
        }
      }, {
        key: changedAttrs,
        get: function get() {
          var _this2 = this;

          var ret = {};
          (0, _toConsumableArray2.default)(this[_changedAttrs]).forEach(function (key) {
            ret[key] = _this2[_attr][key];
          });
          return ret;
        }
      }, {
        key: attributes,
        get: function get() {
          var ret = Object.assign({}, this[_attr]);

          for (var i = 0; i < this[_alias].length; i++) {
            var key = this[_alias][i];
            ret[key] = this[key];
          }

          return ret;
        }
      }, {
        key: "id",
        set: function set(value) {
          this[_setAttribute]('id', value);
        },
        get: function get() {
          return this[_getAttribute]('id');
        }
      }, {
        key: "name",
        set: function set(value) {
          this[_setAttribute]('name', value);
        },
        get: function get() {
          return this[_getAttribute]('name');
        }
      }, {
        key: "className",
        set: function set(value) {
          this[_setAttribute]('className', value);
        },
        get: function get() {
          return this[_getAttribute]('className');
        }
      }, {
        key: "class",
        set: function set(value) {
          this.className = value;
        },
        get: function get() {
          return this.className;
        }
      }, {
        key: "x",
        get: function get() {
          return this[_getAttribute]('x');
        },
        set: function set(value) {
          this[_setAttribute]('x', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "y",
        get: function get() {
          return this[_getAttribute]('y');
        },
        set: function set(value) {
          this[_setAttribute]('y', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "pos",
        get: function get() {
          return [this.x, this.y];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = [value, value];
          this.x = value[0];
          this.y = value[1];
        }
      }, {
        key: "transform",
        get: function get() {
          return this[_getAttribute]('transform');
        },
        set: function set(value) {
          var _matrixValue = null;

          if (Array.isArray(value)) {
            _matrixValue = value;
            value = "matrix(".concat(value.map(attribute_value.toNumber).join(), ")");
          }

          if (typeof value === 'string') value = value.replace(/\s*,\s*/g, ',');else if (value != null) {
            throw new TypeError('Invalid transform value.');
          }
          var oldValue = this[_attr].transform;

          if (this[_setAttribute]('transform', value, false)) {
            var transformMap = this[_transforms];

            if (transformMap.has('matrix')) {
              transformMap.delete('matrix');
            }

            if (_matrixValue) {
              transformMap.set('matrix', _matrixValue);
            } else if (value) {
              var transforms = value.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);

              if (transforms) {
                var m = esm$1.mat2d.fromValues(1, 0, 0, 1, 0, 0);

                for (var i = 0; i < transforms.length; i++) {
                  var t = transforms[i];
                  var matched = t.match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);

                  if (matched) {
                    var _matched = (0, _slicedToArray2.default)(matched, 3),
                        method = _matched[1],
                        _value3 = _matched[2];

                    if (method === 'rotate') _value3 = Math.PI * parseFloat(_value3) / 180;else _value3 = _value3.trim().split(/[\s,]+/).map(function (v) {
                      return (0, attribute_value.toNumber)(v);
                    });

                    if (method === 'matrix') {
                      m = esm$1.mat2d.multiply(m, m, _value3);
                    } else if (method === 'skew') {
                      m = esm$1.mat2d.multiply(m, m, esm$1.mat2d.fromValues(1, Math.tan(_value3[1]), Math.tan(_value3[0]), 1, 0, 0));
                    } else {
                      esm$1.mat2d[method](m, m, _value3);
                    }

                    transformMap.set('matrix', m);
                  }
                }
              } else {
                throw new TypeError('Invalid transform value.');
              }
            }

            this[_transformMatrix] = null;

            this[_subject].onPropertyChange('transform', value, oldValue, this);
          }
        }
      }, {
        key: "transformOrigin",
        get: function get() {
          return this[_getAttribute]('transformOrigin');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);

          if (value != null && !Array.isArray(value)) {
            value = [value, value];
          }

          if (this[_setAttribute]('transformOrigin', value)) {
            this[_transformMatrix] = null;
          }
        }
      }, {
        key: "rotate",
        get: function get() {
          return this[_getAttribute]('rotate');
        },
        set: function set(value) {
          setTransform(this, 'rotate', value);
        }
      }, {
        key: "translate",
        get: function get() {
          return this[_getAttribute]('translate');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (value != null && !Array.isArray(value)) value = [value, value];
          setTransform(this, 'translate', value);
        }
      }, {
        key: "scale",
        get: function get() {
          return this[_getAttribute]('scale');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (value != null && !Array.isArray(value)) value = [value, value];
          setTransform(this, 'scale', value);
        }
      }, {
        key: "skew",
        get: function get() {
          return this[_getAttribute]('skew');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (value != null && !Array.isArray(value)) value = [value, value];
          setTransform(this, 'skew', value);
        }
      }, {
        key: "opacity",
        get: function get() {
          return this[_getAttribute]('opacity');
        },
        set: function set(value) {
          if (value != null) value = Number(value);

          this[_setAttribute]('opacity', value);
        }
      }, {
        key: "zIndex",
        get: function get() {
          return this[_getAttribute]('zIndex');
        },
        set: function set(value) {
          if (value != null) value = Number(value);

          this[_setAttribute]('zIndex', value);
        }
      }, {
        key: "offsetPath",
        get: function get() {
          return this[_getAttribute]('offsetPath');
        },
        set: function set(value) {
          if (this[_setAttribute]('offsetPath', value)) {
            this[_offsetFigure].beginPath();

            if (value != null) this[_offsetFigure].addPath(value);
            updateOffset(this);
          }
        }
      }, {
        key: "offsetDistance",
        get: function get() {
          return this[_getAttribute]('offsetDistance');
        },
        set: function set(value) {
          if (this[_setAttribute]('offsetDistance', (0, attribute_value.toNumber)(value))) {
            updateOffset(this);
          }
        }
      }, {
        key: "offsetRotate",
        get: function get() {
          return this[_getAttribute]('offsetRotate');
        },
        set: function set(value) {
          this[_setAttribute]('offsetRotate', value);

          updateOffset(this);
        }
      }, {
        key: "pointerEvents",
        get: function get() {
          return this[_getAttribute]('pointerEvents');
        },
        set: function set(value) {
          if (value != null && value !== 'none' && value !== 'visible' && value !== 'visibleFill' && value !== 'visibleStroke' && value !== 'all') {
            throw new TypeError('Invalid pointerEvents type.');
          }

          this[_setAttribute]('pointerEvents', value);
        }
      }, {
        key: "filter",
        get: function get() {
          return this[_getAttribute]('filter');
        },
        set: function set(value) {
          this[_setAttribute]('filter', value);
        }
      }, {
        key: "display",
        get: function get() {
          return this[_getAttribute]('display');
        },
        set: function set(value) {
          this[_setAttribute]('display', value);
        }
        /* istanbul ignore next */

      }, {
        key: "offset",
        set: function set(value) {
          /* ignore setting offset for animations */
        }
      }]);
      return Node;
    }();

    exports.default = Node;
  });
  unwrapExports(node$1);

  var _extends_1 = createCommonjsModule(function (module) {
    function _extends() {
      module.exports = _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends.apply(this, arguments);
    }

    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  unwrapExports(_extends_1);

  var getPrototypeOf = createCommonjsModule(function (module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o);
    }

    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(getPrototypeOf);

  var superPropBase = createCommonjsModule(function (module) {
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(superPropBase);

  var get = createCommonjsModule(function (module) {
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        module.exports = _get = Reflect.get, module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _get = function _get(target, property, receiver) {
          var base = superPropBase(target, property);
          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }

          return desc.value;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }

      return _get.apply(this, arguments);
    }

    module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(get);

  var setPrototypeOf = createCommonjsModule(function (module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o, p);
    }

    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(setPrototypeOf);

  var inherits = createCommonjsModule(function (module) {
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) setPrototypeOf(subClass, superClass);
    }

    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(inherits);

  var assertThisInitialized = createCommonjsModule(function (module) {
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(assertThisInitialized);

  var possibleConstructorReturn = createCommonjsModule(function (module) {
    var _typeof = _typeof_1["default"];

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }

      return assertThisInitialized(self);
    }

    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(possibleConstructorReturn);

  var _iterStep = function (done, value) {
    return {
      value: value,
      done: !!done
    };
  };

  var _iterators = {};

  var toString$1 = {}.toString;

  var _cof = function (it) {
    return toString$1.call(it).slice(8, -1);
  };

  // eslint-disable-next-line no-prototype-builtins

  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  // 7.2.1 RequireObjectCoercible(argument)
  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var _library = true;

  var _global = createCommonjsModule(function (module) {
    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
    : Function('return this')();
    if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var _core = createCommonjsModule(function (module) {
    var core = module.exports = {
      version: '2.6.12'
    };
    if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });
  _core.version;

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function () {
      return fn.apply(that, arguments);
    };
  };

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', {
      get: function () {
        return 7;
      }
    }).a != 7;
  });

  var document$3 = _global.document; // typeof document.createElement is 'object' in old IE

  var is$1 = _isObject(document$3) && _isObject(document$3.createElement);

  var _domCreate = function (it) {
    return is$1 ? document$3.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', {
      get: function () {
        return 7;
      }
    }).a != 7;
  });

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string

  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP$3 = Object.defineProperty;
  var f$7 = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP$3(O, P, Attributes);
    } catch (e) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var _objectDp = {
    f: f$7
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty$1 = {}.hasOwnProperty;

  var _has = function (it, key) {
    return hasOwnProperty$1.call(it, key);
  };

  var PROTOTYPE$2 = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE$2];
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE$2];
    var key, own, out;
    if (IS_GLOBAL) source = name;

    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has(exports, key)) continue; // export native or passed

      out = own ? target[key] : source[key]; // prevent global pollution for namespaces

      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
      : IS_BIND && own ? _ctx(out, _global) // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0:
                return new C();

              case 1:
                return new C(a);

              case 2:
                return new C(a, b);
            }

            return new C(a, b, c);
          }

          return C.apply(this, arguments);
        };

        F[PROTOTYPE$2] = C[PROTOTYPE$2];
        return F; // make static versions for prototype methods
      }(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

        if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
      }
    }
  }; // type bitmap


  $export.F = 1; // forced

  $export.G = 2; // global

  $export.S = 4; // static

  $export.P = 8; // proto

  $export.B = 16; // bind

  $export.W = 32; // wrap

  $export.U = 64; // safe

  $export.R = 128; // real proto method for `library`

  var _export = $export;

  var _redefine = _hide;

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;

  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  var min$1 = Math.min;

  var _toLength = function (it) {
    return it > 0 ? min$1(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };

  var max = Math.max;
  var min = Math.min;

  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };

  // true  -> Array#includes

  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };

  var _shared = createCommonjsModule(function (module) {
    var SHARED = '__core-js_shared__';
    var store = _global[SHARED] || (_global[SHARED] = {});
    (module.exports = function (key, value) {
      return store[key] || (store[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: _core.version,
      mode: 'pure' ,
      copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
    });
  });

  var id = 0;
  var px = Math.random();

  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var shared = _shared('keys');

  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO$2 = _sharedKey('IE_PROTO');

  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) if (key != IE_PROTO$2) _has(O, key) && result.push(key); // Don't enum bug & hidden keys


    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }

    return result;
  };

  // IE 8- don't enum bug keys
  var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;

    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);

    return O;
  };

  var document$2 = _global.document;

  var _html = document$2 && document$2.documentElement;

  var IE_PROTO$1 = _sharedKey('IE_PROTO');

  var Empty = function () {
    /* empty */
  };

  var PROTOTYPE$1 = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);

    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;

    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];

    return createDict();
  };

  var _objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO$1] = O;
    } else result = createDict();

    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var _wks = createCommonjsModule(function (module) {
    var store = _shared('wks');
    var Symbol = _global.Symbol;
    var USE_SYMBOL = typeof Symbol == 'function';

    var $exports = module.exports = function (name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
    };

    $exports.store = store;
  });

  var def = _objectDp.f;
  var TAG$1 = _wks('toStringTag');

  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, {
      configurable: true,
      value: tag
    });
  };

  var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

  _hide(IteratorPrototype, _wks('iterator'), function () {
    return this;
  });

  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, {
      next: _propertyDesc(1, next)
    });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  var IE_PROTO = _sharedKey('IE_PROTO');
  var ObjectProto$1 = Object.prototype;

  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO)) return O[IE_PROTO];

    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    }

    return O instanceof Object ? ObjectProto$1 : null;
  };

  var ITERATOR$4 = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';

  var returnThis = function () {
    return this;
  };

  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);

    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];

      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };

        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }

      return function entries() {
        return new Constructor(this, kind);
      };
    };

    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR$4] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype; // Fix native

    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));

      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        _setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines
      }
    } // fix Array#{values, @@iterator}.name in V8 / FF


    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;

      $default = function values() {
        return $native.call(this);
      };
    } // Define iterator


    if ((FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR$4])) {
      _hide(proto, ITERATOR$4, $default);
    } // Plug for library


    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;

    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }

    return methods;
  };

  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()


  _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated); // target

    this._i = 0; // next index

    this._k = kind; // kind
    // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;

    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }

    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

  _iterators.Arguments = _iterators.Array;

  var TO_STRING_TAG = _wks('toStringTag');
  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');

  for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i];
    var Collection = _global[NAME];
    var proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = _iterators.Array;
  }

  // false -> String#codePointAt

  var _stringAt = function (TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  var $at = _stringAt(true); // 21.1.3.27 String.prototype[@@iterator]()

  _iterDefine(String, 'String', function (iterated) {
    this._t = String(iterated); // target

    this._i = 0; // next index
    // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return {
      value: undefined,
      done: true
    };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });

  var TAG = _wks('toStringTag'); // ES3 wrong here

  var ARG = _cof(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) {
      /* empty */
    }
  };

  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
    : ARG ? _cof(O) // ES3 arguments fallback
    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var ITERATOR$3 = _wks('iterator');

  var core_isIterable = _core.isIterable = function (it) {
    var O = Object(it);
    return O[ITERATOR$3] !== undefined || '@@iterator' in O // eslint-disable-next-line no-prototype-builtins
    || _iterators.hasOwnProperty(_classof(O));
  };

  var isIterable$1 = core_isIterable;

  var isIterable = createCommonjsModule(function (module) {
    module.exports = {
      "default": isIterable$1,
      __esModule: true
    };
  });
  unwrapExports(isIterable);

  var ITERATOR$2 = _wks('iterator');

  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || _iterators[_classof(it)];
  };

  var core_getIterator = _core.getIterator = function (it) {
    var iterFn = core_getIteratorMethod(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return _anObject(iterFn.call(it));
  };

  var getIterator$1 = core_getIterator;

  var getIterator = createCommonjsModule(function (module) {
    module.exports = {
      "default": getIterator$1,
      __esModule: true
    };
  });
  unwrapExports(getIterator);

  var slicedToArray = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;

    var _isIterable3 = _interopRequireDefault(isIterable);

    var _getIterator3 = _interopRequireDefault(getIterator);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    exports.default = function () {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      return function (arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if ((0, _isIterable3.default)(Object(arr))) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
  });
  unwrapExports(slicedToArray);

  var _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  var ITERATOR$1 = _wks('iterator');
  var ArrayProto = Array.prototype;

  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };

  var _createProperty = function (object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
  };

  var ITERATOR = _wks('iterator');
  var SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR]();

    riter['return'] = function () {
      SAFE_CLOSING = true;
    }; // eslint-disable-next-line no-throw-literal


    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {
    /* empty */
  }

  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;

    try {
      var arr = [7];
      var iter = arr[ITERATOR]();

      iter.next = function () {
        return {
          done: safe = true
        };
      };

      arr[ITERATOR] = function () {
        return iter;
      };

      exec(arr);
    } catch (e) {
      /* empty */
    }

    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) {
    Array.from(iter);
  }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike
    /* , mapfn = undefined, thisArg = undefined */
    ) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);

        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }

      result.length = index;
      return result;
    }
  });

  var from_1$1 = _core.Array.from;

  var from_1 = createCommonjsModule(function (module) {
    module.exports = {
      "default": from_1$1,
      __esModule: true
    };
  });
  unwrapExports(from_1);

  var toConsumableArray = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;

    var _from2 = _interopRequireDefault(from_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    exports.default = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      } else {
        return (0, _from2.default)(arr);
      }
    };
  });
  unwrapExports(toConsumableArray);

  var _redefineAll = function (target, src, safe) {
    for (var key in src) {
      if (safe && target[key]) target[key] = src[key];else _hide(target, key, src[key]);
    }

    return target;
  };

  var _anInstance = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
      throw TypeError(name + ': incorrect invocation!');
    }

    return it;
  };

  var _forOf = createCommonjsModule(function (module) {
    var BREAK = {};
    var RETURN = {};

    var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
      var iterFn = ITERATOR ? function () {
        return iterable;
      } : core_getIteratorMethod(iterable);
      var f = _ctx(fn, that, entries ? 2 : 1);
      var index = 0;
      var length, step, iterator, result;
      if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

      if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
        result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
        if (result === BREAK || result === RETURN) return result;
      } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
        result = _iterCall(iterator, f, step.value, entries);
        if (result === BREAK || result === RETURN) return result;
      }
    };

    exports.BREAK = BREAK;
    exports.RETURN = RETURN;
  });

  var SPECIES$2 = _wks('species');

  var _setSpecies = function (KEY) {
    var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
    if (_descriptors && C && !C[SPECIES$2]) _objectDp.f(C, SPECIES$2, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  };

  var _meta = createCommonjsModule(function (module) {
    var META = _uid('meta');
    var setDesc = _objectDp.f;
    var id = 0;

    var isExtensible = Object.isExtensible || function () {
      return true;
    };

    var FREEZE = !_fails(function () {
      return isExtensible(Object.preventExtensions({}));
    });

    var setMeta = function (it) {
      setDesc(it, META, {
        value: {
          i: 'O' + ++id,
          // object ID
          w: {} // weak collections IDs

        }
      });
    };

    var fastKey = function (it, create) {
      // return primitive with prefix
      if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

      if (!_has(it, META)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F'; // not necessary to add metadata

        if (!create) return 'E'; // add missing metadata

        setMeta(it); // return object ID
      }

      return it[META].i;
    };

    var getWeak = function (it, create) {
      if (!_has(it, META)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true; // not necessary to add metadata

        if (!create) return false; // add missing metadata

        setMeta(it); // return hash weak collections IDs
      }

      return it[META].w;
    }; // add metadata on freeze-family methods calling


    var onFreeze = function (it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
      return it;
    };

    var meta = module.exports = {
      KEY: META,
      NEED: false,
      fastKey: fastKey,
      getWeak: getWeak,
      onFreeze: onFreeze
    };
  });
  _meta.KEY;
  _meta.NEED;
  _meta.fastKey;
  _meta.getWeak;
  _meta.onFreeze;

  var _validateCollection = function (it, TYPE) {
    if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
  };

  var dP$2 = _objectDp.f;
  var fastKey = _meta.fastKey;
  var SIZE = _descriptors ? '_s' : 'size';

  var getEntry = function (that, key) {
    // fast case
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index]; // frozen object case

    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };

  var _collectionStrong = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        _anInstance(that, C, NAME, '_i');
        that._t = NAME; // collection type

        that._i = _objectCreate(null); // index

        that._f = undefined; // first entry

        that._l = undefined; // last entry

        that[SIZE] = 0; // size

        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear() {
          for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }

          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        'delete': function (key) {
          var that = _validateCollection(this, NAME);
          var entry = getEntry(that, key);

          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          }

          return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn
        /* , that = undefined */
        ) {
          _validateCollection(this, NAME);
          var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;

          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this); // revert to the last existing entry

            while (entry && entry.r) entry = entry.p;
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key) {
          return !!getEntry(_validateCollection(this, NAME), key);
        }
      });
      if (_descriptors) dP$2(C.prototype, 'size', {
        get: function () {
          return _validateCollection(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key);
      var prev, index; // change existing entry

      if (entry) {
        entry.v = value; // create new entry
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          // <- index
          k: key,
          // <- key
          v: value,
          // <- value
          p: prev = that._l,
          // <- previous entry
          n: undefined,
          // <- next entry
          r: false // <- removed

        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++; // add to index

        if (index !== 'F') that._i[index] = entry;
      }

      return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      // add .keys, .values, .entries, [@@iterator]
      // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
      _iterDefine(C, NAME, function (iterated, kind) {
        this._t = _validateCollection(iterated, NAME); // target

        this._k = kind; // kind

        this._l = undefined; // previous
      }, function () {
        var that = this;
        var kind = that._k;
        var entry = that._l; // revert to the last existing entry

        while (entry && entry.r) entry = entry.p; // get next entry


        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          // or finish the iteration
          that._t = undefined;
          return _iterStep(1);
        } // return step by kind


        if (kind == 'keys') return _iterStep(0, entry.k);
        if (kind == 'values') return _iterStep(0, entry.v);
        return _iterStep(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

      _setSpecies(NAME);
    }
  };
  _collectionStrong.getConstructor;
  _collectionStrong.def;
  _collectionStrong.getEntry;
  _collectionStrong.setStrong;

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  var SPECIES$1 = _wks('species');

  var _arraySpeciesConstructor = function (original) {
    var C;

    if (_isArray(original)) {
      C = original.constructor; // cross-realm fallback

      if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;

      if (_isObject(C)) {
        C = C[SPECIES$1];
        if (C === null) C = undefined;
      }
    }

    return C === undefined ? Array : C;
  };

  var _arraySpeciesCreate = function (original, length) {
    return new (_arraySpeciesConstructor(original))(length);
  };

  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex

  var _arrayMethods = function (TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate;
    return function ($this, callbackfn, that) {
      var O = _toObject($this);
      var self = _iobject(O);
      var f = _ctx(callbackfn, that, 3);
      var length = _toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var val, res;

      for (; length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);

        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
        }
      }

      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };

  var dP$1 = _objectDp.f;
  var each = _arrayMethods(0);

  var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = _global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};

    if (!_descriptors || typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
      new C().entries().next();
    }))) {
      // create collection constructor
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      _redefineAll(C.prototype, methods);
      _meta.NEED = true;
    } else {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME, '_c');
        target._c = new Base();
        if (iterable != undefined) _forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) _hide(C.prototype, KEY, function (a, b) {
          _anInstance(this, C, KEY);
          if (!IS_ADDER && IS_WEAK && !_isObject(a)) return KEY == 'get' ? undefined : false;

          var result = this._c[KEY](a === 0 ? 0 : a, b);

          return IS_ADDER ? this : result;
        });
      });
      IS_WEAK || dP$1(C.prototype, 'size', {
        get: function () {
          return this._c.size;
        }
      });
    }

    _setToStringTag(C, NAME);
    O[NAME] = C;
    _export(_export.G + _export.W + _export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };

  var MAP = 'Map'; // 23.1 Map Objects

  _collection(MAP, function (get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key) {
      var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set(key, value) {
      return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
    }
  }, _collectionStrong, true);

  var _arrayFromIterable = function (iter, ITERATOR) {
    var result = [];
    _forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };

  var _collectionToJson = function (NAME) {
    return function toJSON() {
      if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      return _arrayFromIterable(this);
    };
  };

  _export(_export.P + _export.R, 'Map', {
    toJSON: _collectionToJson('Map')
  });

  var _setCollectionOf = function (COLLECTION) {
    _export(_export.S, COLLECTION, {
      of: function of() {
        var length = arguments.length;
        var A = new Array(length);

        while (length--) A[length] = arguments[length];

        return new this(A);
      }
    });
  };

  _setCollectionOf('Map');

  var _setCollectionFrom = function (COLLECTION) {
    _export(_export.S, COLLECTION, {
      from: function from(source
      /* , mapFn, thisArg */
      ) {
        var mapFn = arguments[1];
        var mapping, A, n, cb;
        _aFunction(this);
        mapping = mapFn !== undefined;
        if (mapping) _aFunction(mapFn);
        if (source == undefined) return new this();
        A = [];

        if (mapping) {
          n = 0;
          cb = _ctx(mapFn, arguments[2], 2);
          _forOf(source, false, function (nextItem) {
            A.push(cb(nextItem, n++));
          });
        } else {
          _forOf(source, false, A.push, A);
        }

        return new this(A);
      }
    });
  };

  _setCollectionFrom('Map');

  var map$2 = _core.Map;

  var map$1 = createCommonjsModule(function (module) {
    module.exports = {
      "default": map$2,
      __esModule: true
    };
  });
  unwrapExports(map$1);

  var f$6 = Object.getOwnPropertySymbols;
  var _objectGops = {
    f: f$6
  };

  var f$5 = {}.propertyIsEnumerable;
  var _objectPie = {
    f: f$5
  };

  var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {}; // eslint-disable-next-line no-undef

    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;

    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;

      while (length > j) {
        key = keys[j++];
        if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
      }
    }

    return T;
  } : $assign;

  _export(_export.S + _export.F, 'Object', {
    assign: _objectAssign
  });

  var assign$1 = _core.Object.assign;

  var assign = createCommonjsModule(function (module) {
    module.exports = {
      "default": assign$1,
      __esModule: true
    };
  });
  unwrapExports(assign);

  var classCallCheck = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;

    exports.default = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
  });
  unwrapExports(classCallCheck);

  _export(_export.S + _export.F * !_descriptors, 'Object', {
    defineProperty: _objectDp.f
  });

  var $Object = _core.Object;

  var defineProperty$2 = function defineProperty(it, key, desc) {
    return $Object.defineProperty(it, key, desc);
  };

  var defineProperty$1 = createCommonjsModule(function (module) {
    module.exports = {
      "default": defineProperty$2,
      __esModule: true
    };
  });
  unwrapExports(defineProperty$1);

  var createClass = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;

    var _defineProperty2 = _interopRequireDefault(defineProperty$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    exports.default = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          (0, _defineProperty2.default)(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
  });
  unwrapExports(createClass);

  var f$4 = _wks;
  var _wksExt = {
    f: f$4
  };

  var defineProperty = _objectDp.f;

  var _wksDefine = function (name) {
    var $Symbol = _core.Symbol || (_core.Symbol = {} );
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
      value: _wksExt.f(name)
    });
  };

  var _enumKeys = function (it) {
    var result = _objectKeys(it);
    var getSymbols = _objectGops.f;

    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = _objectPie.f;
      var i = 0;
      var key;

      while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }

    return result;
  };

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };

  var _objectGopn = {
    f: f$3
  };

  var gOPN$1 = _objectGopn.f;
  var toString = {}.toString;
  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return gOPN$1(it);
    } catch (e) {
      return windowNames.slice();
    }
  };

  var f$2 = function getOwnPropertyNames(it) {
    return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(_toIobject(it));
  };

  var _objectGopnExt = {
    f: f$2
  };

  var gOPD$1 = Object.getOwnPropertyDescriptor;
  var f$1 = _descriptors ? gOPD$1 : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD$1(O, P);
    } catch (e) {
      /* empty */
    }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };
  var _objectGopd = {
    f: f$1
  };

  var META = _meta.KEY;
  var gOPD = _objectGopd.f;
  var dP = _objectDp.f;
  var gOPN = _objectGopnExt.f;
  var $Symbol = _global.Symbol;
  var $JSON = _global.JSON;

  var _stringify = $JSON && $JSON.stringify;

  var PROTOTYPE = 'prototype';
  var HIDDEN = _wks('_hidden');
  var TO_PRIMITIVE = _wks('toPrimitive');
  var isEnum$1 = {}.propertyIsEnumerable;
  var SymbolRegistry = _shared('symbol-registry');
  var AllSymbols = _shared('symbols');
  var OPSymbols = _shared('op-symbols');
  var ObjectProto = Object[PROTOTYPE];
  var USE_NATIVE$1 = typeof $Symbol == 'function' && !!_objectGops.f;
  var QObject = _global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

  var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

  var setSymbolDesc = _descriptors && _fails(function () {
    return _objectCreate(dP({}, 'a', {
      get: function () {
        return dP(this, 'a', {
          value: 7
        }).a;
      }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD(ObjectProto, key);
    if (protoDesc) delete ObjectProto[key];
    dP(it, key, D);
    if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
  } : dP;

  var wrap$1 = function (tag) {
    var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE]);

    sym._k = tag;
    return sym;
  };

  var isSymbol = USE_NATIVE$1 && typeof $Symbol.iterator == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return it instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
    _anObject(it);
    key = _toPrimitive(key, true);
    _anObject(D);

    if (_has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!_has(it, HIDDEN)) dP(it, HIDDEN, _propertyDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _objectCreate(D, {
          enumerable: _propertyDesc(0, false)
        });
      }

      return setSymbolDesc(it, key, D);
    }

    return dP(it, key, D);
  };

  var $defineProperties = function defineProperties(it, P) {
    _anObject(it);
    var keys = _enumKeys(P = _toIobject(P));
    var i = 0;
    var l = keys.length;
    var key;

    while (l > i) $defineProperty(it, key = keys[i++], P[key]);

    return it;
  };

  var $create = function create(it, P) {
    return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
  };

  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum$1.call(this, key = _toPrimitive(key, true));
    if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
    return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };

  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = _toIobject(it);
    key = _toPrimitive(key, true);
    if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
    var D = gOPD(it, key);
    if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };

  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN(_toIobject(it));
    var result = [];
    var i = 0;
    var key;

    while (names.length > i) {
      if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    }

    return result;
  };

  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto;
    var names = gOPN(IS_OP ? OPSymbols : _toIobject(it));
    var result = [];
    var i = 0;
    var key;

    while (names.length > i) {
      if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
    }

    return result;
  }; // 19.4.1.1 Symbol([description])


  if (!USE_NATIVE$1) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
      var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);

      var $set = function (value) {
        if (this === ObjectProto) $set.call(OPSymbols, value);
        if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, _propertyDesc(1, value));
      };

      if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, {
        configurable: true,
        set: $set
      });
      return wrap$1(tag);
    };

    _redefine($Symbol[PROTOTYPE], 'toString', function toString() {
      return this._k;
    });
    _objectGopd.f = $getOwnPropertyDescriptor;
    _objectDp.f = $defineProperty;
    _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
    _objectPie.f = $propertyIsEnumerable;
    _objectGops.f = $getOwnPropertySymbols;

    if (_descriptors && !_library) {
      _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable);
    }

    _wksExt.f = function (name) {
      return wrap$1(_wks(name));
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE$1, {
    Symbol: $Symbol
  });

  for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) _wks(es6Symbols[j++]);

  for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);

  _export(_export.S + _export.F * !USE_NATIVE$1, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function (key) {
      return _has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

      for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function () {
      setter = true;
    },
    useSimple: function () {
      setter = false;
    }
  });
  _export(_export.S + _export.F * !USE_NATIVE$1, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  }); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
  // https://bugs.chromium.org/p/v8/issues/detail?id=3443

  var FAILS_ON_PRIMITIVES = _fails(function () {
    _objectGops.f(1);
  });
  _export(_export.S + _export.F * FAILS_ON_PRIMITIVES, 'Object', {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      return _objectGops.f(_toObject(it));
    }
  }); // 24.3.2 JSON.stringify(value [, replacer [, space]])

  $JSON && _export(_export.S + _export.F * (!USE_NATIVE$1 || _fails(function () {
    var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols

    return _stringify([S]) != '[null]' || _stringify({
      a: S
    }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;

      while (arguments.length > i) args.push(arguments[i++]);

      $replacer = replacer = args[1];
      if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!_isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

  $Symbol[PROTOTYPE][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

  _setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

  _setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

  _setToStringTag(_global.JSON, 'JSON', true);

  _wksDefine('asyncIterator');

  _wksDefine('observable');

  var symbol$1 = _core.Symbol;

  var symbol = createCommonjsModule(function (module) {
    module.exports = {
      "default": symbol$1,
      __esModule: true
    };
  });
  unwrapExports(symbol);

  var utils$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createNowTime = createNowTime;
    exports.formatDelay = formatDelay;

    function createNowTime() {
      var nowtime = null;

      if (Date.now) {
        nowtime = Date.now;
      } else {
        nowtime = function nowtime() {
          return new Date().getTime();
        };
      }

      return nowtime;
    }
    /*
      delay = 100 -> delay = {delay: 100}
      delay = {entropy: 100} -> delay = {delay: 100, isEntropy: true}
     */


    function formatDelay(delay) {
      if (typeof delay === 'number') {
        delay = {
          delay: delay
        };
      } else if ('entropy' in delay) {
        delay = {
          delay: delay.entropy,
          isEntropy: true
        };
      }

      return delay;
    }
  });
  unwrapExports(utils$2);
  utils$2.createNowTime;
  utils$2.formatDelay;

  var lib$4 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _slicedToArray3 = _interopRequireDefault(slicedToArray);

    var _toConsumableArray3 = _interopRequireDefault(toConsumableArray);

    var _map2 = _interopRequireDefault(map$1);

    var _assign2 = _interopRequireDefault(assign);

    var _classCallCheck3 = _interopRequireDefault(classCallCheck);

    var _createClass3 = _interopRequireDefault(createClass);

    var _symbol2 = _interopRequireDefault(symbol);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    var _nowtime = (0, utils$2.createNowTime)();

    var defaultOptions = {
      originTime: 0,
      playbackRate: 1.0
    };

    var _timeMark = (0, _symbol2.default)('timeMark'),
        _playbackRate = (0, _symbol2.default)('playbackRate'),
        _timers = (0, _symbol2.default)('timers'),
        _originTime = (0, _symbol2.default)('originTime'),
        _setTimer = (0, _symbol2.default)('setTimer'),
        _parent = (0, _symbol2.default)('parent');

    var Timeline = function () {
      function Timeline(options, parent) {
        (0, _classCallCheck3.default)(this, Timeline);

        if (options instanceof Timeline) {
          parent = options;
          options = {};
        }

        options = (0, _assign2.default)({}, defaultOptions, options);

        if (parent) {
          this[_parent] = parent;
        }

        var nowtime = options.nowtime || _nowtime;

        if (!parent) {
          var createTime = nowtime();
          Object.defineProperty(this, 'globalTime', {
            get: function get() {
              return nowtime() - createTime;
            }
          });
        } else {
          Object.defineProperty(this, 'globalTime', {
            get: function get() {
              return parent.currentTime;
            }
          });
        } // timeMark records the reference points on timeline
        // Each time we change the playbackRate or currentTime or entropy
        // A new timeMark will be generated
        // timeMark sorted by entropy
        // If you reset entropy, all the timeMarks behind the new entropy
        // should be dropped


        this[_timeMark] = [{
          globalTime: this.globalTime,
          localTime: -options.originTime,
          entropy: -options.originTime,
          playbackRate: options.playbackRate,
          globalEntropy: 0
        }];

        if (this[_parent]) {
          this[_timeMark][0].globalEntropy = this[_parent].entropy;
        }

        this[_originTime] = options.originTime;
        this[_playbackRate] = options.playbackRate;
        this[_timers] = new _map2.default();
      }

      (0, _createClass3.default)(Timeline, [{
        key: 'markTime',
        value: function markTime() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$time = _ref.time,
              time = _ref$time === undefined ? this.currentTime : _ref$time,
              _ref$entropy = _ref.entropy,
              entropy = _ref$entropy === undefined ? this.entropy : _ref$entropy,
              _ref$playbackRate = _ref.playbackRate,
              playbackRate = _ref$playbackRate === undefined ? this.playbackRate : _ref$playbackRate;

          var timeMark = {
            globalTime: this.globalTime,
            localTime: time,
            entropy: entropy,
            playbackRate: playbackRate,
            globalEntropy: this.globalEntropy
          };

          this[_timeMark].push(timeMark);
        }
      }, {
        key: 'fork',
        value: function fork(options) {
          return new Timeline(options, this);
        }
      }, {
        key: 'seekGlobalTime',
        value: function seekGlobalTime(seekEntropy) {
          var idx = this.seekTimeMark(seekEntropy),
              timeMark = this[_timeMark][idx];
          var entropy = timeMark.entropy,
              playbackRate = timeMark.playbackRate,
              globalTime = timeMark.globalTime;
          return globalTime + (seekEntropy - entropy) / Math.abs(playbackRate);
        }
      }, {
        key: 'seekLocalTime',
        value: function seekLocalTime(seekEntropy) {
          var idx = this.seekTimeMark(seekEntropy),
              timeMark = this[_timeMark][idx];
          var localTime = timeMark.localTime,
              entropy = timeMark.entropy,
              playbackRate = timeMark.playbackRate;

          if (playbackRate > 0) {
            return localTime + (seekEntropy - entropy);
          }

          return localTime - (seekEntropy - entropy);
        }
      }, {
        key: 'seekTimeMark',
        value: function seekTimeMark(entropy) {
          var timeMark = this[_timeMark];
          var l = 0,
              r = timeMark.length - 1;

          if (entropy <= timeMark[l].entropy) {
            return l;
          }

          if (entropy >= timeMark[r].entropy) {
            return r;
          }

          var m = Math.floor((l + r) / 2); // binary search

          while (m > l && m < r) {
            if (entropy === timeMark[m].entropy) {
              return m;
            }

            if (entropy < timeMark[m].entropy) {
              r = m;
            } else if (entropy > timeMark[m].entropy) {
              l = m;
            }

            m = Math.floor((l + r) / 2);
          }

          return l;
        }
      }, {
        key: 'updateTimers',
        value: function updateTimers() {
          var _this = this;

          var timers = [].concat((0, _toConsumableArray3.default)(this[_timers]));
          timers.forEach(function (_ref2) {
            var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
                id = _ref3[0],
                timer = _ref3[1];

            _this[_setTimer](timer.handler, timer.time, id);
          });
        }
      }, {
        key: 'clearTimeout',
        value: function (_clearTimeout) {
          function clearTimeout(_x) {
            return _clearTimeout.apply(this, arguments);
          }

          clearTimeout.toString = function () {
            return _clearTimeout.toString();
          };

          return clearTimeout;
        }(function (id) {
          var timer = this[_timers].get(id);

          if (timer && timer.timerID != null) {
            if (this[_parent]) {
              this[_parent].clearTimeout(timer.timerID);
            } else {
              clearTimeout(timer.timerID);
            }
          }

          this[_timers].delete(id);
        })
      }, {
        key: 'clearInterval',
        value: function clearInterval(id) {
          return this.clearTimeout(id);
        }
      }, {
        key: 'clear',
        value: function clear() {
          var _this2 = this; // clear all running timers


          var timers = this[_timers];
          [].concat((0, _toConsumableArray3.default)(timers.keys())).forEach(function (id) {
            _this2.clearTimeout(id);
          });
        }
        /*
          setTimeout(func, {delay: 100, isEntropy: true})
          setTimeout(func, {entropy: 100})
          setTimeout(func, 100})
         */

      }, {
        key: 'setTimeout',
        value: function setTimeout(handler) {
          var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            delay: 0
          };
          return this[_setTimer](handler, time);
        }
      }, {
        key: 'setInterval',
        value: function setInterval(handler) {
          var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            delay: 0
          };
          var that = this;

          var id = this[_setTimer](function step() {
            // reset timer before handler cause we may clearTimeout in handler()
            that[_setTimer](step, time, id);

            handler();
          }, time);

          return id;
        }
      }, {
        key: _setTimer,
        value: function value(handler, time) {
          var _this3 = this;

          var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _symbol2.default)('timerID');
          time = (0, utils$2.formatDelay)(time);

          var timer = this[_timers].get(id);

          var delay = void 0,
              timerID = null,
              startTime = void 0,
              startEntropy = void 0;

          if (timer) {
            this.clearTimeout(id);

            if (time.isEntropy) {
              delay = (time.delay - (this.entropy - timer.startEntropy)) / Math.abs(this.playbackRate);
            } else {
              delay = (time.delay - (this.currentTime - timer.startTime)) / this.playbackRate;
            }

            startTime = timer.startTime;
            startEntropy = timer.startEntropy;
          } else {
            delay = time.delay / (time.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate);
            startTime = this.currentTime;
            startEntropy = this.entropy;
          }

          var parent = this[_parent],
              globalTimeout = parent ? parent.setTimeout.bind(parent) : setTimeout;
          var heading = time.heading; // console.log(heading, parent, delay)

          if (!parent && heading === false && delay < 0) {
            delay = Infinity;
          } // if playbackRate is zero, delay will be infinity.
          // For wxapp bugs, cannot use Number.isFinite yet.


          if (isFinite(delay) || parent) {
            // eslint-disable-line no-restricted-globals
            delay = Math.ceil(delay);

            if (globalTimeout !== setTimeout) {
              delay = {
                delay: delay,
                heading: heading
              };
            }

            timerID = globalTimeout(function () {
              _this3[_timers].delete(id);

              handler();
            }, delay);
          }

          this[_timers].set(id, {
            timerID: timerID,
            handler: handler,
            time: time,
            startTime: startTime,
            startEntropy: startEntropy
          });

          return id;
        }
      }, {
        key: 'parent',
        get: function get() {
          return this[_parent];
        }
      }, {
        key: 'lastTimeMark',
        get: function get() {
          return this[_timeMark][this[_timeMark].length - 1];
        }
      }, {
        key: 'currentTime',
        get: function get() {
          var _lastTimeMark = this.lastTimeMark,
              localTime = _lastTimeMark.localTime,
              globalTime = _lastTimeMark.globalTime;
          return localTime + (this.globalTime - globalTime) * this.playbackRate;
        },
        set: function set(time) {
          var _this4 = this;

          var from = this.currentTime,
              to = time,
              timers = this[_timers];
          this.markTime({
            time: time
          });
          [].concat((0, _toConsumableArray3.default)(timers)).forEach(function (_ref4) {
            var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
                id = _ref5[0],
                timer = _ref5[1];

            if (!timers.has(id)) return; // Need check because it maybe clearTimeout by former handler().

            var _timer$time = timer.time,
                isEntropy = _timer$time.isEntropy,
                delay = _timer$time.delay,
                heading = _timer$time.heading,
                handler = timer.handler,
                startTime = timer.startTime;

            if (!isEntropy) {
              var endTime = startTime + delay;

              if (delay === 0 || heading !== false && (to - from) * delay <= 0 || from <= endTime && endTime <= to || from >= endTime && endTime >= to) {
                handler();

                _this4.clearTimeout(id);
              }
            } else if (delay === 0) {
              handler();

              _this4.clearTimeout(id);
            }
          });
          this.updateTimers();
        } // Both currentTime and entropy should be influenced by playbackRate.
        // If current playbackRate is negative, the currentTime should go backwards
        // while the entropy remain to go forwards.
        // Both of the initial values is set to -originTime

      }, {
        key: 'entropy',
        get: function get() {
          var _lastTimeMark2 = this.lastTimeMark,
              entropy = _lastTimeMark2.entropy,
              globalEntropy = _lastTimeMark2.globalEntropy;
          return entropy + Math.abs((this.globalEntropy - globalEntropy) * this.playbackRate);
        },
        // get globalTime() {
        //   if(this[_parent]) {
        //     return this[_parent].currentTime;
        //   }
        //   return nowtime();
        // }
        // change entropy will NOT cause currentTime changing but may influence the pass
        // and the future of the timeline. (It may change the result of seek***Time)
        // While entropy is set, all the marks behind will be droped
        set: function set(entropy) {
          if (this.entropy > entropy) {
            var idx = this.seekTimeMark(entropy);
            this[_timeMark].length = idx + 1;
          }

          this.markTime({
            entropy: entropy
          });
          this.updateTimers();
        }
      }, {
        key: 'globalEntropy',
        get: function get() {
          return this[_parent] ? this[_parent].entropy : this.globalTime;
        }
      }, {
        key: 'playbackRate',
        get: function get() {
          return this[_playbackRate];
        },
        set: function set(rate) {
          if (rate !== this.playbackRate) {
            this.markTime({
              playbackRate: rate
            });
            this[_playbackRate] = rate;
            this.updateTimers();
          }
        }
      }, {
        key: 'paused',
        get: function get() {
          if (this.playbackRate === 0) return true;
          var parent = this.parent;

          while (parent) {
            if (parent.playbackRate === 0) return true;
            parent = parent.parent;
          }

          return false;
        }
      }]);
      return Timeline;
    }();

    exports.default = Timeline;
  });
  unwrapExports(lib$4);

  var effect = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      // s - startFrame, e - endFrame
      default: function _default(from, to, p, s, e) {
        if (typeof from === 'number' && typeof to === 'number') {
          return from + (p - s) / (e - s) * (to - from);
        }

        if (p - s > e - p) {
          return to;
        }

        return from;
      }
    };
  });
  unwrapExports(effect);

  /**
   * https://github.com/gre/bezier-easing
   * BezierEasing - use bezier curve for transition easing function
   * by Gaëtan Renaudeau 2014 - 2015 – MIT License
   */
  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function LinearEasing(x) {
    return x;
  }

  var src = function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    if (mX1 === mY1 && mX2 === mY2) {
      return LinearEasing;
    } // Precompute samples table


    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample; // Interpolate to provide an initial guess for t

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function BezierEasing(x) {
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0) {
        return 0;
      }

      if (x === 1) {
        return 1;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  };

  var easing = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseEasing = exports.Easings = undefined;

    var _slicedToArray3 = _interopRequireDefault(slicedToArray);

    var _toConsumableArray3 = _interopRequireDefault(toConsumableArray);

    var _map2 = _interopRequireDefault(map$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    var bezierFuncCache = new _map2.default();

    function getBezierEasing() {
      for (var _len = arguments.length, value = Array(_len), _key = 0; _key < _len; _key++) {
        value[_key] = arguments[_key];
      }

      var easing = bezierFuncCache.get(value);

      if (easing) {
        return easing;
      }

      easing = src.apply(undefined, value);
      bezierFuncCache.set(value, easing);
      return easing;
    }

    function getStepsEasing(step) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'end';
      return function (p, frames) {
        for (var i = 1; i < frames.length; i++) {
          var offset = frames[i].offset;

          if (p <= offset) {
            var start = frames[i - 1].offset,
                end = offset;
            var fp = (p - start) / (end - start),
                d = 1 / step;
            var t = fp / d;

            if (pos === 'end') {
              t = Math.floor(t);
            } else {
              t = Math.ceil(t);
            }

            return d * t * (end - start) + start;
          }
        }

        return 0;
      };
    }

    function parseEasingStr(easingStr) {
      var pattern = /^cubic-bezier\((.*)\)/,
          matched = easingStr.match(pattern);

      if (matched) {
        var value = matched[1].trim();
        value = value.split(',').map(function (v) {
          return parseFloat(v.trim());
        });
        return getBezierEasing.apply(undefined, (0, _toConsumableArray3.default)(value));
      }

      pattern = /^steps\((.*)\)/;
      matched = easingStr.match(pattern);

      if (matched) {
        var _value = matched[1].trim();

        _value = _value.split(',').map(function (v) {
          return v.trim();
        });

        var _value2 = _value,
            _value3 = (0, _slicedToArray3.default)(_value2, 2),
            step = _value3[0],
            pos = _value3[1];

        return getStepsEasing(parseInt(step, 10), pos);
      }

      return easingStr;
    }

    var Easings = {
      linear: function linear(p) {
        return p;
      },
      ease: getBezierEasing(0.25, 0.1, 0.25, 1),
      'ease-in': getBezierEasing(0.42, 0, 1, 1),
      'ease-out': getBezierEasing(0, 0, 0.58, 1),
      'ease-in-out': getBezierEasing(0.42, 0, 0.58, 1),
      // 'step-start': function(p, frames){
      //   let ret = 0
      //   for(let i = 0; i < frames.length; i++){
      //     const {offset} = frames[i]
      //     ret = offset
      //     if(p < offset){
      //       break
      //     }
      //   }
      //   return ret
      // },
      // 'step-end': function(p, frames){
      //   let ret = 0
      //   for(let i = 0; i < frames.length; i++){
      //     const {offset} = frames[i]
      //     if(p < offset){
      //       break
      //     }
      //     ret = offset
      //   }
      //   return ret
      // }
      'step-start': getStepsEasing(1, 'start'),
      'step-end': getStepsEasing(1, 'end')
    };

    function parseEasing(easing) {
      if (typeof easing === 'string') {
        if (!Easings[easing]) {
          easing = parseEasingStr(easing);
        } else {
          // load default Easing
          easing = Easings[easing];
        }
      } else if (easing.type === 'cubic-bezier') {
        easing = getBezierEasing.apply(undefined, (0, _toConsumableArray3.default)(easing.value));
      } else if (easing.type === 'steps') {
        easing = getStepsEasing(easing.step, easing.pos);
      }

      return easing;
    }

    exports.Easings = Easings;
    exports.parseEasing = parseEasing;
  });
  unwrapExports(easing);
  easing.parseEasing;
  easing.Easings;

  var SPECIES = _wks('species');

  var _speciesConstructor = function (O, D) {
    var C = _anObject(O).constructor;
    var S;
    return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
  };

  // fast apply, http://jsperf.lnkit.com/fast-apply/5
  var _invoke = function (fn, args, that) {
    var un = that === undefined;

    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);

      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);

      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }

    return fn.apply(that, args);
  };

  var process$3 = _global.process;
  var setTask = _global.setImmediate;
  var clearTask = _global.clearImmediate;
  var MessageChannel = _global.MessageChannel;
  var Dispatch = _global.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;

  var run = function () {
    var id = +this; // eslint-disable-next-line no-prototype-builtins

    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var listener = function (event) {
    run.call(event.data);
  }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;

      while (arguments.length > i) args.push(arguments[i++]);

      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        _invoke(typeof fn == 'function' ? fn : Function(fn), args);
      };

      defer(counter);
      return counter;
    };

    clearTask = function clearImmediate(id) {
      delete queue[id];
    }; // Node.js 0.8-


    if (_cof(process$3) == 'process') {
      defer = function (id) {
        process$3.nextTick(_ctx(run, id, 1));
      }; // Sphere (JS game engine) Dispatch API

    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(_ctx(run, id, 1));
      }; // Browsers with MessageChannel, includes WebWorkers

    } else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = _ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
      defer = function (id) {
        _global.postMessage(id + '', '*');
      };

      _global.addEventListener('message', listener, false); // IE8-
    } else if (ONREADYSTATECHANGE in _domCreate('script')) {
      defer = function (id) {
        _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
          _html.removeChild(this);
          run.call(id);
        };
      }; // Rest old browsers

    } else {
      defer = function (id) {
        setTimeout(_ctx(run, id, 1), 0);
      };
    }
  }

  var _task = {
    set: setTask,
    clear: clearTask
  };

  var macrotask = _task.set;
  var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
  var process$2 = _global.process;
  var Promise$1 = _global.Promise;
  var isNode$1 = _cof(process$2) == 'process';

  var _microtask = function () {
    var head, last, notify;

    var flush = function () {
      var parent, fn;
      if (isNode$1 && (parent = process$2.domain)) parent.exit();

      while (head) {
        fn = head.fn;
        head = head.next;

        try {
          fn();
        } catch (e) {
          if (head) notify();else last = undefined;
          throw e;
        }
      }

      last = undefined;
      if (parent) parent.enter();
    }; // Node.js


    if (isNode$1) {
      notify = function () {
        process$2.nextTick(flush);
      }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

    } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode('');
      new Observer(flush).observe(node, {
        characterData: true
      }); // eslint-disable-line no-new

      notify = function () {
        node.data = toggle = !toggle;
      }; // environments with maybe non-completely correct, but existent Promise

    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      var promise = Promise$1.resolve(undefined);

      notify = function () {
        promise.then(flush);
      }; // for other environments - macrotask based on:
      // - setImmediate
      // - MessageChannel
      // - window.postMessag
      // - onreadystatechange
      // - setTimeout

    } else {
      notify = function () {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(_global, flush);
      };
    }

    return function (fn) {
      var task = {
        fn: fn,
        next: undefined
      };
      if (last) last.next = task;

      if (!head) {
        head = task;
        notify();
      }

      last = task;
    };
  };

  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = _aFunction(resolve);
    this.reject = _aFunction(reject);
  }

  var f = function (C) {
    return new PromiseCapability(C);
  };

  var _newPromiseCapability = {
    f: f
  };

  var _perform = function (exec) {
    try {
      return {
        e: false,
        v: exec()
      };
    } catch (e) {
      return {
        e: true,
        v: e
      };
    }
  };

  var navigator$1 = _global.navigator;

  var _userAgent = navigator$1 && navigator$1.userAgent || '';

  var _promiseResolve = function (C, x) {
    _anObject(C);
    if (_isObject(x) && x.constructor === C) return x;
    var promiseCapability = _newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var task = _task.set;
  var microtask = _microtask();
  var PROMISE = 'Promise';
  var TypeError$1 = _global.TypeError;
  var process$1 = _global.process;
  var versions = process$1 && process$1.versions;
  var v8 = versions && versions.v8 || '';
  var $Promise = _global[PROMISE];
  var isNode = _classof(process$1) == 'process';

  var empty$1 = function () {
    /* empty */
  };

  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
  var USE_NATIVE = !!function () {
    try {
      // correct subclassing with @@species support
      var promise = $Promise.resolve(1);

      var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
        exec(empty$1, empty$1);
      }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


      return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty$1) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0 && _userAgent.indexOf('Chrome/66') === -1;
    } catch (e) {
      /* empty */
    }
  }(); // helpers

  var isThenable = function (it) {
    var then;
    return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify = function (promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function () {
      var value = promise._v;
      var ok = promise._s == 1;
      var i = 0;

      var run = function (reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;

        try {
          if (handler) {
            if (!ok) {
              if (promise._h == 2) onHandleUnhandled(promise);
              promise._h = 1;
            }

            if (handler === true) result = value;else {
              if (domain) domain.enter();
              result = handler(value); // may throw

              if (domain) {
                domain.exit();
                exited = true;
              }
            }

            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (e) {
          if (domain && !exited) domain.exit();
          reject(e);
        }
      };

      while (chain.length > i) run(chain[i++]); // variable length - can't use forEach


      promise._c = [];
      promise._n = false;
      if (isReject && !promise._h) onUnhandled(promise);
    });
  };

  var onUnhandled = function (promise) {
    task.call(_global, function () {
      var value = promise._v;
      var unhandled = isUnhandled(promise);
      var result, handler, console;

      if (unhandled) {
        result = _perform(function () {
          if (isNode) {
            process$1.emit('unhandledRejection', value, promise);
          } else if (handler = _global.onunhandledrejection) {
            handler({
              promise: promise,
              reason: value
            });
          } else if ((console = _global.console) && console.error) {
            console.error('Unhandled promise rejection', value);
          }
        }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

        promise._h = isNode || isUnhandled(promise) ? 2 : 1;
      }

      promise._a = undefined;
      if (unhandled && result.e) throw result.v;
    });
  };

  var isUnhandled = function (promise) {
    return promise._h !== 1 && (promise._a || promise._c).length === 0;
  };

  var onHandleUnhandled = function (promise) {
    task.call(_global, function () {
      var handler;

      if (isNode) {
        process$1.emit('rejectionHandled', promise);
      } else if (handler = _global.onrejectionhandled) {
        handler({
          promise: promise,
          reason: promise._v
        });
      }
    });
  };

  var $reject = function (value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap

    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
  };

  var $resolve = function (value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap

    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");

      if (then = isThenable(value)) {
        microtask(function () {
          var wrapper = {
            _w: promise,
            _d: false
          }; // wrap

          try {
            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch (e) {
      $reject.call({
        _w: promise,
        _d: false
      }, e); // wrap
    }
  }; // constructor polyfill


  if (!USE_NATIVE) {
    // 25.4.3.1 Promise(executor)
    $Promise = function Promise(executor) {
      _anInstance(this, $Promise, PROMISE, '_h');
      _aFunction(executor);
      Internal.call(this);

      try {
        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    }; // eslint-disable-next-line no-unused-vars


    Internal = function Promise(executor) {
      this._c = []; // <- awaiting reactions

      this._a = undefined; // <- checked in isUnhandled reactions

      this._s = 0; // <- state

      this._d = false; // <- done

      this._v = undefined; // <- value

      this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

      this._n = false; // <- notify
    };

    Internal.prototype = _redefineAll($Promise.prototype, {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = isNode ? process$1.domain : undefined;

        this._c.push(reaction);

        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });

    OwnPromiseCapability = function () {
      var promise = new Internal();
      this.promise = promise;
      this.resolve = _ctx($resolve, promise, 1);
      this.reject = _ctx($reject, promise, 1);
    };

    _newPromiseCapability.f = newPromiseCapability = function (C) {
      return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE, {
    Promise: $Promise
  });
  _setToStringTag($Promise, PROMISE);
  _setSpecies(PROMISE);
  Wrapper = _core[PROMISE]; // statics

  _export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  _export(_export.S + _export.F * (_library ), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x) {
      return _promiseResolve(this === Wrapper ? $Promise : this, x);
    }
  });
  _export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
    $Promise.all(iter)['catch'](empty$1);
  })), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = _perform(function () {
        var values = [];
        var index = 0;
        var remaining = 1;
        _forOf(iterable, false, function (promise) {
          var $index = index++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          C.resolve(promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[$index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.e) reject(result.v);
      return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = _perform(function () {
        _forOf(iterable, false, function (promise) {
          C.resolve(promise).then(capability.resolve, reject);
        });
      });
      if (result.e) reject(result.v);
      return capability.promise;
    }
  });

  _export(_export.P + _export.R, 'Promise', {
    'finally': function (onFinally) {
      var C = _speciesConstructor(this, _core.Promise || _global.Promise);
      var isFunction = typeof onFinally == 'function';
      return this.then(isFunction ? function (x) {
        return _promiseResolve(C, onFinally()).then(function () {
          return x;
        });
      } : onFinally, isFunction ? function (e) {
        return _promiseResolve(C, onFinally()).then(function () {
          throw e;
        });
      } : onFinally);
    }
  });

  _export(_export.S, 'Promise', {
    'try': function (callbackfn) {
      var promiseCapability = _newPromiseCapability.f(this);
      var result = _perform(callbackfn);
      (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
      return promiseCapability.promise;
    }
  });

  var promise$1 = _core.Promise;

  var promise = createCommonjsModule(function (module) {
    module.exports = {
      "default": promise$1,
      __esModule: true
    };
  });
  unwrapExports(promise);

  var _objectSap = function (KEY, exec) {
    var fn = (_core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(_export.S + _export.F * _fails(function () {
      fn(1);
    }), 'Object', exp);
  };

  _objectSap('keys', function () {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });

  var keys$1 = _core.Object.keys;

  var keys = createCommonjsModule(function (module) {
    module.exports = {
      "default": keys$1,
      __esModule: true
    };
  });
  unwrapExports(keys);

  var isEnum = _objectPie.f;

  var _objectToArray = function (isEntries) {
    return function (it) {
      var O = _toIobject(it);
      var keys = _objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;

      while (length > i) {
        key = keys[i++];

        if (!_descriptors || isEnum.call(O, key)) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      }

      return result;
    };
  };

  var $entries = _objectToArray(true);
  _export(_export.S, 'Object', {
    entries: function entries(it) {
      return $entries(it);
    }
  });

  var entries$1 = _core.Object.entries;

  var entries = createCommonjsModule(function (module) {
    module.exports = {
      "default": entries$1,
      __esModule: true
    };
  });
  unwrapExports(entries);

  var utils$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _slicedToArray3 = _interopRequireDefault(slicedToArray);

    var _entries2 = _interopRequireDefault(entries);

    var _assign2 = _interopRequireDefault(assign);

    var _promise2 = _interopRequireDefault(promise);

    exports.defer = defer;
    exports.periodicity = periodicity;
    exports.calculateFramesOffset = calculateFramesOffset;
    exports.getProgress = getProgress;
    exports.getCurrentFrame = getCurrentFrame;

    var _effect2 = _interopRequireDefault(effect);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    function defer() {
      var ret = {};
      ret.promise = new _promise2.default(function (resolve, reject) {
        ret.resolve = resolve;
        ret.reject = reject;
      });
      return ret;
    }

    function periodicity(val, dur) {
      var t = Math.floor(val / dur);
      var v = val - t * dur;

      if (v === 0 && t > 0) {
        v = dur;
        t--;
      }

      return [t, v];
    }

    function calculateFramesOffset(keyframes) {
      keyframes = keyframes.slice(0);
      var firstFrame = keyframes[0],
          lastFrame = keyframes[keyframes.length - 1];
      lastFrame.offset = lastFrame.offset || 1;
      firstFrame.offset = firstFrame.offset || 0;
      var offset = 0,
          offsetFrom = -1;

      for (var i = 0; i < keyframes.length; i++) {
        var frame = keyframes[i];

        if (frame.offset != null) {
          var dis = i - offsetFrom;

          if (dis > 1) {
            var delta = (frame.offset - offset) / dis;

            for (var j = 0; j < dis - 1; j++) {
              keyframes[offsetFrom + j + 1].offset = offset + delta * (j + 1);
            }
          }

          offset = frame.offset;
          offsetFrom = i;
        }

        if (frame.easing != null) {
          frame.easing = (0, easing.parseEasing)(frame.easing);
        }

        if (i > 0) {
          var hasEasing = keyframes[i].easing != null; // 如果中间某个属性没有了，需要从前一帧复制过来

          keyframes[i] = (0, _assign2.default)({}, keyframes[i - 1], keyframes[i]);

          if (!hasEasing) {
            // easing 不能复制
            delete keyframes[i].easing;
          }
        }
      }

      return keyframes;
    }

    function getProgress(timeline, timing, p) {
      var currentTime = timeline.currentTime,
          direction = timing.direction,
          duration = timing.duration;
      var inverted = false;

      if (direction === 'reverse') {
        p = 1 - p;
        inverted = true;
      } else if (direction === 'alternate' || direction === 'alternate-reverse') {
        var period = Math.floor(currentTime / duration);
        if (p === 1) period--; // period = Math.max(0, period)

        if (period % 2 ^ direction === 'alternate-reverse') {
          p = 1 - p;
          inverted = true;
        }
      }

      return {
        p: p,
        inverted: inverted
      };
    }

    function calculateFrame(previousFrame, nextFrame, effects, p) {
      var ret = {};
      (0, _entries2.default)(nextFrame).forEach(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        if (key !== 'offset' && key !== 'easing') {
          var effect = effects[key] || effects.default;
          var v = effect(previousFrame[key], value, p, previousFrame.offset, nextFrame.offset);

          if (v != null) {
            ret[key] = v;
          }
        }
      });
      return ret;
    }

    function getCurrentFrame(timing, keyframes, effects, p) {
      var easing = timing.easing,
          effect = timing.effect;

      if (!effect) {
        // timing.effect 会覆盖掉 Effects 和 animator.applyEffects 中定义的 effects
        effects = (0, _assign2.default)({}, _effect2.default, effects);
      }

      var ret = {};
      p = easing(p, keyframes);

      for (var i = 1; i < keyframes.length; i++) {
        var frame = keyframes[i],
            offset = frame.offset;

        if (offset >= p || i === keyframes.length - 1) {
          var previousFrame = keyframes[i - 1],
              previousOffset = previousFrame.offset,
              _easing = previousFrame.easing;
          var ep = p;

          if (_easing) {
            var d = offset - previousOffset;
            ep = _easing((p - previousOffset) / d) * d + previousOffset;
          }

          if (effect) {
            ret = effect(previousFrame, frame, ep, previousOffset, offset);
          } else {
            ret = calculateFrame(previousFrame, frame, effects, ep);
          }

          break;
        }
      }

      return ret;
    }
  });
  unwrapExports(utils$1);
  utils$1.defer;
  utils$1.periodicity;
  utils$1.calculateFramesOffset;
  utils$1.getProgress;
  utils$1.getCurrentFrame;

  var animator = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _promise2 = _interopRequireDefault(promise);

    var _keys2 = _interopRequireDefault(keys);

    var _assign2 = _interopRequireDefault(assign);

    var _classCallCheck3 = _interopRequireDefault(classCallCheck);

    var _createClass3 = _interopRequireDefault(createClass);

    var _symbol2 = _interopRequireDefault(symbol);

    var _spriteTimeline2 = _interopRequireDefault(lib$4);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    var _timing = (0, _symbol2.default)('timing'),
        _keyframes = (0, _symbol2.default)('keyframes'),
        _initState = (0, _symbol2.default)('initState'),
        _readyDefer = (0, _symbol2.default)('readyDefer'),
        _finishedDefer = (0, _symbol2.default)('finishedDefer'),
        _effects = (0, _symbol2.default)('effects'),
        _activeReadyTimer = (0, _symbol2.default)('activeReadyTimer'),
        _activeFinishTimer = (0, _symbol2.default)('activeFinishTimer'),
        _removeDefer = (0, _symbol2.default)('removeDefer');
    /**
      easing: {
        type: 'cubic-bezier',
        value: [...]
      }
      easing: {
        type: 'steps',
        step: 1,
        pos: 'end'
      }
     */


    var defaultTiming = {
      delay: 0,
      endDelay: 0,
      fill: 'auto',
      iterations: 1.0,
      playbackRate: 1.0,
      direction: 'normal',
      easing: 'linear',
      effect: null
    };
    /**
      animation: play --> delay --> effect --> endDelay
      playState: idle --> pending --> running --> pending --> finished
     */

    var _class = function () {
      function _class(initState, keyframes, timing) {
        var _this = this;

        (0, _classCallCheck3.default)(this, _class);

        if (Array.isArray(initState)) {
          var _ref = [initState[0], initState, keyframes]; // 如果 initState 缺省，默认 keyframes 的第一帧为 initState

          initState = _ref[0];
          keyframes = _ref[1];
          timing = _ref[2];
        }

        if (typeof timing === 'number') {
          timing = {
            duration: timing
          };
        }

        this[_timing] = (0, _assign2.default)({}, defaultTiming, timing);
        this[_timing].easing = (0, easing.parseEasing)(this[_timing].easing);
        this[_keyframes] = (0, utils$1.calculateFramesOffset)(keyframes);
        var lastFrame = this[_keyframes][this[_keyframes].length - 1];
        this[_initState] = {}; // 初始状态

        (0, _keys2.default)(lastFrame).forEach(function (key) {
          if (Object.prototype.hasOwnProperty.call(initState, key)) {
            if (key !== 'easing' && key !== 'offset') {
              _this[_initState][key] = initState[key];
            }
          }
        }); // 补齐参数

        this[_keyframes] = this[_keyframes].map(function (frame) {
          return (0, _assign2.default)({}, _this[_initState], frame);
        });

        if (this[_keyframes][0].offset !== 0) {
          // 要补第一帧
          this[_keyframes].unshift((0, _assign2.default)({}, this[_initState], {
            offset: 0
          }));
        }

        if (lastFrame.offset < 1) {
          // 要补最后一帧
          this[_keyframes].push((0, _assign2.default)({}, lastFrame, {
            offset: 1
          }));
        }

        this[_effects] = {};
        this.timeline = null; // idle, no effect
      }

      (0, _createClass3.default)(_class, [{
        key: 'pause',
        value: function pause() {
          this.timeline.playbackRate = 0;
        }
      }, {
        key: _activeReadyTimer,
        value: function value() {
          var _this2 = this;

          if (this[_readyDefer] && !this[_readyDefer].timerID) {
            if (this.timeline.currentTime < 0) {
              this[_readyDefer].timerID = this.timeline.setTimeout(function () {
                _this2[_readyDefer].resolve();

                delete _this2[_readyDefer];
              }, {
                delay: -this.timeline.currentTime,
                heading: false
              });
            } else {
              this[_readyDefer].timerID = this.timeline.setTimeout(function () {
                _this2[_readyDefer].resolve();

                delete _this2[_readyDefer];
              }, {
                delay: 0,
                isEntropy: true
              });
            }
          }
        }
      }, {
        key: _activeFinishTimer,
        value: function value() {
          var _this3 = this;

          var _timing2 = this[_timing],
              duration = _timing2.duration,
              iterations = _timing2.iterations,
              endDelay = _timing2.endDelay;
          var delay = Math.ceil(duration * iterations + endDelay - this.timeline.currentTime) + 1;

          if (this[_finishedDefer] && !this[_finishedDefer].timerID) {
            this[_finishedDefer].timerID = this.timeline.setTimeout(function () {
              _this3[_finishedDefer].resolve();

              _this3[_removeDefer](_readyDefer);

              _this3[_removeDefer](_finishedDefer);
            }, {
              delay: delay,
              heading: false
            });
            this[_finishedDefer].reverseTimerID = this.timeline.setTimeout(function () {
              _this3[_finishedDefer].resolve();

              _this3[_removeDefer](_readyDefer);

              _this3[_removeDefer](_finishedDefer);

              _this3.timeline = null;
            }, {
              delay: -this[_timing].delay - 1,
              heading: false
            });
          }
        }
      }, {
        key: 'play',
        value: function play() {
          if (this.playState === 'finished') {
            this.cancel();
          }

          if (this.playState === 'idle') {
            if (this.playbackRate <= 0) {
              return;
            }

            var _timing3 = this[_timing],
                delay = _timing3.delay,
                playbackRate = _timing3.playbackRate,
                timeline = _timing3.timeline;
            this.timeline = new _spriteTimeline2.default({
              originTime: delay,
              playbackRate: playbackRate
            }, timeline);

            this[_activeReadyTimer]();

            this[_activeFinishTimer]();
          } else if (this.playState === 'paused') {
            this.timeline.playbackRate = this.playbackRate;

            this[_activeReadyTimer]();
          }
        }
      }, {
        key: _removeDefer,
        value: function value(deferID) {
          var defered = this[deferID],
              timeline = this.timeline;

          if (defered && timeline) {
            timeline.clearTimeout(defered.timerID);

            if (defered.reverseTimerID) {
              timeline.clearTimeout(defered.reverseTimerID);
            }
          }

          delete this[deferID];
        }
      }, {
        key: 'cancel',
        value: function cancel() {
          this[_removeDefer](_readyDefer);

          this[_removeDefer](_finishedDefer);

          this.timeline = null;
        }
      }, {
        key: 'finish',
        value: function finish() {
          if (this.timeline) {
            this.timeline.currentTime = Infinity / this.playbackRate;
          }

          this[_removeDefer](_readyDefer);

          this[_removeDefer](_finishedDefer);
        }
      }, {
        key: 'applyEffects',
        value: function applyEffects(effects) {
          return (0, _assign2.default)(this[_effects], effects);
        }
      }, {
        key: 'playbackRate',
        get: function get() {
          return this[_timing].playbackRate;
        },
        set: function set(rate) {
          if (this.timeline) {
            this.timeline.playbackRate = rate;
          }

          this[_timing].playbackRate = rate;
        }
      }, {
        key: 'playState',
        get: function get() {
          var timeline = this.timeline,
              _timing4 = this[_timing],
              iterations = _timing4.iterations,
              duration = _timing4.duration,
              endDelay = _timing4.endDelay;
          var state = 'running';

          if (timeline == null) {
            state = 'idle';
          } else if (timeline.paused) {
            state = 'paused';
          } else if (timeline.currentTime < 0) {
            // 开始 pending
            state = 'pending';
          } else {
            var ed = timeline.currentTime - iterations * duration;

            if (ed > 0 && ed < endDelay) {
              // 结束 pending
              state = 'pending';
            } else if (ed >= endDelay) {
              state = 'finished';
            }
          }

          return state;
        }
      }, {
        key: 'progress',
        get: function get() {
          if (!this.timeline) return 0;
          var _timing5 = this[_timing],
              duration = _timing5.duration,
              iterations = _timing5.iterations;
          var timeline = this.timeline,
              playState = this.playState;
          var p = void 0;

          if (playState === 'idle') {
            p = 0;
          } else if (playState === 'paused' && timeline.currentTime < 0) {
            p = 0;
          } else if (playState === 'pending') {
            if (timeline.currentTime < 0) {
              p = 0;
            } else {
              var time = timeline.seekLocalTime(iterations * duration);
              p = (0, utils$1.periodicity)(time, duration)[1] / duration;
            }
          } else if (playState === 'running' || playState === 'paused') {
            p = (0, utils$1.periodicity)(timeline.currentTime, duration)[1] / duration;
          }

          if (playState === 'finished') {
            p = (0, utils$1.periodicity)(iterations, 1)[1];
          }

          return p;
        }
      }, {
        key: 'frame',
        get: function get() {
          var playState = this.playState,
              initState = this[_initState],
              fill = this[_timing].fill;

          if (playState === 'idle') {
            return initState;
          }

          var currentTime = this.timeline.currentTime,
              keyframes = this[_keyframes].slice(0);

          var _getProgress = (0, utils$1.getProgress)(this.timeline, this[_timing], this.progress),
              p = _getProgress.p,
              inverted = _getProgress.inverted;

          var frameState = initState;

          if (currentTime < 0 && playState === 'pending') {
            // 在开始前 delay 阶段
            if (fill === 'backwards' || fill === 'both') {
              frameState = inverted ? keyframes[keyframes.length - 1] : keyframes[0];
            }
          } else if (playState !== 'pending' && playState !== 'finished' || fill === 'forwards' || fill === 'both') {
            // 不在 endDelay 或结束状态，或 forwards
            frameState = (0, utils$1.getCurrentFrame)(this[_timing], keyframes, this[_effects], p);
          }

          return frameState;
        }
      }, {
        key: 'timing',
        get: function get() {
          return this[_timing];
        }
      }, {
        key: 'effects',
        get: function get() {
          return this[_effects];
        }
      }, {
        key: 'baseTimeline',
        set: function set(timeline) {
          this[_timing].timeline = timeline;
        },
        get: function get() {
          return this[_timing].timeline;
        }
      }, {
        key: 'ready',
        get: function get() {
          if (this[_readyDefer]) {
            return this[_readyDefer].promise;
          }

          if (this.timeline && this.timeline.currentTime >= 0) {
            if (this.playState !== 'paused') {
              return _promise2.default.resolve();
            }
          }

          this[_readyDefer] = (0, utils$1.defer)();

          if (this.timeline) {
            // 已经在 pending 状态
            this[_activeReadyTimer]();
          }

          if (this[_readyDefer]) {
            return this[_readyDefer].promise;
          }

          return _promise2.default.resolve();
        }
      }, {
        key: 'finished',
        get: function get() {
          if (this.playState === 'finished') {
            return _promise2.default.resolve();
          }

          if (!this[_finishedDefer]) {
            this[_finishedDefer] = (0, utils$1.defer)();

            if (this.timeline) {
              this[_activeFinishTimer]();
            }
          }

          return this[_finishedDefer].promise;
        }
      }]);
      return _class;
    }();

    exports.default = _class;
  });
  unwrapExports(animator);

  var lib$3 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Timeline = exports.Effects = exports.Easings = exports.Animator = undefined;

    var _spriteTimeline2 = _interopRequireDefault(lib$4);

    var _effect2 = _interopRequireDefault(effect);

    var _animator2 = _interopRequireDefault(animator);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    exports.Animator = _animator2.default;
    exports.Easings = easing.Easings;
    exports.Effects = _effect2.default;
    exports.Timeline = _spriteTimeline2.default;
  });
  unwrapExports(lib$3);
  lib$3.Timeline;
  lib$3.Effects;
  lib$3.Easings;
  lib$3.Animator;

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  /**
   * @module color-parse
   */
  /**
   * Base hues
   * http://dev.w3.org/csswg/css-color/#typedef-named-hue
   */
  //FIXME: use external hue detector

  var baseHues = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
  };
  /**
   * Parse color from the string passed
   *
   * @return {Object} A space indicator `space`, an array `values` and `alpha`
   */

  function parse$2(cstr) {
    var m,
        parts = [],
        alpha = 1,
        space;

    if (typeof cstr === 'string') {
      //keyword
      if (colorName[cstr]) {
        parts = colorName[cstr].slice();
        space = 'rgb';
      } //reserved words
      else if (cstr === 'transparent') {
        alpha = 0;
        space = 'rgb';
        parts = [0, 0, 0];
      } //hex
      else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
        var base = cstr.slice(1);
        var size = base.length;
        var isShort = size <= 4;
        alpha = 1;

        if (isShort) {
          parts = [parseInt(base[0] + base[0], 16), parseInt(base[1] + base[1], 16), parseInt(base[2] + base[2], 16)];

          if (size === 4) {
            alpha = parseInt(base[3] + base[3], 16) / 255;
          }
        } else {
          parts = [parseInt(base[0] + base[1], 16), parseInt(base[2] + base[3], 16), parseInt(base[4] + base[5], 16)];

          if (size === 8) {
            alpha = parseInt(base[6] + base[7], 16) / 255;
          }
        }

        if (!parts[0]) parts[0] = 0;
        if (!parts[1]) parts[1] = 0;
        if (!parts[2]) parts[2] = 0;
        space = 'rgb';
      } //color space
      else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
        var name = m[1];
        var isRGB = name === 'rgb';
        var base = name.replace(/a$/, '');
        space = base;
        var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3;
        parts = m[2].trim().split(/\s*[,\/]\s*|\s+/).map(function (x, i) {
          //<percentage>
          if (/%$/.test(x)) {
            //alpha
            if (i === size) return parseFloat(x) / 100; //rgb

            if (base === 'rgb') return parseFloat(x) * 255 / 100;
            return parseFloat(x);
          } //hue
          else if (base[i] === 'h') {
            //<deg>
            if (/deg$/.test(x)) {
              return parseFloat(x);
            } //<base-hue>
            else if (baseHues[x] !== undefined) {
              return baseHues[x];
            }
          }

          return parseFloat(x);
        });
        if (name === base) parts.push(1);
        alpha = isRGB ? 1 : parts[size] === undefined ? 1 : parts[size];
        parts = parts.slice(0, size);
      } //named channels case
      else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
        parts = cstr.match(/([0-9]+)/g).map(function (value) {
          return parseFloat(value);
        });
        space = cstr.match(/([a-z])/ig).join('').toLowerCase();
      }
    } //numeric case
    else if (!isNaN(cstr)) {
      space = 'rgb';
      parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff];
    } //array-like
    else if (Array.isArray(cstr) || cstr.length) {
      parts = [cstr[0], cstr[1], cstr[2]];
      space = 'rgb';
      alpha = cstr.length === 4 ? cstr[3] : 1;
    } //object case - detects css cases of rgb and hsl
    else if (cstr instanceof Object) {
      if (cstr.r != null || cstr.red != null || cstr.R != null) {
        space = 'rgb';
        parts = [cstr.r || cstr.red || cstr.R || 0, cstr.g || cstr.green || cstr.G || 0, cstr.b || cstr.blue || cstr.B || 0];
      } else {
        space = 'hsl';
        parts = [cstr.h || cstr.hue || cstr.H || 0, cstr.s || cstr.saturation || cstr.S || 0, cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness];
      }

      alpha = cstr.a || cstr.alpha || cstr.opacity || 1;
      if (cstr.opacity != null) alpha /= 100;
    }

    return {
      space: space,
      values: parts,
      alpha: alpha
    };
  }

  /**
   * RGB space.
   *
   * @module  color-space/rgb
   */
  var rgb = {
    name: 'rgb',
    min: [0, 0, 0],
    max: [255, 255, 255],
    channel: ['red', 'green', 'blue'],
    alias: ['RGB']
  };

  /**
   * @module color-space/hsl
   */
  var hsl = {
    name: 'hsl',
    min: [0, 0, 0],
    max: [360, 100, 100],
    channel: ['hue', 'saturation', 'lightness'],
    alias: ['HSL'],
    rgb: function (hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);

        if (t3 < 0) {
          t3++;
        } else if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }
  }; //extend rgb

  rgb.hsl = function (rgb) {
    var r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        delta = max - min,
        h,
        s,
        l;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  /** @module  color-rgba */
  function rgba(color) {
    // template literals
    if (Array.isArray(color) && color.raw) color = String.raw(...arguments);
    var values; //attempt to parse non-array arguments

    var parsed = parse$2(color);
    if (!parsed.space) return [];
    const min = parsed.space[0] === 'h' ? hsl.min : rgb.min;
    const max = parsed.space[0] === 'h' ? hsl.max : rgb.max;
    values = Array(3);
    values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
    values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
    values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);

    if (parsed.space[0] === 'h') {
      values = hsl.rgb(values);
    }

    values.push(Math.min(Math.max(parsed.alpha, 0), 1));
    return values;
  }

  var colorRgba = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': rgba
  });

  var require$$8 = getCjsExportFromNamespace(colorRgba);

  var animation = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _extends2 = interopRequireDefault(_extends_1);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _colorRgba = interopRequireDefault(require$$8);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function parseValue(v) {
      if (typeof v === 'string') {
        v = v.trim();
        if (/^[0-9.]+%$/.test(v)) return parseFloat(v) / 100;
        if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(v)) return (0, attribute_value.sizeToPixel)(v); // const c = rgba(v);
        // return c.length > 0 ? c : v;
      }

      return v;
    }

    function colorEffect(from, to, p, s, e) {
      if (typeof from === 'string') from = (0, _colorRgba.default)(from);
      if (typeof to === 'string') to = (0, _colorRgba.default)(to);
      return lib$3.Effects.default(from, to, p, s, e);
    }

    function stringEffect(from, to, p, s, e) {
      return lib$3.Effects.default(from, to, p, s, e);
    }

    lib$3.Effects.default = function (from, to, p, s, e) {
      if (Array.isArray(from) && Array.isArray(to)) {
        return from.map(function (v, i) {
          return v + (p - s) / (e - s) * (to[i] - v);
        });
      }

      if (typeof from === 'number' && typeof to === 'number') {
        return from + (p - s) / (e - s) * (to - from);
      }

      if (p - s > e - p) {
        return to;
      }

      return from;
    };

    lib$3.Effects.fillColor = colorEffect;
    lib$3.Effects.strokeColor = colorEffect;
    lib$3.Effects.bgcolor = colorEffect;
    lib$3.Effects.borderColor = colorEffect;
    lib$3.Effects.text = stringEffect;

    var Animation = /*#__PURE__*/function (_Animator) {
      (0, _inherits2.default)(Animation, _Animator);

      var _super = _createSuper(Animation);

      function Animation(sprite, frames, timing) {
        var _this;

        (0, _classCallCheck2.default)(this, Animation);
        var initAttrs = sprite.attr();
        Object.entries(initAttrs).forEach(function (_ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          initAttrs[key] = lib$3.Effects[key] ? value : parseValue(value);
        });
        frames = frames.map(function (_ref3) {
          var frame = (0, _extends2.default)({}, _ref3);
          var ret = {};
          Object.entries(frame).forEach(function (_ref4) {
            var _ref5 = (0, _slicedToArray2.default)(_ref4, 2),
                key = _ref5[0],
                value = _ref5[1];

            ret[key] = lib$3.Effects[key] ? value : parseValue(value);
          });
          return ret;
        });
        _this = _super.call(this, initAttrs, frames, timing);
        _this.target = sprite;

        _this.setter = function (frame, target) {
          target.attr(frame);
        };

        return _this;
      }

      (0, _createClass2.default)(Animation, [{
        key: "finish",
        value: function finish() {
          // finish should change attrs synchronously
          (0, _get2.default)((0, _getPrototypeOf2.default)(Animation.prototype), "finish", this).call(this);
          (0, animationFrame.cancelAnimationFrame)(this.requestId);
          this.setter(this.frame, this.target);
        }
      }, {
        key: "play",
        value: function play() {
          if (!this.target.parent || this.playState === 'running') {
            return;
          }

          (0, _get2.default)((0, _getPrototypeOf2.default)(Animation.prototype), "play", this).call(this);
          this.setter(this.frame, this.target);
          var that = this;
          this.ready.then(function () {
            that.setter(that.frame, that.target);
            that.requestId = (0, animationFrame.requestAnimationFrame)(function update() {
              var target = that.target;

              if (typeof document !== 'undefined' && document.documentElement && document.documentElement.contains && target.layer && target.layer.canvas && !document.documentElement.contains(target.layer.canvas)) {
                // if dom element has been removed stop animation.
                // it usually occurs in single page applications.
                that.cancel();
                return;
              }

              var playState = that.playState;
              that.setter(that.frame, that.target);
              if (playState === 'idle') return;

              if (playState === 'running') {
                that.requestId = (0, animationFrame.requestAnimationFrame)(update);
              } else if (playState === 'paused' || playState === 'pending' && that.timeline.currentTime < 0) {
                // playbackRate < 0 will cause playState reset to pending...
                that.ready.then(function () {
                  that.setter(that.frame, that.target);
                  that.requestId = (0, animationFrame.requestAnimationFrame)(update);
                });
              }
            });
          });
        }
      }, {
        key: "cancel",
        value: function cancel() {
          var preserveState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          (0, animationFrame.cancelAnimationFrame)(this.requestId);

          if (preserveState) {
            this.setter(this.frame, this.target);
            (0, _get2.default)((0, _getPrototypeOf2.default)(Animation.prototype), "cancel", this).call(this);
          } else {
            (0, _get2.default)((0, _getPrototypeOf2.default)(Animation.prototype), "cancel", this).call(this);
            this.setter(this.frame, this.target);
          }
        }
      }, {
        key: "playState",
        get: function get() {
          if (!this.target.parent) {
            return 'idle';
          }

          return (0, _get2.default)((0, _getPrototypeOf2.default)(Animation.prototype), "playState", this);
        }
      }, {
        key: "finished",
        get: function get() {
          var _this2 = this; // set last frame when finished
          // because while the web page is not focused
          // requestAnimationFrame will not trigger while deferTime of
          // the animator is still running


          return (0, _get2.default)((0, _getPrototypeOf2.default)(Animation.prototype), "finished", this).then(function () {
            var that = _this2;
            return new Promise(function (resolve) {
              function update() {
                that.setter(that.frame, that.target);
                var playState = that.playState;

                if (playState === 'finished' || playState === 'idle') {
                  (0, animationFrame.cancelAnimationFrame)(that.requestId);
                  resolve();
                } else {
                  (0, animationFrame.requestAnimationFrame)(update);
                }
              }

              update();
            });
          });
        }
      }]);
      return Animation;
    }(lib$3.Animator);

    exports.default = Animation;
  });
  unwrapExports(animation);

  var document$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    esm$1.glMatrix.setMatrixArrayType(Array);
    var nodeMap = new Map();

    function createElement(nodeName) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      nodeName = nodeName.toLowerCase();
      var Element = nodeMap.get(nodeName);
      if (!Element) throw new TypeError("Invalid node: ".concat(nodeName));
      var elem = new Element(attrs);
      children.forEach(function (child) {
        elem.appendChild(child);
      });
      return elem;
    }

    var ownerDocument = {
      registerNode: function registerNode(Node, nodeName) {
        var nodeType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
        nodeName = nodeName.toLowerCase();
        if (nodeMap.has(nodeName)) throw new TypeError("Cannot registerNode, ".concat(nodeName, " has been taken."));
        nodeMap.set(nodeName, Node);
        Object.defineProperties(Node.prototype, {
          nodeType: {
            value: nodeType
          },
          tagName: {
            value: nodeName.toUpperCase()
          },
          nodeName: {
            value: nodeName
          },
          ownerDocument: {
            value: ownerDocument
          },
          namespaceURI: {
            value: "http://spritejs.com/".concat(nodeName)
          }
        });
      },
      createElement: createElement,
      createElementNS: function createElementNS(uri, name) {
        return createElement(name);
      },
      isSpriteNode: function isSpriteNode(nodeName) {
        return nodeMap.has(nodeName.toLowerCase());
      }
    };
    var _default = ownerDocument;
    exports.default = _default;
  });
  unwrapExports(document$1);

  var event = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    var _type = Symbol('type');

    var _bubbles = Symbol('bubbles');

    var _originalEvent = Symbol('originalEvent');

    var _detail = Symbol('detail');

    var Event = /*#__PURE__*/function () {
      function Event(originalEvent) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$bubbles = _ref.bubbles,
            bubbles = _ref$bubbles === void 0 ? null : _ref$bubbles;

        (0, _classCallCheck2.default)(this, Event);

        if (typeof originalEvent === 'string') {
          this[_type] = originalEvent;
          this[_bubbles] = !!bubbles;
        } else {
          this[_type] = originalEvent.type;
          this[_originalEvent] = originalEvent;
          this[_bubbles] = bubbles != null ? !!bubbles : !!originalEvent.bubbles;

          if (originalEvent.detail) {
            this[_detail] = originalEvent.detail;
          }
        }

        if (!this[_type]) throw new TypeError('Invalid event type.');
        this.cancelBubble = false;
      }

      (0, _createClass2.default)(Event, [{
        key: "setOriginalEvent",
        value: function setOriginalEvent(originalEvent) {
          this[_originalEvent] = originalEvent;
        }
      }, {
        key: "stopPropagation",
        value: function stopPropagation() {
          this.cancelBubble = true;
        }
      }, {
        key: "originalEvent",
        get: function get() {
          return this[_originalEvent];
        }
      }, {
        key: "type",
        get: function get() {
          return this[_type];
        }
      }, {
        key: "bubbles",
        get: function get() {
          return this[_bubbles];
        }
      }, {
        key: "detail",
        get: function get() {
          return this[_detail];
        }
      }]);
      return Event;
    }();

    exports.default = Event;
  });
  unwrapExports(event);

  var filter$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseFilterString = parseFilterString;
    exports.applyFilters = applyFilters;

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function parseFilterString(filterStr) {
      filterStr = filterStr.trim();
      if (!filterStr || filterStr === 'none') return null;
      var filterReg = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i;
      var filters = filterStr.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig);
      var ret = [];

      if (filters) {
        filters.forEach(function (filter) {
          var matched = filter.match(filterReg);
          if (!matched) throw new TypeError('Invalid fitler string.');

          var _matched = (0, _slicedToArray2.default)(matched, 3),
              type = _matched[1],
              args = _matched[2];

          type = type.toLowerCase();
          args = args.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map(function (n, i) {
            var value;

            if (type === 'url' || type === 'drop-shadow' && i === 3) {
              value = n;
            } else {
              value = (0, attribute_value.toNumber)(n);
            }

            if (/%$/.test(n)) {
              value /= 100;
            }

            return value;
          });
          ret.push({
            type: type,
            args: args
          });
        });
      }

      return ret;
    }

    function applyFilters(mesh, filters) {
      mesh.clearFilter();

      if (filters) {
        filters.forEach(function (_ref) {
          var type = _ref.type,
              args = _ref.args;
          var method = type;
          if (method === 'drop-shadow') method = 'dropShadow';else if (method === 'hue-rotate') method = 'hueRotate';
          mesh[method].apply(mesh, (0, _toConsumableArray2.default)(args));
        });
      }
    }
  });
  unwrapExports(filter$1);
  filter$1.parseFilterString;
  filter$1.applyFilters;

  var render_event = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = applyRenderEvent;
    esm$1.glMatrix.setMatrixArrayType(Array);

    function applyRenderEvent(target, mesh) {
      if (!mesh) return;
      var beforeRenderHandlers = target.getListeners('beforerender');
      var afterRenderHandlers = target.getListeners('afterrender');

      if (beforeRenderHandlers.length && !mesh.beforeRender) {
        mesh.beforeRender = function (context) {
          target.dispatchEvent({
            type: 'beforerender',
            detail: {
              context: context
            }
          });
        };
      } else if (!beforeRenderHandlers.length) {
        mesh.beforeRender = null;
      }

      if (afterRenderHandlers.length && !mesh.afterRender) {
        mesh.afterRender = function (context) {
          target.dispatchEvent({
            type: 'afterrender',
            detail: {
              context: context
            }
          });
        };
      } else if (!afterRenderHandlers.length) {
        mesh.afterRender = null;
      }
    }
  });
  unwrapExports(render_event);

  var node = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _typeof2 = interopRequireDefault(_typeof_1);

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _node = interopRequireDefault(node$1);

    var _animation2 = interopRequireDefault(animation);

    var _document = interopRequireDefault(document$1);

    var _event = interopRequireDefault(event);

    var _render_event = interopRequireDefault(render_event);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            (0, _defineProperty2.default)(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    var changedAttrs = Symbol.for('spritejs_changedAttrs');
    var attributes = Symbol.for('spritejs_attributes');

    var _resolution = Symbol('resolution');

    var _animations = Symbol('animations');

    var _eventListeners = Symbol('eventListeners');

    var _captureEventListeners = Symbol('captureEventListeners');

    var _filters = Symbol('filters');

    var _display = Symbol('display');

    var _program = Symbol('program');

    var _shaderAttrs = Symbol('shaderAttrs');

    var _uniforms = Symbol('uniforms');

    var Node = /*#__PURE__*/function () {
      function Node() {
        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Node);
        this.attributes = new this.constructor.Attr(this);
        this[_resolution] = {
          width: 300,
          height: 150
        };
        Object.assign(this.attributes, attrs); // if(Object.seal) {
        //   Object.seal(this.attributes);
        // }

        this[_animations] = new Set();
        this[_eventListeners] = {};
        this[_captureEventListeners] = {};
      }

      (0, _createClass2.default)(Node, [{
        key: "activateAnimations",
        value: function activateAnimations() {
          var layer = this.layer;

          if (layer) {
            var animations = this[_animations];
            animations.forEach(function (animation) {
              animation.baseTimeline = layer.timeline;
              animation.play();
              animation.finished.then(function () {
                animations.delete(animation);
              });
            });
            var children = this.children;

            if (children) {
              children.forEach(function (child) {
                if (child.activateAnimations) child.activateAnimations();
              });
            }
          }
        }
      }, {
        key: "addEventListener",
        value: function addEventListener(type, listener) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          if (type === 'mousewheel') type = 'wheel';
          if (typeof options === 'boolean') options = {
            capture: options
          };
          var _options = options,
              capture = _options.capture,
              once = _options.once;
          var eventListeners = capture ? _captureEventListeners : _eventListeners;
          this[eventListeners][type] = this[eventListeners][type] || [];
          this[eventListeners][type].push({
            listener: listener,
            once: once
          });
          return this;
        }
      }, {
        key: "animate",
        value: function animate(frames, timing) {
          var _this = this;

          var animation = new _animation2.default(this, frames, timing);
          if (this.effects) animation.applyEffects(this.effects);

          if (this.layer) {
            animation.baseTimeline = this.layer.timeline;
            animation.play();
            animation.finished.then(function () {
              _this[_animations].delete(animation);
            });
          }

          this[_animations].add(animation);

          return animation;
        }
      }, {
        key: "attr",
        value: function attr() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (args.length === 0) return this.attributes[attributes];

          if (args.length > 1) {
            var key = args[0],
                value = args[1];

            if (typeof value === 'function') {
              value = value(this.attr(key));
            }

            this.setAttribute(key, value);
            return this;
          }

          if (typeof args[0] === 'string') {
            return this.getAttribute(args[0]);
          }

          Object.assign(this.attributes, args[0]);
          return this;
        }
      }, {
        key: "cloneNode",
        value: function cloneNode() {
          var cloned = new this.constructor();
          var attrs = this.attributes[changedAttrs];
          cloned.attr(attrs);
          return cloned;
        }
      }, {
        key: "connect",
        value: function connect(parent, zOrder) {
          Object.defineProperty(this, 'parent', {
            value: parent,
            writable: false,
            configurable: true
          });
          Object.defineProperty(this, 'zOrder', {
            value: zOrder,
            writable: false,
            configurable: true
          });
          if (parent.timeline) this.activateAnimations();
          this.setResolution(parent.getResolution());
          this.forceUpdate();
          this.dispatchEvent({
            type: 'append',
            detail: {
              parent: parent,
              zOrder: zOrder
            }
          });
        }
      }, {
        key: "contains",
        value: function contains(node) {
          while (node && this !== node) {
            node = node.parent;
          }

          return !!node;
        }
      }, {
        key: "deactivateAnimations",
        value: function deactivateAnimations() {
          this[_animations].forEach(function (animation) {
            return animation.cancel();
          });

          var children = this.children;

          if (children) {
            children.forEach(function (child) {
              if (child.deactivateAnimations) child.deactivateAnimations();
            });
          }
        }
      }, {
        key: "disconnect",
        value: function disconnect() {
          var parent = this.parent,
              zOrder = this.zOrder;
          delete this.parent;
          delete this.zOrder;
          this.deactivateAnimations();
          this.dispatchEvent({
            type: 'remove',
            detail: {
              parent: parent,
              zOrder: zOrder
            }
          });
          if (parent) parent.forceUpdate();
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          var _this2 = this;

          if (!(event instanceof _event.default)) {
            event = new _event.default(event);
          }

          event.target = this;
          var type = event.type;
          if (type === 'mousewheel') type = 'wheel';
          var elements = [this];
          var parent = this.parent;

          while (event.bubbles && parent) {
            elements.push(parent);
            parent = parent.parent;
          } // capture phase


          for (var i = elements.length - 1; i >= 0; i--) {
            var element = elements[i];
            var listeners = element[_captureEventListeners] && element[_captureEventListeners][type];

            if (listeners && listeners.length) {
              event.currentTarget = element;
              listeners.forEach(function (_ref) {
                var listener = _ref.listener,
                    once = _ref.once;
                listener.call(_this2, event);
                if (once) elements.removeEventListener(listener);
              });
              delete event.currentTarget;
            }

            if (!event.bubbles && event.cancelBubble) break;
          } // bubbling


          if (!event.cancelBubble) {
            for (var _i = 0; _i < elements.length; _i++) {
              var _element = elements[_i];

              var _listeners = _element[_eventListeners] && _element[_eventListeners][type];

              if (_listeners && _listeners.length) {
                event.currentTarget = _element;

                _listeners.forEach(function (_ref2) {
                  var listener = _ref2.listener,
                      once = _ref2.once;
                  listener.call(_this2, event);
                  if (once) elements.removeEventListener(listener);
                });

                delete event.currentTarget;
              }

              if (!event.bubbles || event.cancelBubble) break;
            }
          }
        }
      }, {
        key: "dispatchPointerEvent",
        value: function dispatchPointerEvent(event) {
          var x = event.layerX,
              y = event.layerY;

          if (this.isPointCollision(x, y)) {
            this.dispatchEvent(event);
            return true;
          }

          return false;
        }
      }, {
        key: "draw",
        value: function draw() {
          var _this3 = this;

          var meshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var mesh = this.mesh;

          if (mesh) {
            (0, filter$1.applyFilters)(mesh, this.filters);
            meshes.push(mesh);

            if (this[_program]) {
              mesh.setProgram(this[_program]);
              var shaderAttrs = this[_shaderAttrs];

              if (shaderAttrs) {
                Object.entries(shaderAttrs).forEach(function (_ref3) {
                  var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
                      key = _ref4[0],
                      setter = _ref4[1];

                  mesh.setAttribute(key, setter);
                });
              }

              var uniforms = this[_uniforms];

              if (this[_uniforms]) {
                var _uniform = {};
                Object.entries(uniforms).forEach(function (_ref5) {
                  var _ref6 = (0, _slicedToArray2.default)(_ref5, 2),
                      key = _ref6[0],
                      value = _ref6[1];

                  if (typeof value === 'function') {
                    value = value(_this3, key);
                  }

                  _uniform[key] = value;
                });
                mesh.setUniforms(_uniform);
              }
            }

            (0, _render_event.default)(this, mesh);
          }

          return meshes;
        }
      }, {
        key: "forceUpdate",
        value: function forceUpdate() {
          if (this.parent) this.parent.forceUpdate();
        }
      }, {
        key: "getAttribute",
        value: function getAttribute(key) {
          return this.attributes[key];
        }
      }, {
        key: "getListeners",
        value: function getListeners(type) {
          var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref7$capture = _ref7.capture,
              capture = _ref7$capture === void 0 ? false : _ref7$capture;

          var eventListeners = capture ? _captureEventListeners : _eventListeners;
          return (0, _toConsumableArray2.default)(this[eventListeners][type] || []);
        }
      }, {
        key: "getNodeNearBy",
        value: function getNodeNearBy() {
          var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          if (!this.parent) return null;
          if (distance === 0) return this;
          var children = this.parent.children;
          var idx = children.indexOf(this);
          return children[idx + distance];
        }
      }, {
        key: "getWorldPosition",
        value: function getWorldPosition(offsetX, offsetY) {
          var m = this.renderMatrix;
          var x = offsetX * m[0] + offsetY * m[2] + m[4];
          var y = offsetX * m[1] + offsetY * m[3] + m[5];
          return [x, y];
        }
      }, {
        key: "getOffsetPosition",
        value: function getOffsetPosition(x, y) {
          var m = esm$1.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix);

          var offsetX = x * m[0] + y * m[2] + m[4];
          var offsetY = x * m[1] + y * m[3] + m[5];
          return [offsetX, offsetY];
        }
      }, {
        key: "getResolution",
        value: function getResolution() {
          return _objectSpread({}, this[_resolution]);
        }
      }, {
        key: "isPointCollision",
        value: function isPointCollision(x, y) {
          if (!this.mesh) return false;
          var pointerEvents = this.attributes.pointerEvents;
          if (pointerEvents === 'none') return false;
          if (pointerEvents !== 'all' && !this.isVisible) return false;
          var which = 'both';
          if (pointerEvents === 'visibleFill') which = 'fill';
          if (pointerEvents === 'visibleStroke') which = 'stroke';
          return this.mesh.isPointCollision(x, y, which);
        }
      }, {
        key: "onPropertyChange",
        value: function onPropertyChange(key, newValue, oldValue) {
          if (key !== 'id' && key !== 'name' && key !== 'className' && key !== 'pointerEvents' && key !== 'passEvents') {
            this.forceUpdate();
          }

          if (key === 'filter') {
            this[_filters] = (0, filter$1.parseFilterString)(newValue);
          }

          if (key === 'zIndex' && this.parent) {
            this.parent.reorder();
          }
        }
      }, {
        key: "setAttribute",
        value: function setAttribute(key, value) {
          if (key === 'attrs') {
            this.attr(value);
          }

          this.attributes[key] = value;
        }
      }, {
        key: "setMouseCapture",
        value: function setMouseCapture() {
          if (this.layer) {
            this.layer.__mouseCapturedTarget = this;
          }
        } // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)

      }, {
        key: "setProgram",
        value: function setProgram(program) {
          this[_program] = program;
          this.forceUpdate();
        }
      }, {
        key: "setShaderAttribute",
        value: function setShaderAttribute(attrName, setter) {
          this[_shaderAttrs] = this[_shaderAttrs] || {};
          this[_shaderAttrs][attrName] = setter;
          this.forceUpdate();
        }
      }, {
        key: "setUniforms",
        value: function setUniforms(uniforms) {
          this[_uniforms] = this[_uniforms] || {};
          Object.assign(this[_uniforms], uniforms);
          this.forceUpdate();
        }
      }, {
        key: "setResolution",
        value: function setResolution(_ref8) {
          var width = _ref8.width,
              height = _ref8.height;
          var _this$_resolution = this[_resolution],
              w = _this$_resolution.width,
              h = _this$_resolution.height;

          if (w !== width || h !== height) {
            this[_resolution] = {
              width: width,
              height: height
            }; // this.updateContours();

            this.forceUpdate();
            this.dispatchEvent({
              type: 'resolutionchange',
              detail: {
                width: width,
                height: height
              }
            });
          }
        }
      }, {
        key: "show",
        value: function show() {
          if (this.attributes.display === 'none') {
            this.attributes.display = this[_display] || '';
          }
        }
      }, {
        key: "hide",
        value: function hide() {
          if (this.attributes.display !== 'none') {
            this[_display] = this.attributes.display;
            this.attributes.display = 'none';
          }
        }
      }, {
        key: "releaseMouseCapture",
        value: function releaseMouseCapture() {
          if (this.layer && this.layer.__mouseCapturedTarget === this) {
            this.layer.__mouseCapturedTarget = null;
          }
        }
      }, {
        key: "remove",
        value: function remove() {
          if (this.parent && this.parent.removeChild) {
            this.parent.removeChild(this);
            return true;
          }

          return false;
        }
      }, {
        key: "removeAllListeners",
        value: function removeAllListeners(type) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (typeof options === 'boolean') options = {
            capture: options
          };
          var capture = options.capture;
          var eventListeners = capture ? _captureEventListeners : _eventListeners;

          if (this[eventListeners][type]) {
            this[eventListeners][type] = [];
          }

          return this;
        }
      }, {
        key: "removeAttribute",
        value: function removeAttribute(key) {
          this.setAttribute(key, null);
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener(type, listener) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          if (typeof options === 'boolean') options = {
            capture: options
          };
          var capture = options.capture;
          var eventListeners = capture ? _captureEventListeners : _eventListeners;

          if (this[eventListeners][type]) {
            var listeners = this[eventListeners][type];

            if (listeners) {
              for (var i = 0; i < listeners.length; i++) {
                var _listener = listeners[i].listener;

                if (_listener === listener) {
                  this[eventListeners][type].splice(i, 1);
                  break;
                }
              }
            }
          }

          return this;
        }
      }, {
        key: "transition",
        value: function transition(sec) {
          var _ref11;

          var easing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'linear';

          var that = this,
              _animation = Symbol('animation');

          easing = easing || 'linear';
          var delay = 0;

          if ((0, _typeof2.default)(sec) === 'object') {
            delay = sec.delay || 0;
            sec = sec.duration;
          }

          return _ref11 = {}, (0, _defineProperty2.default)(_ref11, _animation, null), (0, _defineProperty2.default)(_ref11, "cancel", function cancel() {
            var preserveState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var animation = this[_animation];

            if (animation) {
              animation.cancel(preserveState);
            }
          }), (0, _defineProperty2.default)(_ref11, "end", function end() {
            var animation = this[_animation];

            if (animation && (animation.playState === 'running' || animation.playState === 'pending')) {
              animation.finish();
            }
          }), (0, _defineProperty2.default)(_ref11, "reverse", function reverse() {
            var animation = this[_animation];

            if (animation) {
              if (animation.playState === 'running' || animation.playState === 'pending') {
                animation.playbackRate = -animation.playbackRate;
              } else {
                var direction = animation.timing.direction;
                animation.timing.direction = direction === 'reverse' ? 'normal' : 'reverse';
                animation.play();
              }
            }

            return animation.finished;
          }), (0, _defineProperty2.default)(_ref11, "attr", function attr(prop, val) {
            this.end();

            if (typeof prop === 'string') {
              prop = (0, _defineProperty2.default)({}, prop, val);
            }

            Object.entries(prop).forEach(function (_ref9) {
              var _ref10 = (0, _slicedToArray2.default)(_ref9, 2),
                  key = _ref10[0],
                  value = _ref10[1];

              if (typeof value === 'function') {
                prop[key] = value(that.attr(key));
              }
            });
            this[_animation] = that.animate([prop], {
              duration: sec * 1000,
              delay: delay * 1000,
              fill: 'forwards',
              easing: easing
            });
            return this[_animation].finished;
          }), _ref11;
        }
      }, {
        key: "updateContours",
        value: function updateContours() {// override
        }
      }, {
        key: "ancestors",
        get: function get() {
          var parent = this.parent;
          var ret = [];

          while (parent) {
            ret.push(parent);
            parent = parent.parent;
          }

          return ret;
        }
      }, {
        key: "animations",
        get: function get() {
          return this[_animations];
        }
      }, {
        key: "filters",
        get: function get() {
          return this[_filters] || this.parent && this.parent.filters;
        }
      }, {
        key: "isVisible",
        get: function get() {
          return false;
        }
      }, {
        key: "layer",
        get: function get() {
          if (this.parent) return this.parent.layer;
          return null;
        }
      }, {
        key: "localMatrix",
        get: function get() {
          var m = this.transformMatrix;
          var _this$attributes = this.attributes,
              x = _this$attributes.x,
              y = _this$attributes.y;
          m[4] += x;
          m[5] += y;
          return m;
        }
      }, {
        key: "opacity",
        get: function get() {
          var opacity = this.attributes.opacity;

          if (this.parent && this.parent.opacity != null) {
            opacity *= this.parent.opacity;
          }

          return opacity;
        }
      }, {
        key: "parentNode",
        get: function get() {
          return this.parent;
        }
      }, {
        key: "nextSibling",
        get: function get() {
          return this.getNodeNearBy(1);
        }
      }, {
        key: "previousSibling",
        get: function get() {
          return this.getNodeNearBy(-1);
        }
      }, {
        key: "program",
        get: function get() {
          return this[_program];
        }
        /* get parent defined by connect method */

      }, {
        key: "renderer",
        get: function get() {
          if (this.parent) return this.parent.renderer;
          return null;
        }
      }, {
        key: "renderMatrix",
        get: function get() {
          if (this.__cacheRenderMatrix) return this.__cacheRenderMatrix;
          var m = this.localMatrix;
          var parent = this.parent;

          if (parent) {
            var renderMatrix = parent.__cacheRenderMatrix || parent.renderMatrix;

            if (renderMatrix) {
              m = esm$1.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), renderMatrix, m);
            }
          }

          return m;
        }
      }, {
        key: "worldScaling",
        get: function get() {
          var m = this.renderMatrix;
          return [Math.hypot(m[0], m[1]), Math.hypot(m[2], m[3])];
        }
      }, {
        key: "worldRotation",
        get: function get() {
          var m = this.renderMatrix;
          return Math.atan2(m[1], m[3]);
        }
      }, {
        key: "worldPosition",
        get: function get() {
          var m = this.renderMatrix;
          return [m[4], m[5]];
        }
      }, {
        key: "uniforms",
        get: function get() {
          return this[_uniforms];
        }
        /* get zOrder defined by connect method */

        /* attributes */

      }, {
        key: "className",
        get: function get() {
          return this.attributes.className;
        },
        set: function set(value) {
          this.attributes.className = value;
        }
      }, {
        key: "id",
        get: function get() {
          return this.attributes.id;
        },
        set: function set(value) {
          this.attributes.id = value;
        }
      }, {
        key: "name",
        get: function get() {
          return this.attributes.name;
        },
        set: function set(value) {
          this.attributes.name = value;
        }
      }, {
        key: "zIndex",
        get: function get() {
          return this.attributes.zIndex;
        },
        set: function set(value) {
          this.attributes.zIndex = value;
        }
      }, {
        key: "mesh",
        get: function get() {
          return null;
        }
      }, {
        key: "shaderAttrs",
        get: function get() {
          return this[_shaderAttrs] || {};
        }
      }]);
      return Node;
    }();

    exports.default = Node;
    (0, _defineProperty2.default)(Node, "Attr", _node.default);

    _document.default.registerNode(Node, 'node');
  });
  unwrapExports(node);

  var regeneratorRuntime$1 = createCommonjsModule(function (module) {
    var _typeof = _typeof_1["default"];

    function _regeneratorRuntime() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {},
          Op = Object.prototype,
          hasOwn = Op.hasOwnProperty,
          $Symbol = "function" == typeof Symbol ? Symbol : {},
          iteratorSymbol = $Symbol.iterator || "@@iterator",
          asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
          toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }

      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function (innerFn, self, context) {
          var state = "suspendedStart";
          return function (method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");

            if ("completed" === state) {
              if ("throw" === method) throw arg;
              return doneResult();
            }

            for (context.method = method, context.arg = arg;;) {
              var delegate = context.delegate;

              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);

                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }

              if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                if ("suspendedStart" === state) throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self, context);

              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }

              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }(innerFn, self, context), generator;
      }

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      exports.wrap = wrap;
      var ContinueSentinel = {};

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {}

      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
          NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if ("throw" !== record.type) {
            var result = record.arg,
                value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }

          reject(record.arg);
        }

        var previousPromise;

        this._invoke = function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }

      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (undefined === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }

      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              for (; ++i < iterable.length;) {
                if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              }

              return next.value = undefined, next.done = !0, next;
            };

            return next.next = next;
          }
        }

        return {
          next: doneResult
        };
      }

      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }

      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }

          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          }
        },
        stop: function stop() {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) throw exception;
          var context = this;

          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
                record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                  hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          }

          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }

    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(regeneratorRuntime$1);

  var regenerator = regeneratorRuntime$1();

  var asyncToGenerator = createCommonjsModule(function (module) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(asyncToGenerator);

  var texture = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.loadTexture = loadTexture;
    exports.applyTexture = applyTexture;
    exports.createTexture = createTexture;
    exports.deleteTexture = deleteTexture;
    exports.drawTexture = drawTexture;
    exports.loadFrames = loadFrames;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _regenerator = interopRequireDefault(regenerator);

    var _asyncToGenerator2 = interopRequireDefault(asyncToGenerator);

    esm$1.glMatrix.setMatrixArrayType(Array);
    var loadedTextures = {};

    function loadTexture(src, alias) {
      if (loadedTextures[src]) return loadedTextures[src];

      var img = mesh.ENV.loadImage(src, {
        alias: alias,
        useImageBitmap: false
      });

      return img != null ? img : src;
    }

    function applyTexture(_x, _x2, _x3) {
      return _applyTexture.apply(this, arguments);
    }

    function _applyTexture() {
      _applyTexture = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(node, image, updateContours) {
        var textureImage, _node$attributes, width, height, textureRect, oldImage;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                textureImage = image;

                if (typeof image === 'string') {
                  textureImage = loadTexture(image);
                }

                if (!(textureImage && typeof textureImage.then === 'function')) {
                  _context.next = 6;
                  break;
                }

                _context.next = 5;
                return textureImage;

              case 5:
                textureImage = _context.sent;

              case 6:
                if (image === node.attributes.texture) {
                  if (textureImage && textureImage.image) {
                    if (textureImage.sourceRect) {
                      node.attributes.sourceRect = textureImage.sourceRect;
                    }

                    node.textureImageRotated = !!textureImage.rotated;
                    textureImage = textureImage.image;
                  }

                  _node$attributes = node.attributes, width = _node$attributes.width, height = _node$attributes.height, textureRect = _node$attributes.textureRect;
                  oldImage = node.textureImage;
                  node.textureImage = textureImage;

                  if (updateContours && oldImage !== textureImage && !textureRect && (width == null || height == null)) {
                    node.updateContours();
                  }

                  node.forceUpdate();
                }

                return _context.abrupt("return", textureImage);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _applyTexture.apply(this, arguments);
    }

    var _textureMap = Symbol('textureMap');

    function createTexture(image, renderer) {
      renderer[_textureMap] = renderer[_textureMap] || new Map();

      if (renderer[_textureMap].has(image)) {
        return renderer[_textureMap].get(image);
      }

      var texture = renderer.createTexture(image);

      if (!/^blob:/.test(image.src) && typeof image.getContext !== 'function') {
        // no cache blobs
        renderer[_textureMap].set(image, texture);
      }

      return texture;
    }

    function deleteTexture(image, renderer) {
      if (renderer[_textureMap] && renderer[_textureMap].has(image)) {
        var texture = renderer[_textureMap].get(image);

        renderer.deleteTexture(texture);

        renderer[_textureMap].delete(image);

        return true;
      }

      return false;
    }

    var _textureContext = Symbol('textureContext');

    function drawTexture(node, mesh) {
      var textureImage = node.textureImage instanceof String // for wechat miniprogram
      ? String(node.textureImage) : node.textureImage;
      var textureImageRotated = node.textureImageRotated;
      var texture = mesh.texture;
      var renderer = node.renderer;

      if (textureImage) {
        var contentRect = node.originalContentRect;
        var textureRect = node.attributes.textureRect;
        var textureRepeat = node.attributes.textureRepeat;
        var sourceRect = node.attributes.sourceRect;

        if (!texture || node[_textureContext] && node[_textureContext] !== renderer || texture.image !== textureImage || texture.options.repeat !== textureRepeat || !(0, attribute_value.compareValue)(texture.options.rect, textureRect) || !(0, attribute_value.compareValue)(texture.options.srcRect, sourceRect)) {
          var newTexture = createTexture(textureImage, renderer);

          if (textureRect) {
            textureRect[0] += contentRect[0];
            textureRect[1] += contentRect[1];
          } else {
            textureRect = contentRect;
          }

          var oldTexture = null;

          if (texture && !renderer[_textureMap].has(texture.image) && (!texture.options || !texture.options.hidden)) {
            oldTexture = mesh.uniforms.u_texSampler;
          }

          mesh.setTexture(newTexture, {
            rect: textureRect,
            repeat: textureRepeat,
            srcRect: sourceRect,
            rotated: textureImageRotated
          }); // delete uncached texture

          if (oldTexture && oldTexture.delete) {
            oldTexture.delete();
          }

          node[_textureContext] = renderer;
        }
      } else if (texture) {
        var _oldTexture = null;

        if (!renderer[_textureMap].has(texture.image) && (!texture.options || !texture.options.hidden)) {
          _oldTexture = mesh.uniforms.u_texSampler;
        }

        mesh.setTexture(null); // delete uncached texture

        if (_oldTexture && _oldTexture.delete) {
          _oldTexture.delete();
        }
      }
    }
    /**
      u3d-json compatible: https://www.codeandweb.com/texturepacker
      {
        frames: {
          key: {
            frame: {x, y, w, h},
            trimmed: ...,
            rotated: true|false,
            spriteSourceSize: {x, y, w, h},
            sourceSize: {w, h}
          }
        }
      }
      */


    function loadFrames(_x4, _x5) {
      return _loadFrames.apply(this, arguments);
    }

    function _loadFrames() {
      _loadFrames = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(src, frameData) {
        var response, texture, frames;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(typeof frameData === 'string')) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 3;
                return fetch(frameData, {
                  method: 'GET',
                  mode: 'cors',
                  cache: 'default'
                });

              case 3:
                response = _context2.sent;
                _context2.next = 6;
                return response.json();

              case 6:
                frameData = _context2.sent;

              case 7:
                _context2.next = 9;
                return loadTexture(src);

              case 9:
                texture = _context2.sent;
                frames = frameData.frames;
                Object.entries(frames).forEach(function (_ref) {
                  var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                      key = _ref2[0],
                      frame = _ref2[1];

                  var _frame$frame = frame.frame,
                      x = _frame$frame.x,
                      y = _frame$frame.y,
                      w = _frame$frame.w,
                      h = _frame$frame.h;
                  var sourceRect = [x, y, w, h];
                  var rotated = frame.rotated;

                  if (rotated) {
                    sourceRect = [sourceRect[0], sourceRect[1], sourceRect[3], sourceRect[2]];
                  }

                  loadedTextures[key] = {
                    image: texture,
                    sourceRect: sourceRect,
                    rotated: rotated
                  };
                });
                return _context2.abrupt("return", texture);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _loadFrames.apply(this, arguments);
    }
  });
  unwrapExports(texture);
  texture.loadTexture;
  texture.applyTexture;
  texture.createTexture;
  texture.deleteTexture;
  texture.drawTexture;
  texture.loadFrames;

  var cloud = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _node = interopRequireDefault(node);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _amount = Symbol('amount');

    var _meshCloud = Symbol('meshCloud');

    var Cloud = /*#__PURE__*/function (_Node) {
      (0, _inherits2.default)(Cloud, _Node);

      var _super = _createSuper(Cloud);

      function Cloud(node) {
        var _this;

        var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        (0, _classCallCheck2.default)(this, Cloud);
        _this = _super.call(this);
        _this.meshNode = node;
        node.connect((0, _assertThisInitialized2.default)(_this));
        _this[_amount] = amount;
        _this[_meshCloud] = null;
        return _this;
      }

      (0, _createClass2.default)(Cloud, [{
        key: "brightness",
        value: function brightness(idx, p) {
          if (this.meshCloud) {
            this.meshCloud.brightness(idx, p);
            this.forceUpdate();
          }
        }
      }, {
        key: "contrast",
        value: function contrast(idx, p) {
          if (this.meshCloud) {
            this.meshCloud.contrast(idx, p);
            this.forceUpdate();
          }
        }
      }, {
        key: "delete",
        value: function _delete(idx) {
          if (this.meshCloud) {
            this.meshCloud.delete(idx);
            this[_amount]--;
            this.forceUpdate();
          }
        }
        /* override */

      }, {
        key: "draw",
        value: function draw() {
          var _this2 = this;

          var meshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          (0, _get2.default)((0, _getPrototypeOf2.default)(Cloud.prototype), "draw", this).call(this, meshes);

          if (this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              var shaderAttrs = this.shaderAttrs;

              if (shaderAttrs) {
                Object.entries(shaderAttrs).forEach(function (_ref) {
                  var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                      key = _ref2[0],
                      setter = _ref2[1];

                  _this2.meshCloud.mesh.setAttribute(key, setter);
                });
              }

              var uniforms = this.uniforms;

              if (this.uniforms) {
                var _uniform = {};
                Object.entries(uniforms).forEach(function (_ref3) {
                  var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
                      key = _ref4[0],
                      value = _ref4[1];

                  if (typeof value === 'function') {
                    value = value(_this2, key);
                  }

                  _uniform[key] = value;
                });
                this.meshCloud.mesh.setUniforms(_uniform);
              }
            }

            if (this.meshNode.textureImage) {
              (0, texture.drawTexture)(this.meshNode, this.meshNode.mesh);
            }

            meshes.push(this.meshCloud);
          }

          return meshes;
        }
      }, {
        key: "getTransform",
        value: function getTransform(idx) {
          if (this.meshCloud) return this.meshCloud.getTransform(idx);
        }
      }, {
        key: "grayscale",
        value: function grayscale(idx, p) {
          if (this.meshCloud) {
            this.meshCloud.grayscale(idx, p);
            this.forceUpdate();
          }
        }
      }, {
        key: "hueRotate",
        value: function hueRotate(idx, deg) {
          if (this.meshCloud) {
            this.meshCloud.hueRotate(idx, deg);
            this.forceUpdate();
          }
        }
      }, {
        key: "invert",
        value: function invert(idx, p) {
          if (this.meshCloud) {
            this.meshCloud.invert(idx, p);
            this.forceUpdate();
          }
        }
        /* override */

      }, {
        key: "isPointCollision",
        value: function isPointCollision(x, y) {
          if (!this.meshCloud) return false;
          var pointerEvents = this.attributes.pointerEvents;
          if (pointerEvents === 'none') return false;
          if (pointerEvents !== 'all' && !this.isVisible) return false;
          var which = 'both';
          if (pointerEvents === 'visibleFill') which = 'fill';
          if (pointerEvents === 'visibleStroke') which = 'stroke';

          for (var i = 0; i < this[_amount]; i++) {
            if (!this.meshCloud.isPointCollision(i, [x, y], which)) return false;
          }

          return true;
        }
      }, {
        key: "setOpacity",
        value: function setOpacity(idx, p) {
          if (this.meshCloud) {
            this.meshCloud.opacity(idx, p);
            this.forceUpdate();
          }
        }
      }, {
        key: "rotate",
        value: function rotate(idx, ang) {
          var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
              _ref6 = (0, _slicedToArray2.default)(_ref5, 2),
              ox = _ref6[0],
              oy = _ref6[1];

          var rad = Math.PI * ang / 180;

          if (this.meshCloud) {
            var _this$meshNode$attrib = this.meshNode.attributes,
                x0 = _this$meshNode$attrib.x,
                y0 = _this$meshNode$attrib.y;
            this.meshCloud.rotate(idx, rad, [ox + x0, oy + y0]);
            this.forceUpdate();
          }
        }
      }, {
        key: "saturate",
        value: function saturate(idx, p) {
          if (this.meshCloud) {
            this.meshCloud.saturate(idx, p);
            this.forceUpdate();
          }
        }
      }, {
        key: "scale",
        value: function scale(idx, _ref7) {
          var _ref8 = (0, _slicedToArray2.default)(_ref7, 2),
              x = _ref8[0],
              _ref8$ = _ref8[1],
              y = _ref8$ === void 0 ? x : _ref8$;

          var _ref9 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
              _ref10 = (0, _slicedToArray2.default)(_ref9, 2),
              ox = _ref10[0],
              oy = _ref10[1];

          if (this.meshCloud) {
            var _this$meshNode$attrib2 = this.meshNode.attributes,
                x0 = _this$meshNode$attrib2.x,
                y0 = _this$meshNode$attrib2.y;
            var t = 1e-5;
            if (Math.abs(x) < t) x = 1 / x > 0 ? t : -t;
            if (Math.abs(y) < t) y = 1 / y > 0 ? t : -t;
            this.meshCloud.scale(idx, [x, y], [ox + x0, oy + y0]);
            this.forceUpdate();
          }
        }
      }, {
        key: "setColorTransform",
        value: function setColorTransform(idx, m) {
          if (this.meshCloud) {
            this.meshCloud.setColorTransform(idx, m);
            this.forceUpdate();
          }
        }
      }, {
        key: "setFillColor",
        value: function setFillColor(idx, color) {
          if (this.meshCloud) {
            if (Array.isArray(color)) {
              color = (0, _toConsumableArray2.default)(color);
              color[0] /= 255;
              color[1] /= 255;
              color[2] /= 255;
            }

            this.meshCloud.setFillColor(idx, color);
            this.forceUpdate();
          }
        }
      }, {
        key: "sepia",
        value: function sepia(idx, p) {
          if (this.meshCloud) {
            this.meshCloud.sepia(idx, p);
            this.forceUpdate();
          }
        }
        /* override */

      }, {
        key: "setResolution",
        value: function setResolution(_ref11) {
          var width = _ref11.width,
              height = _ref11.height;
          (0, _get2.default)((0, _getPrototypeOf2.default)(Cloud.prototype), "setResolution", this).call(this, {
            width: width,
            height: height
          });
          this.meshNode.setResolution({
            width: width,
            height: height
          });
        }
      }, {
        key: "setStrokeColor",
        value: function setStrokeColor(idx, color) {
          if (this.meshCloud) {
            if (Array.isArray(color)) {
              color = (0, _toConsumableArray2.default)(color);
              color[0] /= 255;
              color[1] /= 255;
              color[2] /= 255;
            }

            this.meshCloud.setStrokeColor(idx, color);
            this.forceUpdate();
          }
        }
      }, {
        key: "setTransform",
        value: function setTransform(idx, m) {
          if (this.meshCloud) {
            this.meshCloud.setTransform(idx, m);
            this.forceUpdate();
          }
        }
      }, {
        key: "skew",
        value: function skew(idx, _ref12) {
          var _ref13 = (0, _slicedToArray2.default)(_ref12, 2),
              x = _ref13[0],
              _ref13$ = _ref13[1],
              y = _ref13$ === void 0 ? x : _ref13$;

          var _ref14 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
              _ref15 = (0, _slicedToArray2.default)(_ref14, 2),
              ox = _ref15[0],
              oy = _ref15[1];

          if (this.meshCloud) {
            var _this$meshNode$attrib3 = this.meshNode.attributes,
                x0 = _this$meshNode$attrib3.x,
                y0 = _this$meshNode$attrib3.y;
            this.meshCloud.skew(idx, [x, y], [ox + x0, oy + y0]);
            this.forceUpdate();
          }
        }
      }, {
        key: "transform",
        value: function transform(idx, m) {
          if (this.meshCloud) {
            this.meshCloud.transform(idx, m);
            this.forceUpdate();
          }
        }
      }, {
        key: "transformColor",
        value: function transformColor(idx, m) {
          if (this.meshCloud) {
            this.meshCloud.transformColor(idx, m);
            this.forceUpdate();
          }
        }
      }, {
        key: "translate",
        value: function translate(idx, _ref16) {
          var _ref17 = (0, _slicedToArray2.default)(_ref16, 2),
              x = _ref17[0],
              y = _ref17[1];

          if (this.meshCloud) {
            this.meshCloud.translate(idx, [x, y]);
            this.forceUpdate();
          }
        }
      }, {
        key: "updateMesh",
        value: function updateMesh() {
          if (this[_meshCloud]) {
            this[_meshCloud].mesh = this.meshNode.mesh;
            this.forceUpdate();
          }
        }
      }, {
        key: "meshCloud",
        get: function get() {
          var meshNode = this.meshNode;
          var amount = this[_amount];

          if (!this[_meshCloud] && meshNode.mesh) {
            this[_meshCloud] = new mesh.MeshCloud(meshNode.mesh, amount); // const {bgcolor, fillColor} = meshNode.attributes;
            // for(let i = 0; i < this[_amount]; i++) {
            //   if(bgcolor) {
            //     this[_meshCloud].setFillColor(i, bgcolor);
            //   } else if(fillColor) {
            //     this[_meshCloud].setFillColor(i, fillColor);
            //   }
            // }
          } // if(this[_meshCloud] && meshNode.mesh !== this[_meshCloud].mesh) {
          //   this[_meshCloud].mesh = meshNode.mesh;
          // }


          return this[_meshCloud];
        }
        /* override */

      }, {
        key: "isVisible",
        get: function get() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
      }, {
        key: "amount",
        get: function get() {
          return this[_amount];
        },
        set: function set(value) {
          this[_amount] = value;
          if (this[_meshCloud]) this[_meshCloud].amount = value;
        }
      }]);
      return Cloud;
    }(_node.default);

    exports.default = Cloud;

    _document.default.registerNode(Cloud, 'cloud');
  });
  unwrapExports(cloud);

  var isNativeFunction = createCommonjsModule(function (module) {
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(isNativeFunction);

  var isNativeReflectConstruct = createCommonjsModule(function (module) {
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(isNativeReflectConstruct);

  var construct = createCommonjsModule(function (module) {
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        module.exports = _construct = Reflect.construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) setPrototypeOf(instance, Class.prototype);
          return instance;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }

      return _construct.apply(null, arguments);
    }

    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(construct);

  var wrapNativeSuper = createCommonjsModule(function (module) {
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return construct(Class, arguments, getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return setPrototypeOf(Wrapper, Class);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _wrapNativeSuper(Class);
    }

    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(wrapNativeSuper);

  var color = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isTransparent = isTransparent;
    exports.parseColor = parseColor;
    exports.setFillColor = setFillColor;
    exports.setStrokeColor = setStrokeColor;
    exports.Color = exports.Gradient = void 0;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _wrapNativeSuper2 = interopRequireDefault(wrapNativeSuper);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _colorRgba = interopRequireDefault(require$$8);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Gradient = /*#__PURE__*/function () {
      function Gradient(_ref) {
        var vector = _ref.vector,
            colors = _ref.colors;
        (0, _classCallCheck2.default)(this, Gradient);

        if (!Array.isArray(vector) || vector.length !== 4 && vector.length !== 6 && vector.length !== 3) {
          throw new TypeError('Invalid gradient');
        }

        this.vector = vector;
        this.colors = colors.map(function (_ref2) {
          var offset = _ref2.offset,
              color = _ref2.color;
          return {
            offset: offset,
            color: parseColor(color)
          };
        });
      }

      (0, _createClass2.default)(Gradient, [{
        key: "toString",
        value: function toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }]);
      return Gradient;
    }();

    exports.Gradient = Gradient;

    function isTransparent(color) {
      if (color instanceof Gradient) return false;
      if (color == null) return true;
      return (0, _colorRgba.default)(color)[3] === 0;
    }

    function parseColor(color) {
      // if(Array.isArray(color)) return color;
      if (color == null) return color;
      if (!color) color = 'transparent';
      if (color instanceof Gradient) return color;
      var ret = (0, _colorRgba.default)(color);
      if (!ret || !ret.length) throw new TypeError('Invalid color value.');
      return "rgba(".concat(ret.join(), ")");
    }

    function applyMeshGradient(mesh, type, color) {
      var vectorOffset = mesh.boundingBox[0];

      if (color.vector) {
        var vector = color.vector,
            colors = color.colors;

        if (vector.length === 4) {
          vector = [vector[0] + vectorOffset[0], vector[1] + vectorOffset[1], vector[2] + vectorOffset[0], vector[3] + vectorOffset[1]];
          mesh.setLinearGradient({
            vector: vector,
            colors: colors,
            type: type
          });
        } else if (vector.length === 3) {
          vector = [vector[0] + vectorOffset[0], vector[1] + vectorOffset[1], vector[2]];
          mesh.setCircularGradient({
            vector: vector,
            colors: colors,
            type: type
          });
        } else {
          vector = [vector[0] + vectorOffset[0], vector[1] + vectorOffset[1], vector[2], vector[3] + vectorOffset[0], vector[4] + vectorOffset[1], vector[5]];
          mesh.setRadialGradient({
            vector: vector,
            colors: colors,
            type: type
          });
        }
      } else if (mesh.gradient && mesh.gradient[type]) {
        delete mesh.gradient[type];
        delete mesh.uniforms.u_radialGradientVector;
      }
    }

    function setFillColor(mesh, _ref3) {
      var fillColor = _ref3.color,
          _ref3$rule = _ref3.rule,
          rule = _ref3$rule === void 0 ? 'nonzero' : _ref3$rule;
      applyMeshGradient(mesh, 'fill', fillColor);

      if (!fillColor.vector) {
        mesh.setFill({
          color: fillColor,
          rule: rule
        });
      }

      return mesh;
    }

    function setStrokeColor(mesh, _ref4) {
      var strokeColor = _ref4.color,
          lineWidth = _ref4.lineWidth,
          lineCap = _ref4.lineCap,
          lineJoin = _ref4.lineJoin,
          lineDash = _ref4.lineDash,
          lineDashOffset = _ref4.lineDashOffset,
          miterLimit = _ref4.miterLimit,
          roundSegments = _ref4.roundSegments;
      applyMeshGradient(mesh, 'stroke', strokeColor);

      if (strokeColor.vector) {
        strokeColor = [0, 0, 0, 1];
      }

      mesh.setStroke({
        color: strokeColor,
        thickness: lineWidth,
        cap: lineCap,
        join: lineJoin,
        miterLimit: miterLimit,
        lineDash: lineDash,
        lineDashOffset: lineDashOffset,
        roundSegments: roundSegments
      });
    }

    var Color = /*#__PURE__*/function (_Array) {
      (0, _inherits2.default)(Color, _Array);

      var _super = _createSuper(Color);

      function Color() {
        var _this;

        var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        (0, _classCallCheck2.default)(this, Color);

        if (Array.isArray(r)) {
          var _r = r;

          var _r2 = (0, _slicedToArray2.default)(_r, 4);

          r = _r2[0];
          g = _r2[1];
          b = _r2[2];
          a = _r2[3];
        }

        if (typeof r === 'string') {
          var _rgba = (0, _colorRgba.default)(r);

          var _rgba2 = (0, _slicedToArray2.default)(_rgba, 4);

          r = _rgba2[0];
          g = _rgba2[1];
          b = _rgba2[2];
          a = _rgba2[3];
          r /= 255;
          g /= 255;
          b /= 255;
        }

        _this = _super.call(this, r, g, b, a);
        return (0, _possibleConstructorReturn2.default)(_this, (0, _assertThisInitialized2.default)(_this));
      }

      (0, _createClass2.default)(Color, [{
        key: "fromColor",
        value: function fromColor(color) {
          if (typeof color === 'string') {
            color = (0, _colorRgba.default)(color);
            color[0] /= 255;
            color[1] /= 255;
            color[2] /= 255;
          }

          this[0] = color[0];
          this[1] = color[1];
          this[2] = color[2];
          this[3] = color[3];
          return this;
        }
      }, {
        key: "r",
        get: function get() {
          return Math.round(this[0] * 255);
        },
        set: function set(v) {
          this[0] = v / 255;
        }
      }, {
        key: "g",
        get: function get() {
          return Math.round(this[1] * 255);
        },
        set: function set(v) {
          this[1] = v / 255;
        }
      }, {
        key: "b",
        get: function get() {
          return Math.round(this[2] * 255);
        },
        set: function set(v) {
          this[2] = v / 255;
        }
      }, {
        key: "a",
        get: function get() {
          return this[3];
        },
        set: function set(v) {
          this[3] = v;
        }
      }, {
        key: "hex",
        get: function get() {
          var r = "0".concat(this.r.toString(16)).slice(-2);
          var g = "0".concat(this.g.toString(16)).slice(-2);
          var b = "0".concat(this.b.toString(16)).slice(-2);
          var a;

          if (this.a < 1) {
            a = Math.round(this[3] * 255);
            a = "0".concat(a.toString(16)).slice(-2);
          }

          return "#".concat(r).concat(g).concat(b).concat(a || '');
        }
      }, {
        key: "rgba",
        get: function get() {
          return "rgba(".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.a, ")");
        }
      }]);
      return Color;
    }( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Array));

    exports.Color = Color;
  });
  unwrapExports(color);
  color.isTransparent;
  color.parseColor;
  color.setFillColor;
  color.setStrokeColor;
  color.Color;
  color.Gradient;

  var block$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _node = interopRequireDefault(node$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');
    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var declareAlias = Symbol.for('spritejs_declareAlias');

    var Block = /*#__PURE__*/function (_Node) {
      (0, _inherits2.default)(Block, _Node);

      var _super = _createSuper(Block);

      function Block(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Block);
        _this = _super.call(this, subject);

        _this[setDefault]({
          anchorX: 0,
          anchorY: 0,

          /* anchor */
          width: undefined,
          height: undefined,

          /* size */
          borderWidth: 0,
          borderColor: 'rgba(0,0,0,1)',

          /* border */
          borderDash: undefined,
          borderDashOffset: 0,
          borderTopLeftRadius: [0, 0],
          borderTopRightRadius: [0, 0],
          borderBottomRightRadius: [0, 0],
          borderBottomLeftRadius: [0, 0],

          /* borderRadius */
          bgcolor: 'rgba(0,0,0,0)',
          paddingTop: 0,
          paddingRight: 0,
          paddingBottom: 0,
          paddingLeft: 0,

          /* padding */
          boxSizing: 'content-box',
          clipPath: undefined
        });

        _this[declareAlias]('anchor', 'size', 'border', 'borderRadius', 'padding');

        return _this;
      }

      (0, _createClass2.default)(Block, [{
        key: "anchorX",
        get: function get() {
          return this[getAttribute]('anchorX');
        },
        set: function set(value) {
          this[setAttribute]('anchorX', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "anchorY",
        get: function get() {
          return this[getAttribute]('anchorY');
        },
        set: function set(value) {
          this[setAttribute]('anchorY', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "anchor",
        get: function get() {
          return [this.anchorX, this.anchorY];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = [value, value];
          this.anchorX = value[0];
          this.anchorY = value[1];
        }
      }, {
        key: "width",
        get: function get() {
          return this[getAttribute]('width');
        },
        set: function set(value) {
          this[setAttribute]('width', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "height",
        get: function get() {
          return this[getAttribute]('height');
        },
        set: function set(value) {
          this[setAttribute]('height', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "size",
        get: function get() {
          return [this.width, this.height];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = [value, value];
          this.width = value[0];
          this.height = value[1];
        }
      }, {
        key: "borderWidth",
        get: function get() {
          return this[getAttribute]('borderWidth');
        },
        set: function set(value) {
          this[setAttribute]('borderWidth', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "borderColor",
        get: function get() {
          return this[getAttribute]('borderColor');
        },
        set: function set(value) {
          this[setAttribute]('borderColor', (0, color.parseColor)(value));
        }
      }, {
        key: "border",
        get: function get() {
          return [this.borderWidth, this.borderColor];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = [value];
          this.borderWidth = value[0];
          if (value[1] != null) this.borderColor = value[1];
        }
      }, {
        key: "borderDash",
        get: function get() {
          return this[getAttribute]('borderDash');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (value != null && !Array.isArray(value)) value = [value];
          this[setAttribute]('borderDash', value ? value.map(attribute_value.toNumber) : null);
        }
      }, {
        key: "borderDashOffset",
        get: function get() {
          return this[getAttribute]('borderDashOffset');
        },
        set: function set(value) {
          this[setAttribute]('borderDashOffset', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "borderTopLeftRadius",
        get: function get() {
          return this[getAttribute]('borderTopLeftRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (!Array.isArray(value)) value = [value, value];
          this[setAttribute]('borderTopLeftRadius', value.map(attribute_value.toNumber));
        }
      }, {
        key: "borderTopRightRadius",
        get: function get() {
          return this[getAttribute]('borderTopRightRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (!Array.isArray(value)) value = [value, value];
          this[setAttribute]('borderTopRightRadius', value.map(attribute_value.toNumber));
        }
      }, {
        key: "borderBottomRightRadius",
        get: function get() {
          return this[getAttribute]('borderBottomRightRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (!Array.isArray(value)) value = [value, value];
          this[setAttribute]('borderBottomRightRadius', value.map(attribute_value.toNumber));
        }
      }, {
        key: "borderBottomLeftRadius",
        get: function get() {
          return this[getAttribute]('borderBottomLeftRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (!Array.isArray(value)) value = [value, value];
          this[setAttribute]('borderBottomLeftRadius', value.map(attribute_value.toNumber));
        }
      }, {
        key: "borderRadius",
        get: function get() {
          return [].concat((0, _toConsumableArray2.default)(this.borderTopLeftRadius), (0, _toConsumableArray2.default)(this.borderTopRightRadius), (0, _toConsumableArray2.default)(this.borderBottomRightRadius), (0, _toConsumableArray2.default)(this.borderBottomLeftRadius));
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = Array(8).fill(value);else if (value.length === 2) value = [value[0], value[1], value[0], value[1], value[0], value[1], value[0], value[1]];else if (value.length === 4) value = [value[0], value[1], value[2], value[3], value[0], value[1], value[2], value[3]];else if (value.length === 6) value = [value[0], value[1], value[2], value[3], value[4], value[5], value[2], value[3]];else if (value.length !== 8) throw new TypeError('Invalid borderRadius value.');
          this.borderTopLeftRadius = [value[0], value[1]];
          this.borderTopRightRadius = [value[2], value[3]];
          this.borderBottomRightRadius = [value[4], value[5]];
          this.borderBottomLeftRadius = [value[6], value[7]];
        }
      }, {
        key: "bgcolor",
        get: function get() {
          return this[getAttribute]('bgcolor');
        },
        set: function set(value) {
          this[setAttribute]('bgcolor', (0, color.parseColor)(value));
        }
      }, {
        key: "paddingTop",
        get: function get() {
          return this[getAttribute]('paddingTop');
        },
        set: function set(value) {
          this[setAttribute]('paddingTop', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "paddingRight",
        get: function get() {
          return this[getAttribute]('paddingRight');
        },
        set: function set(value) {
          this[setAttribute]('paddingRight', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "paddingBottom",
        get: function get() {
          return this[getAttribute]('paddingBottom');
        },
        set: function set(value) {
          this[setAttribute]('paddingBottom', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "paddingLeft",
        get: function get() {
          return this[getAttribute]('paddingLeft');
        },
        set: function set(value) {
          this[setAttribute]('paddingLeft', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "padding",
        get: function get() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);

          if (!Array.isArray(value)) {
            value = [value, value, value, value];
          } else if (value.length === 2) {
            value = [value[0], value[1], value[0], value[1]];
          } else if (value.length === 3) {
            value = [value[0], value[1], value[2], value[1]];
          }

          this.paddingTop = value[0];
          this.paddingRight = value[1];
          this.paddingBottom = value[2];
          this.paddingLeft = value[3];
        }
      }, {
        key: "clipPath",
        get: function get() {
          return this[getAttribute]('clipPath');
        },
        set: function set(value) {
          this[setAttribute]('clipPath', value);
        }
      }, {
        key: "boxSizing",
        get: function get() {
          return this[getAttribute]('boxSizing');
        },
        set: function set(value) {
          if (value != null && value !== 'border-box' && value !== 'content-box') {
            throw new TypeError('Invalid boxSizing type.');
          }

          this[setAttribute]('boxSizing', value);
        }
      }]);
      return Block;
    }(_node.default);

    exports.default = Block;
  });
  unwrapExports(block$2);

  var border_radius = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createRadiusBox = createRadiusBox;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function createEllipseBorder(figure, x, y, w, h) {
      var pos = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'leftTop';
      var kappa = 0.5522848,
          ox = w / 2 * kappa,
          // control point offset horizontal
      oy = h / 2 * kappa,
          // control point offset vertical
      xe = x + w,
          // x-end
      ye = y + h,
          // y-end
      xm = x + w / 2,
          // x-middle
      ym = y + h / 2; // y-middle

      if (pos === 'leftTop') {
        figure.moveTo(x, ym);
        figure.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      } else if (pos === 'rightTop') {
        figure.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
      } else if (pos === 'rightBottom') {
        figure.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      } else if (pos === 'leftBottom') {
        figure.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
      }
    }

    function createRadiusBox(figure, _ref, radius) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 4),
          x = _ref2[0],
          y = _ref2[1],
          w = _ref2[2],
          h = _ref2[3];

      if (!radius || Array.isArray(radius) && radius.every(function (r) {
        return r === 0;
      })) {
        figure.beginPath();
        figure.rect(x, y, w, h);
      } else {
        if (typeof radius === 'number') radius = Array(8).fill(radius);

        var _radius$map = radius.map(function (r, i) {
          if (i % 2) return Math.min(r, h / 2);
          return Math.min(r, w / 2);
        }),
            _radius$map2 = (0, _slicedToArray2.default)(_radius$map, 8),
            tl0 = _radius$map2[0],
            tl1 = _radius$map2[1],
            tr0 = _radius$map2[2],
            tr1 = _radius$map2[3],
            br0 = _radius$map2[4],
            br1 = _radius$map2[5],
            bl0 = _radius$map2[6],
            bl1 = _radius$map2[7];

        figure.beginPath();
        figure.moveTo(x, y + tl1);
        createEllipseBorder(figure, x, y, tl0 * 2, tl1 * 2, 'leftTop');
        figure.lineTo(x + w - tr0, y);
        createEllipseBorder(figure, x + w - tr0 * 2, y, tr0 * 2, tr1 * 2, 'rightTop');
        figure.lineTo(x + w, y + h - br1);
        createEllipseBorder(figure, x + w - br0 * 2, y + h - br1 * 2, br0 * 2, br1 * 2, 'rightBottom');
        figure.lineTo(x + bl0, y + h);
        createEllipseBorder(figure, x, y + h - bl1 * 2, bl0 * 2, bl1 * 2, 'leftBottom');
        figure.closePath();
      }

      return figure;
    }
  });
  unwrapExports(border_radius);
  border_radius.createRadiusBox;

  var bounding_box = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _default(boundingBox, m) {
      if (!boundingBox) {
        return {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }

      var _boundingBox = (0, _slicedToArray2.default)(boundingBox, 2),
          _boundingBox$ = (0, _slicedToArray2.default)(_boundingBox[0], 2),
          x1 = _boundingBox$[0],
          y1 = _boundingBox$[1],
          _boundingBox$2 = (0, _slicedToArray2.default)(_boundingBox[1], 2),
          x2 = _boundingBox$2[0],
          y2 = _boundingBox$2[1];

      var x11 = x1 * m[0] + y1 * m[2] + m[4];
      var y11 = x1 * m[1] + y1 * m[3] + m[5];
      var x21 = x2 * m[0] + y1 * m[2] + m[4];
      var y21 = x2 * m[1] + y1 * m[3] + m[5];
      var x22 = x2 * m[0] + y2 * m[2] + m[4];
      var y22 = x2 * m[1] + y2 * m[3] + m[5];
      var x12 = x1 * m[0] + y2 * m[2] + m[4];
      var y12 = x1 * m[1] + y2 * m[3] + m[5];
      var left = Math.min(x11, x21, x22, x12);
      var top = Math.min(y11, y21, y22, y12);
      var right = Math.max(x11, x21, x22, x12);
      var bottom = Math.max(y11, y21, y22, y12);
      return {
        x: left,
        y: top,
        width: right - left,
        height: bottom - top,
        left: left,
        top: top,
        right: right,
        bottom: bottom
      };
    }
  });
  unwrapExports(bounding_box);

  var block$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _node = interopRequireDefault(node);

    var _block = interopRequireDefault(block$2);

    var _document = interopRequireDefault(document$1);

    var _bounding_box = interopRequireDefault(bounding_box);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _mesh = Symbol('mesh');

    var Block = /*#__PURE__*/function (_Node) {
      (0, _inherits2.default)(Block, _Node);

      var _super = _createSuper(Block);

      function Block() {
        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Block);
        return _super.call(this, attrs);
      }

      (0, _createClass2.default)(Block, [{
        key: "getBoundingClientRect",
        value: function getBoundingClientRect() {
          var m = this.renderMatrix;

          if (this.layer && this.layer.layerTransformInvert) {
            m = esm$1.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, m);
          }

          var boundingBox = null;

          if (this.mesh) {
            boundingBox = (0, _toConsumableArray2.default)(this.mesh.boundingBox);
            var borderWidth = this.attributes.borderWidth;

            if (borderWidth) {
              boundingBox[0] = [boundingBox[0][0] - borderWidth, boundingBox[0][1] - borderWidth];
              boundingBox[1] = [boundingBox[1][0] + borderWidth, boundingBox[1][1] + borderWidth];
            }
          }

          return (0, _bounding_box.default)(boundingBox, m);
        } // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }

        /* override */

      }, {
        key: "onPropertyChange",
        value: function onPropertyChange(key, newValue, oldValue) {
          // eslint-disable-line complexity
          (0, _get2.default)((0, _getPrototypeOf2.default)(Block.prototype), "onPropertyChange", this).call(this, key, newValue, oldValue);

          if (key === 'anchorX' || key === 'anchorY' || key === 'boxSizing' || key === 'width' || key === 'height' || key === 'borderWidth' || key === 'paddingLeft' || key === 'paddingRight' || key === 'paddingTop' || key === 'paddingBottom' || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(key)) {
            this.updateContours();
          } // if(key === 'opacity') {
          //   if(this[_mesh]) this[_mesh].setOpacity(this.opacity);
          // }
          // if(key === 'anchorX' || key === 'anchorY' || key === 'boxSizing') {
          //   if(this[_mesh]) {
          //     const bgcolor = this.attributes.bgcolor;
          //     if(bgcolor && bgcolor.vector) {
          //       setFillColor(this[_mesh], {color: bgcolor});
          //     }
          //     const borderColor = this.attributes.borderColor;
          //     if(borderColor && borderColor.vector) {
          //       const {borderWidth, borderDash, borderDashOffset} = this.attributes;
          //       setStrokeColor(this[_mesh],
          //         {color: borderColor, lineWidth: borderWidth, lineDash: borderDash, lineDashOffset: borderDashOffset});
          //     }
          //   }
          // }


          if (this[_mesh] && key === 'clipPath') {
            this[_mesh].setClipPath(newValue);
          }

          if (this[_mesh] && key === 'bgcolor') {
            (0, color.setFillColor)(this[_mesh], {
              color: newValue
            });
          }

          if (this[_mesh] && (key === 'borderColor' || key === 'borderWidth' || key === 'borderDash' || key === 'borderDashOffset')) {
            var _this$attributes = this.attributes,
                borderColor = _this$attributes.borderColor,
                borderWidth = _this$attributes.borderWidth,
                borderDash = _this$attributes.borderDash,
                borderDashOffset = _this$attributes.borderDashOffset;
            (0, color.setStrokeColor)(this[_mesh], {
              color: borderColor,
              lineWidth: borderWidth,
              lineDash: borderWidth ? borderDash : 0,
              lineDashOffset: borderDashOffset
            });
          }
        }
        /* override */

      }, {
        key: "updateContours",
        value: function updateContours() {
          var _this$attributes2 = this.attributes,
              anchorX = _this$attributes2.anchorX,
              anchorY = _this$attributes2.anchorY,
              borderWidth = _this$attributes2.borderWidth,
              borderRadius = _this$attributes2.borderRadius;

          var _this$borderSize = (0, _slicedToArray2.default)(this.borderSize, 2),
              width = _this$borderSize[0],
              height = _this$borderSize[1];

          var offsetSize = this.offsetSize;
          var bw = 0.5 * borderWidth;
          var left = -anchorX * offsetSize[0] + bw;
          var top = -anchorY * offsetSize[1] + bw;
          this.clientBox = new mesh.Figure2D();
          (0, border_radius.createRadiusBox)(this.clientBox, [left, top, width, height], borderRadius);
        }
      }, {
        key: "borderSize",
        get: function get() {
          var _this$attributes3 = this.attributes,
              paddingTop = _this$attributes3.paddingTop,
              paddingRight = _this$attributes3.paddingRight,
              paddingBottom = _this$attributes3.paddingBottom,
              paddingLeft = _this$attributes3.paddingLeft,
              borderWidth = _this$attributes3.borderWidth;

          var _this$contentSize = (0, _slicedToArray2.default)(this.contentSize, 2),
              width = _this$contentSize[0],
              height = _this$contentSize[1];

          return [paddingLeft + width + paddingRight + borderWidth, paddingTop + height + paddingBottom + borderWidth];
        } // content + padding

      }, {
        key: "clientSize",
        get: function get() {
          var _this$attributes4 = this.attributes,
              paddingTop = _this$attributes4.paddingTop,
              paddingRight = _this$attributes4.paddingRight,
              paddingBottom = _this$attributes4.paddingBottom,
              paddingLeft = _this$attributes4.paddingLeft;

          var _this$contentSize2 = (0, _slicedToArray2.default)(this.contentSize, 2),
              width = _this$contentSize2[0],
              height = _this$contentSize2[1];

          return [paddingLeft + width + paddingRight, paddingTop + height + paddingBottom];
        }
      }, {
        key: "contentSize",
        get: function get() {
          var _this$attributes5 = this.attributes,
              width = _this$attributes5.width,
              height = _this$attributes5.height,
              boxSizing = _this$attributes5.boxSizing,
              paddingTop = _this$attributes5.paddingTop,
              paddingRight = _this$attributes5.paddingRight,
              paddingBottom = _this$attributes5.paddingBottom,
              paddingLeft = _this$attributes5.paddingLeft;
          width = width || 0;
          height = height || 0;

          if (boxSizing === 'border-box') {
            var bw = 2 * this.attributes.borderWidth;
            width -= bw + paddingRight + paddingLeft;
            height -= bw + paddingTop + paddingBottom;
            width = Math.max(0, width);
            height = Math.max(0, height);
          }

          return [width, height];
        }
      }, {
        key: "hasBorder",
        get: function get() {
          var borderWidth = this.attributes.borderWidth;
          return borderWidth > 0;
        }
        /* override */

      }, {
        key: "isVisible",
        get: function get() {
          var _this$borderSize2 = (0, _slicedToArray2.default)(this.borderSize, 2),
              width = _this$borderSize2[0],
              height = _this$borderSize2[1];

          return width > 0 && height > 0;
        }
      }, {
        key: "mesh",
        get: function get() {
          if (this.attributes.display === 'none') return null;
          var box = this.clientBox;

          if (box) {
            var _mesh2;

            var mesh$1 = this[_mesh];

            if (!mesh$1) {
              mesh$1 = new mesh.Mesh2D(box);
              mesh$1.box = box;
              var fillColor = this.attributes.bgcolor;
              (0, color.setFillColor)(mesh$1, {
                color: fillColor
              });

              if (this.hasBorder) {
                var _this$attributes6 = this.attributes,
                    borderColor = _this$attributes6.borderColor,
                    borderWidth = _this$attributes6.borderWidth,
                    borderDash = _this$attributes6.borderDash,
                    borderDashOffset = _this$attributes6.borderDashOffset;
                (0, color.setStrokeColor)(mesh$1, {
                  color: borderColor,
                  lineWidth: borderWidth,
                  lineDash: borderDash,
                  lineDashOffset: borderDashOffset
                });
              } // mesh.setOpacity(this.attributes.opacity);


              this[_mesh] = mesh$1;
              var clipPath = this.attributes.clipPath;

              if (clipPath) {
                this[_mesh].setClipPath(clipPath);
              }
            } else if (mesh$1.box !== box) {
              mesh$1.contours = box.contours;
              mesh$1.box = box;
            }

            var opacity = this.opacity;

            if (mesh$1.getOpacity() !== opacity) {
              mesh$1.setOpacity(opacity);
            }

            (_mesh2 = mesh$1).setTransform.apply(_mesh2, (0, _toConsumableArray2.default)(this.renderMatrix));

            return mesh$1;
          }

          return null;
        } // content + padding + border

      }, {
        key: "offsetSize",
        get: function get() {
          var _this$attributes7 = this.attributes,
              paddingTop = _this$attributes7.paddingTop,
              paddingRight = _this$attributes7.paddingRight,
              paddingBottom = _this$attributes7.paddingBottom,
              paddingLeft = _this$attributes7.paddingLeft,
              borderWidth = _this$attributes7.borderWidth;

          var _this$contentSize3 = (0, _slicedToArray2.default)(this.contentSize, 2),
              width = _this$contentSize3[0],
              height = _this$contentSize3[1];

          var bw2 = 2 * borderWidth;
          return [paddingLeft + width + paddingRight + bw2, paddingTop + height + paddingBottom + bw2];
        }
      }, {
        key: "originalClientRect",
        get: function get() {
          if (this.mesh) {
            var boundingBox = this.mesh.boundingBox;
            return [boundingBox[0][0], boundingBox[0][1], boundingBox[1][0] - boundingBox[0][0], boundingBox[1][1] - boundingBox[0][1]];
          }

          return [0, 0, 0, 0];
        }
      }, {
        key: "originalContentRect",
        get: function get() {
          var _this$originalClientR = (0, _slicedToArray2.default)(this.originalClientRect, 4),
              left = _this$originalClientR[0],
              top = _this$originalClientR[1],
              width = _this$originalClientR[2],
              height = _this$originalClientR[3];

          var padding = this.attributes.padding;
          return [left + padding[0], top + padding[1], width - padding[0] - padding[2], height - padding[1] - padding[3]];
        }
      }]);
      return Block;
    }(_node.default);

    exports.default = Block;
    (0, _defineProperty2.default)(Block, "Attr", _block.default);

    _document.default.registerNode(Block, 'block');
  });
  unwrapExports(block$1);

  var sprite$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _block = interopRequireDefault(block$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');

    var Sprite = /*#__PURE__*/function (_Block) {
      (0, _inherits2.default)(Sprite, _Block);

      var _super = _createSuper(Sprite);

      function Sprite(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Sprite);
        _this = _super.call(this, subject);

        _this[setDefault]({
          texture: undefined,
          textureRect: undefined,
          textureRepeat: false,
          sourceRect: undefined
        });

        return _this;
      }

      (0, _createClass2.default)(Sprite, [{
        key: "texture",
        get: function get() {
          return this[getAttribute]('texture');
        },
        set: function set(value) {
          this[setAttribute]('texture', value);
        }
      }, {
        key: "textureRect",
        get: function get() {
          return this[getAttribute]('textureRect');
        },
        set: function set(value) {
          this[setAttribute]('textureRect', value);
        }
      }, {
        key: "sourceRect",
        get: function get() {
          return this[getAttribute]('sourceRect');
        },
        set: function set(value) {
          this[setAttribute]('sourceRect', value);
        }
      }, {
        key: "textureRepeat",
        get: function get() {
          return this[getAttribute]('textureRepeat');
        },
        set: function set(value) {
          this[setAttribute]('textureRepeat', !!value);
        }
      }]);
      return Sprite;
    }(_block.default);

    exports.default = Sprite;
  });
  unwrapExports(sprite$1);

  var sprite = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get4 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _block = interopRequireDefault(block$1);

    var _sprite = interopRequireDefault(sprite$1);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _textureTask = Symbol('textureTask');

    var Sprite = /*#__PURE__*/function (_Block) {
      (0, _inherits2.default)(Sprite, _Block);

      var _super = _createSuper(Sprite);

      function Sprite() {
        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Sprite);
        if (typeof attrs === 'string') attrs = {
          texture: attrs
        };
        return _super.call(this, attrs);
      }
      /* override */


      (0, _createClass2.default)(Sprite, [{
        key: "draw",

        /* override */
        value: function draw() {
          var meshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          (0, _get4.default)((0, _getPrototypeOf2.default)(Sprite.prototype), "draw", this).call(this, meshes);
          var mesh = this.mesh;

          if (mesh) {
            (0, texture.drawTexture)(this, mesh);
          }

          return meshes;
        }
        /* override */

      }, {
        key: "onPropertyChange",
        value: function onPropertyChange(key, newValue, oldValue) {
          (0, _get4.default)((0, _getPrototypeOf2.default)(Sprite.prototype), "onPropertyChange", this).call(this, key, newValue, oldValue);

          if (key === 'texture') {
            this[_textureTask] = (0, texture.applyTexture)(this, newValue, true); // this.setTexture(newValue);
          }

          if (key === 'textureRect') {
            var _this$attributes = this.attributes,
                width = _this$attributes.width,
                height = _this$attributes.height;

            if (width == null || height == null) {
              this.updateContours();
            }
          }
        }
      }, {
        key: "contentSize",
        get: function get() {
          var _get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(Sprite.prototype), "contentSize", this),
              _get3 = (0, _slicedToArray2.default)(_get2, 2),
              w = _get3[0],
              h = _get3[1];

          var _this$attributes2 = this.attributes,
              width = _this$attributes2.width,
              height = _this$attributes2.height;

          if (width == null || height == null) {
            var img = this.textureImage;
            var textureRect = this.attributes.textureRect;
            var sourceRect = this.attributes.sourceRect;

            if (textureRect) {
              if (width == null) w = textureRect[0] + textureRect[2];
              if (height == null) h = textureRect[1] + textureRect[3];
            } else if (sourceRect) {
              var ratio = this.layer ? this.layer.displayRatio : 1;
              if (width == null) w = sourceRect[2] / ratio;
              if (height == null) h = sourceRect[3] / ratio;
            } else if (img) {
              var _ratio = this.layer ? this.layer.displayRatio : 1;

              if (width == null) w = img.width / _ratio;
              if (height == null) h = img.height / _ratio;
            }
          }

          return [w, h];
        }
      }, {
        key: "textureImageReady",
        get: function get() {
          return this[_textureTask] || Promise.resolve();
        }
      }]);
      return Sprite;
    }(_block.default);

    exports.default = Sprite;
    (0, _defineProperty2.default)(Sprite, "Attr", _sprite.default);

    _document.default.registerNode(Sprite, 'sprite');
  });
  unwrapExports(sprite);

  var pasition = createCommonjsModule(function (module, exports) {
    /**
     * pasition v1.0.2 By dntzhang
     * Github: https://github.com/AlloyTeam/pasition
     * MIT Licensed.
     */
    (function (global, factory) {
      module.exports = factory() ;
    })(commonjsGlobal, function () {

      var slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }(); //https://github.com/colinmeinke/svg-arc-to-cubic-bezier


      var TAU = Math.PI * 2;

      var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
        var x = _ref.x,
            y = _ref.y;
        x *= rx;
        y *= ry;
        var xp = cosphi * x - sinphi * y;
        var yp = sinphi * x + cosphi * y;
        return {
          x: xp + centerx,
          y: yp + centery
        };
      };

      var approxUnitArc = function approxUnitArc(ang1, ang2) {
        var a = 4 / 3 * Math.tan(ang2 / 4);
        var x1 = Math.cos(ang1);
        var y1 = Math.sin(ang1);
        var x2 = Math.cos(ang1 + ang2);
        var y2 = Math.sin(ang1 + ang2);
        return [{
          x: x1 - y1 * a,
          y: y1 + x1 * a
        }, {
          x: x2 + y2 * a,
          y: y2 - x2 * a
        }, {
          x: x2,
          y: y2
        }];
      };

      var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
        var sign = ux * vy - uy * vx < 0 ? -1 : 1;
        var umag = Math.sqrt(ux * ux + uy * uy);
        var vmag = Math.sqrt(ux * ux + uy * uy);
        var dot = ux * vx + uy * vy;
        var div = dot / (umag * vmag);

        if (div > 1) {
          div = 1;
        }

        if (div < -1) {
          div = -1;
        }

        return sign * Math.acos(div);
      };

      var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
        var rxsq = Math.pow(rx, 2);
        var rysq = Math.pow(ry, 2);
        var pxpsq = Math.pow(pxp, 2);
        var pypsq = Math.pow(pyp, 2);
        var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

        if (radicant < 0) {
          radicant = 0;
        }

        radicant /= rxsq * pypsq + rysq * pxpsq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        var centerxp = radicant * rx / ry * pyp;
        var centeryp = radicant * -ry / rx * pxp;
        var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
        var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
        var vx1 = (pxp - centerxp) / rx;
        var vy1 = (pyp - centeryp) / ry;
        var vx2 = (-pxp - centerxp) / rx;
        var vy2 = (-pyp - centeryp) / ry;
        var ang1 = vectorAngle(1, 0, vx1, vy1);
        var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }

        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }

        return [centerx, centery, ang1, ang2];
      };

      var arcToBezier = function arcToBezier(_ref2) {
        var px = _ref2.px,
            py = _ref2.py,
            cx = _ref2.cx,
            cy = _ref2.cy,
            rx = _ref2.rx,
            ry = _ref2.ry,
            _ref2$xAxisRotation = _ref2.xAxisRotation,
            xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
            _ref2$largeArcFlag = _ref2.largeArcFlag,
            largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
            _ref2$sweepFlag = _ref2.sweepFlag,
            sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;
        var curves = [];

        if (rx === 0 || ry === 0) {
          return [];
        }

        var sinphi = Math.sin(xAxisRotation * TAU / 360);
        var cosphi = Math.cos(xAxisRotation * TAU / 360);
        var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
        var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

        if (pxp === 0 && pyp === 0) {
          return [];
        }

        rx = Math.abs(rx);
        ry = Math.abs(ry);
        var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

        if (lambda > 1) {
          rx *= Math.sqrt(lambda);
          ry *= Math.sqrt(lambda);
        }

        var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
            _getArcCenter2 = slicedToArray(_getArcCenter, 4),
            centerx = _getArcCenter2[0],
            centery = _getArcCenter2[1],
            ang1 = _getArcCenter2[2],
            ang2 = _getArcCenter2[3];

        var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);
        ang2 /= segments;

        for (var i = 0; i < segments; i++) {
          curves.push(approxUnitArc(ang1, ang2));
          ang1 += ang2;
        }

        return curves.map(function (curve) {
          var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
              x1 = _mapToEllipse.x,
              y1 = _mapToEllipse.y;

          var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
              x2 = _mapToEllipse2.x,
              y2 = _mapToEllipse2.y;

          var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
              x = _mapToEllipse3.x,
              y = _mapToEllipse3.y;

          return {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            x: x,
            y: y
          };
        });
      }; //https://github.com/jkroso/parse-svg-path/blob/master/index.js

      /**
       * expected argument lengths
       * @type {Object}
       */


      var length = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
        /**
         * segment pattern
         * @type {RegExp}
         */

      };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      /**
       * parse an svg path data string. Generates an Array
       * of commands where each command is an Array of the
       * form `[command, arg1, arg2, ...]`
       *
       * @param {String} path
       * @return {Array}
       */

      function parse(path) {
        var data = [];
        path.replace(segment, function (_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args); // overloaded moveTo

          if (type == 'm' && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = 'l';
            command = command == 'm' ? 'l' : 'L';
          }

          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }

            if (args.length < length[type]) throw new Error('malformed path data');
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }

      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }

      function shapeBox(shape) {
        var minX = shape[0][0],
            minY = shape[0][1],
            maxX = minX,
            maxY = minY;
        shape.forEach(function (curve) {
          var x1 = curve[0],
              x2 = curve[2],
              x3 = curve[4],
              x4 = curve[6],
              y1 = curve[1],
              y2 = curve[3],
              y3 = curve[5],
              y4 = curve[7];
          minX = Math.min(minX, x1, x2, x3, x4);
          minY = Math.min(minY, y1, y2, y3, y4);
          maxX = Math.max(maxX, x1, x2, x3, x4);
          maxY = Math.max(maxY, y1, y2, y3, y4);
        });
        return [minX, minY, maxX, maxY];
      }

      function boxDistance(boxA, boxB) {
        return Math.sqrt(Math.pow(boxA[0] - boxB[0], 2) + Math.pow(boxA[1] - boxB[1], 2)) + Math.sqrt(Math.pow(boxA[2] - boxB[2], 2) + Math.pow(boxA[3] - boxB[3], 2));
      }

      function curveDistance(curveA, curveB) {
        var x1 = curveA[0],
            x2 = curveA[2],
            x3 = curveA[4],
            x4 = curveA[6],
            y1 = curveA[1],
            y2 = curveA[3],
            y3 = curveA[5],
            y4 = curveA[7],
            xb1 = curveB[0],
            xb2 = curveB[2],
            xb3 = curveB[4],
            xb4 = curveB[6],
            yb1 = curveB[1],
            yb2 = curveB[3],
            yb3 = curveB[5],
            yb4 = curveB[7];
        return Math.sqrt(Math.pow(xb1 - x1, 2) + Math.pow(yb1 - y1, 2)) + Math.sqrt(Math.pow(xb2 - x2, 2) + Math.pow(yb2 - y2, 2)) + Math.sqrt(Math.pow(xb3 - x3, 2) + Math.pow(yb3 - y3, 2)) + Math.sqrt(Math.pow(xb4 - x4, 2) + Math.pow(yb4 - y4, 2));
      }

      function sortCurves(curvesA, curvesB) {
        var arrList = permuteCurveNum(curvesA.length);
        var list = [];
        arrList.forEach(function (arr) {
          var distance = 0;
          var i = 0;
          arr.forEach(function (index) {
            distance += curveDistance(curvesA[index], curvesB[i++]);
          });
          list.push({
            index: arr,
            distance: distance
          });
        });
        list.sort(function (a, b) {
          return a.distance - b.distance;
        });
        var result = [];
        list[0].index.forEach(function (index) {
          result.push(curvesA[index]);
        });
        return result;
      }

      function sort(pathA, pathB) {
        var arrList = permuteNum(pathA.length);
        var list = [];
        arrList.forEach(function (arr) {
          var distance = 0;
          arr.forEach(function (index) {
            distance += boxDistance(shapeBox(pathA[index]), shapeBox(pathB[index]));
          });
          list.push({
            index: arr,
            distance: distance
          });
        });
        list.sort(function (a, b) {
          return a.distance - b.distance;
        });
        var result = [];
        list[0].index.forEach(function (index) {
          result.push(pathA[index]);
        });
        return result;
      }

      function permuteCurveNum(num) {
        var arr = [];

        for (var i = 0; i < num; i++) {
          var indexArr = [];

          for (var j = 0; j < num; j++) {
            var index = j + i;
            if (index > num - 1) index -= num;
            indexArr[index] = j;
          }

          arr.push(indexArr);
        }

        return arr;
      }

      function permuteNum(num) {
        var arr = [];

        for (var i = 0; i < num; i++) {
          arr.push(i);
        }

        return permute(arr);
      }

      function permute(input) {
        var permArr = [],
            usedChars = [];

        function main(input) {
          var i, ch;

          for (i = 0; i < input.length; i++) {
            ch = input.splice(i, 1)[0];
            usedChars.push(ch);

            if (input.length == 0) {
              permArr.push(usedChars.slice());
            }

            main(input);
            input.splice(i, 0, ch);
            usedChars.pop();
          }

          return permArr;
        }

        return main(input);
      }

      var pasition = {};
      pasition.parser = parse;

      pasition.lerpCurve = function (pathA, pathB, t) {
        return pasition.lerpPoints(pathA[0], pathA[1], pathB[0], pathB[1], t).concat(pasition.lerpPoints(pathA[2], pathA[3], pathB[2], pathB[3], t)).concat(pasition.lerpPoints(pathA[4], pathA[5], pathB[4], pathB[5], t)).concat(pasition.lerpPoints(pathA[6], pathA[7], pathB[6], pathB[7], t));
      };

      pasition.lerpPoints = function (x1, y1, x2, y2, t) {
        return [x1 + (x2 - x1) * t, y1 + (y2 - y1) * t];
      };

      pasition.q2b = function (x1, y1, x2, y2, x3, y3) {
        return [x1, y1, (x1 + 2 * x2) / 3, (y1 + 2 * y2) / 3, (x3 + 2 * x2) / 3, (y3 + 2 * y2) / 3, x3, y3];
      };

      pasition.path2shapes = function (path) {
        //https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths
        //M = moveto
        //L = lineto
        //H = horizontal lineto
        //V = vertical lineto
        //C = curveto
        //S = smooth curveto
        //Q = quadratic Belzier curve
        //T = smooth quadratic Belzier curveto
        //A = elliptical Arc
        //Z = closepath
        //以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位(从上一个点开始)。
        var cmds = pasition.parser(path),
            preX = 0,
            preY = 0,
            j = 0,
            len = cmds.length,
            shapes = [],
            current = null,
            closeX = void 0,
            closeY = void 0,
            preCX = void 0,
            preCY = void 0,
            sLen = void 0,
            curves = void 0,
            lastCurve = void 0;

        for (; j < len; j++) {
          var item = cmds[j];
          var action = item[0];
          var preItem = cmds[j - 1];

          switch (action) {
            case 'm':
              sLen = shapes.length;
              shapes[sLen] = [];
              current = shapes[sLen];
              preX = preX + item[1];
              preY = preY + item[2];
              break;

            case 'M':
              sLen = shapes.length;
              shapes[sLen] = [];
              current = shapes[sLen];
              preX = item[1];
              preY = item[2];
              break;

            case 'l':
              current.push([preX, preY, preX, preY, preX, preY, preX + item[1], preY + item[2]]);
              preX += item[1];
              preY += item[2];
              break;

            case 'L':
              current.push([preX, preY, item[1], item[2], item[1], item[2], item[1], item[2]]);
              preX = item[1];
              preY = item[2];
              break;

            case 'h':
              current.push([preX, preY, preX, preY, preX, preY, preX + item[1], preY]);
              preX += item[1];
              break;

            case 'H':
              current.push([preX, preY, item[1], preY, item[1], preY, item[1], preY]);
              preX = item[1];
              break;

            case 'v':
              current.push([preX, preY, preX, preY, preX, preY, preX, preY + item[1]]);
              preY += item[1];
              break;

            case 'V':
              current.push([preX, preY, preX, item[1], preX, item[1], preX, item[1]]);
              preY = item[1];
              break;

            case 'C':
              current.push([preX, preY, item[1], item[2], item[3], item[4], item[5], item[6]]);
              preX = item[5];
              preY = item[6];
              break;

            case 'S':
              if (preItem[0] === 'C' || preItem[0] === 'c') {
                current.push([preX, preY, preX + preItem[5] - preItem[3], preY + preItem[6] - preItem[4], item[1], item[2], item[3], item[4]]);
              } else if (preItem[0] === 'S' || preItem[0] === 's') {
                current.push([preX, preY, preX + preItem[3] - preItem[1], preY + preItem[4] - preItem[2], item[1], item[2], item[3], item[4]]);
              }

              preX = item[3];
              preY = item[4];
              break;

            case 'c':
              current.push([preX, preY, preX + item[1], preY + item[2], preX + item[3], preY + item[4], preX + item[5], preY + item[6]]);
              preX = preX + item[5];
              preY = preY + item[6];
              break;

            case 's':
              if (preItem[0] === 'C' || preItem[0] === 'c') {
                current.push([preX, preY, preX + preItem[5] - preItem[3], preY + preItem[6] - preItem[4], preX + item[1], preY + item[2], preX + item[3], preY + item[4]]);
              } else if (preItem[0] === 'S' || preItem[0] === 's') {
                current.push([preX, preY, preX + preItem[3] - preItem[1], preY + preItem[4] - preItem[2], preX + item[1], preY + item[2], preX + item[3], preY + item[4]]);
              }

              preX = preX + item[3];
              preY = preY + item[4];
              break;

            case 'a':
              curves = arcToBezier({
                rx: item[1],
                ry: item[2],
                px: preX,
                py: preY,
                xAxisRotation: item[3],
                largeArcFlag: item[4],
                sweepFlag: item[5],
                cx: preX + item[6],
                cy: preY + item[7]
              });
              lastCurve = curves[curves.length - 1];
              curves.forEach(function (curve, index) {
                if (index === 0) {
                  current.push([preX, preY, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                } else {
                  current.push([curves[index - 1].x, curves[index - 1].y, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                }
              });
              preX = lastCurve.x;
              preY = lastCurve.y;
              break;

            case 'A':
              curves = arcToBezier({
                rx: item[1],
                ry: item[2],
                px: preX,
                py: preY,
                xAxisRotation: item[3],
                largeArcFlag: item[4],
                sweepFlag: item[5],
                cx: item[6],
                cy: item[7]
              });
              lastCurve = curves[curves.length - 1];
              curves.forEach(function (curve, index) {
                if (index === 0) {
                  current.push([preX, preY, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                } else {
                  current.push([curves[index - 1].x, curves[index - 1].y, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                }
              });
              preX = lastCurve.x;
              preY = lastCurve.y;
              break;

            case 'Q':
              current.push(pasition.q2b(preX, preY, item[1], item[2], item[3], item[4]));
              preX = item[3];
              preY = item[4];
              break;

            case 'q':
              current.push(pasition.q2b(preX, preY, preX + item[1], preY + item[2], item[3] + preX, item[4] + preY));
              preX += item[3];
              preY += item[4];
              break;

            case 'T':
              if (preItem[0] === 'Q' || preItem[0] === 'q') {
                preCX = preX + preItem[3] - preItem[1];
                preCY = preY + preItem[4] - preItem[2];
                current.push(pasition.q2b(preX, preY, preCX, preCY, item[1], item[2]));
              } else if (preItem[0] === 'T' || preItem[0] === 't') {
                current.push(pasition.q2b(preX, preY, preX + preX - preCX, preY + preY - preCY, item[1], item[2]));
                preCX = preX + preX - preCX;
                preCY = preY + preY - preCY;
              }

              preX = item[1];
              preY = item[2];
              break;

            case 't':
              if (preItem[0] === 'Q' || preItem[0] === 'q') {
                preCX = preX + preItem[3] - preItem[1];
                preCY = preY + preItem[4] - preItem[2];
                current.push(pasition.q2b(preX, preY, preCX, preCY, preX + item[1], preY + item[2]));
              } else if (preItem[0] === 'T' || preItem[0] === 't') {
                current.push(pasition.q2b(preX, preY, preX + preX - preCX, preY + preY - preCY, preX + item[1], preY + item[2]));
                preCX = preX + preX - preCX;
                preCY = preY + preY - preCY;
              }

              preX += item[1];
              preY += item[2];
              break;

            case 'Z':
              closeX = current[0][0];
              closeY = current[0][1];
              current.push([preX, preY, closeX, closeY, closeX, closeY, closeX, closeY]);
              break;

            case 'z':
              closeX = current[0][0];
              closeY = current[0][1];
              current.push([preX, preY, closeX, closeY, closeX, closeY, closeX, closeY]);
              break;
          }
        }

        return shapes;
      };

      pasition._upCurves = function (curves, count) {
        var i = 0,
            index = 0,
            len = curves.length;

        for (; i < count; i++) {
          curves.push(curves[index].slice(0));
          index++;

          if (index > len - 1) {
            index -= len;
          }
        }
      };

      function split(x1, y1, x2, y2, x3, y3, x4, y4, t) {
        return {
          left: _split(x1, y1, x2, y2, x3, y3, x4, y4, t),
          right: _split(x4, y4, x3, y3, x2, y2, x1, y1, 1 - t, true)
        };
      }

      function _split(x1, y1, x2, y2, x3, y3, x4, y4, t, reverse) {
        var x12 = (x2 - x1) * t + x1;
        var y12 = (y2 - y1) * t + y1;
        var x23 = (x3 - x2) * t + x2;
        var y23 = (y3 - y2) * t + y2;
        var x34 = (x4 - x3) * t + x3;
        var y34 = (y4 - y3) * t + y3;
        var x123 = (x23 - x12) * t + x12;
        var y123 = (y23 - y12) * t + y12;
        var x234 = (x34 - x23) * t + x23;
        var y234 = (y34 - y23) * t + y23;
        var x1234 = (x234 - x123) * t + x123;
        var y1234 = (y234 - y123) * t + y123;

        if (reverse) {
          return [x1234, y1234, x123, y123, x12, y12, x1, y1];
        }

        return [x1, y1, x12, y12, x123, y123, x1234, y1234];
      }

      pasition._splitCurves = function (curves, count) {
        var i = 0,
            index = 0;

        for (; i < count; i++) {
          var curve = curves[index];
          var cs = split(curve[0], curve[1], curve[2], curve[3], curve[4], curve[5], curve[6], curve[7], 0.5);
          curves.splice(index, 1);
          curves.splice(index, 0, cs.left, cs.right);
          index += 2;

          if (index >= curves.length - 1) {
            index = 0;
          }
        }
      };

      function sync(shapes, count) {
        var _loop = function _loop(i) {
          var shape = shapes[shapes.length - 1];
          var newShape = [];
          shape.forEach(function (curve) {
            newShape.push(curve.slice(0));
          });
          shapes.push(newShape);
        };

        for (var i = 0; i < count; i++) {
          _loop();
        }
      }

      pasition.lerp = function (pathA, pathB, t) {
        return pasition._lerp(pasition.path2shapes(pathA), pasition.path2shapes(pathB), t);
      };

      pasition.MIM_CURVES_COUNT = 100;

      pasition._preprocessing = function (pathA, pathB) {
        var lenA = pathA.length,
            lenB = pathB.length,
            clonePathA = JSON.parse(JSON.stringify(pathA)),
            clonePathB = JSON.parse(JSON.stringify(pathB));

        if (lenA > lenB) {
          sync(clonePathB, lenA - lenB);
        } else if (lenA < lenB) {
          sync(clonePathA, lenB - lenA);
        }

        clonePathA = sort(clonePathA, clonePathB);
        clonePathA.forEach(function (curves, index) {
          var lenA = curves.length,
              lenB = clonePathB[index].length;

          if (lenA > lenB) {
            if (lenA < pasition.MIM_CURVES_COUNT) {
              pasition._splitCurves(curves, pasition.MIM_CURVES_COUNT - lenA);

              pasition._splitCurves(clonePathB[index], pasition.MIM_CURVES_COUNT - lenB);
            } else {
              pasition._splitCurves(clonePathB[index], lenA - lenB);
            }
          } else if (lenA < lenB) {
            if (lenB < pasition.MIM_CURVES_COUNT) {
              pasition._splitCurves(curves, pasition.MIM_CURVES_COUNT - lenA);

              pasition._splitCurves(clonePathB[index], pasition.MIM_CURVES_COUNT - lenB);
            } else {
              pasition._splitCurves(curves, lenB - lenA);
            }
          }
        });
        clonePathA.forEach(function (curves, index) {
          clonePathA[index] = sortCurves(curves, clonePathB[index]);
        });
        return [clonePathA, clonePathB];
      };

      pasition._lerp = function (pathA, pathB, t) {
        var shapes = [];
        pathA.forEach(function (curves, index) {
          var newCurves = [];
          curves.forEach(function (curve, curveIndex) {
            newCurves.push(pasition.lerpCurve(curve, pathB[index][curveIndex], t));
          });
          shapes.push(newCurves);
        });
        return shapes;
      };

      pasition.animate = function (option) {
        var pathA = pasition.path2shapes(option.from);
        var pathB = pasition.path2shapes(option.to);

        var pathArr = pasition._preprocessing(pathA, pathB);

        var beginTime = new Date(),
            end = option.end || function () {},
            progress = option.progress || function () {},
            begin = option.begin || function () {},
            easing = option.easing || function (v) {
          return v;
        },
            tickId = null,
            outShape = null,
            time = option.time;

        begin(pathA);

        var tick = function tick() {
          var dt = new Date() - beginTime;

          if (dt >= time) {
            outShape = pathB;
            progress(outShape, 1);
            end(outShape);
            cancelAnimationFrame(tickId);
            return;
          }

          var percent = easing(dt / time);
          outShape = pasition._lerp(pathArr[0], pathArr[1], percent);
          progress(outShape, percent);
          tickId = requestAnimationFrame(tick);
        };

        tick();
      };

      return pasition;
    });
  });

  var path$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _node = interopRequireDefault(node$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');

    var Path = /*#__PURE__*/function (_Node) {
      (0, _inherits2.default)(Path, _Node);

      var _super = _createSuper(Path);

      function Path(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Path);
        _this = _super.call(this, subject);

        _this[setDefault]({
          d: '',
          normalize: false,
          fillColor: undefined,
          fillRule: 'nonzero',
          strokeColor: undefined,
          lineWidth: 1,
          lineJoin: 'miter',
          // 'miter' or 'bevel' or 'round'
          lineCap: 'butt',
          // 'butt' or 'square' or 'round'
          roundSegments: 20,
          // default roundSegment if lineJoin or lineCap is round
          lineDash: undefined,
          lineDashOffset: 0,
          miterLimit: 10,
          texture: undefined,
          textureRect: undefined,
          textureRepeat: false,
          sourceRect: undefined,
          clipPath: undefined
        });

        return _this;
      }

      (0, _createClass2.default)(Path, [{
        key: "d",
        get: function get() {
          return this[getAttribute]('d');
        },
        set: function set(value) {
          this[setAttribute]('d', value);
        }
      }, {
        key: "normalize",
        get: function get() {
          return this[getAttribute]('normalize');
        },
        set: function set(value) {
          this[setAttribute]('normalize', !!value);
        }
      }, {
        key: "fillColor",
        get: function get() {
          return this[getAttribute]('fillColor');
        },
        set: function set(value) {
          this[setAttribute]('fillColor', (0, color.parseColor)(value));
        }
      }, {
        key: "fillRule",
        get: function get() {
          return this[getAttribute]('fillRule');
        },
        set: function set(value) {
          if (value != null && value !== 'nonzero' && value !== 'evenodd') throw new TypeError('Invalid fill rule.');
          this[setAttribute]('fillRule', value);
        }
      }, {
        key: "strokeColor",
        get: function get() {
          return this[getAttribute]('strokeColor');
        },
        set: function set(value) {
          this[setAttribute]('strokeColor', (0, color.parseColor)(value));
        }
      }, {
        key: "lineWidth",
        get: function get() {
          return this[getAttribute]('lineWidth');
        },
        set: function set(value) {
          this[setAttribute]('lineWidth', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "lineJoin",
        get: function get() {
          return this[getAttribute]('lineJoin');
        },
        set: function set(value) {
          if (value != null && value !== 'miter' && value !== 'bevel' && value !== 'round') throw new TypeError('Invalid lineJoin type.');
          this[setAttribute]('lineJoin', value);
        }
      }, {
        key: "lineCap",
        get: function get() {
          return this[getAttribute]('lineCap');
        },
        set: function set(value) {
          if (value != null && value !== 'butt' && value !== 'square' && value !== 'round') throw new TypeError('Invalid lineCap type.');
          this[setAttribute]('lineCap', value);
        }
      }, {
        key: "lineDash",
        get: function get() {
          return this[getAttribute]('lineDash');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (value != null && !Array.isArray(value)) value = [value];
          this[setAttribute]('lineDash', value ? value.map(attribute_value.toNumber) : null);
        }
      }, {
        key: "lineDashOffset",
        get: function get() {
          return this[getAttribute]('lineDashOffset');
        },
        set: function set(value) {
          this[setAttribute]('lineDashOffset', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "miterLimit",
        get: function get() {
          return this[getAttribute]('miterLimit');
        },
        set: function set(value) {
          this[setAttribute]('miterLimit', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "roundSegments",
        get: function get() {
          return this[getAttribute]('roundSegments');
        },
        set: function set(value) {
          this[setAttribute]('roundSegments', value);
        }
      }, {
        key: "texture",
        get: function get() {
          return this[getAttribute]('texture');
        },
        set: function set(value) {
          this[setAttribute]('texture', value);
        }
      }, {
        key: "textureRect",
        get: function get() {
          return this[getAttribute]('textureRect');
        },
        set: function set(value) {
          this[setAttribute]('textureRect', value);
        }
      }, {
        key: "sourceRect",
        get: function get() {
          return this[getAttribute]('sourceRect');
        },
        set: function set(value) {
          this[setAttribute]('sourceRect', value);
        }
      }, {
        key: "textureRepeat",
        get: function get() {
          return this[getAttribute]('textureRepeat');
        },
        set: function set(value) {
          this[setAttribute]('textureRepeat', !!value);
        }
      }, {
        key: "clipPath",
        get: function get() {
          return this[getAttribute]('clipPath');
        },
        set: function set(value) {
          this[setAttribute]('clipPath', value);
        }
      }]);
      return Path;
    }(_node.default);

    exports.default = Path;
  });
  unwrapExports(path$1);

  var path = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _pasition = interopRequireDefault(pasition);

    var _node = interopRequireDefault(node);

    var _path = interopRequireDefault(path$1);

    var _document = interopRequireDefault(document$1);

    var _bounding_box = interopRequireDefault(bounding_box);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _mesh = Symbol('mesh');

    var Path = /*#__PURE__*/function (_Node) {
      (0, _inherits2.default)(Path, _Node);

      var _super = _createSuper(Path);

      function Path() {
        var _this;

        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Path);
        if (typeof attrs === 'string') attrs = {
          d: attrs
        };
        _this = _super.call(this, attrs);
        _this.effects = {
          d: function d(from, to, p, s, e) {
            var ep = (p - s) / (e - s);
            if (ep <= 0) return from;
            if (ep >= 1) return to;

            var shapes = _pasition.default._preprocessing(_pasition.default.path2shapes(from), _pasition.default.path2shapes(to));

            var shape = _pasition.default._lerp.apply(_pasition.default, (0, _toConsumableArray2.default)(shapes).concat([ep]))[0];

            var path = shape.reduce(function (str, c) {
              return "".concat(str).concat(c.slice(2).join(' '), " ");
            }, "M".concat(shape[0][0], " ").concat(shape[0][1], "C")).trim();
            return path;
          }
        };
        return _this;
      }
      /* override */


      (0, _createClass2.default)(Path, [{
        key: "draw",

        /* override */
        value: function draw() {
          var meshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          (0, _get2.default)((0, _getPrototypeOf2.default)(Path.prototype), "draw", this).call(this, meshes);
          var mesh = this.mesh;

          if (mesh) {
            (0, texture.drawTexture)(this, mesh);
          }

          return meshes;
        }
      }, {
        key: "getBoundingClientRect",
        value: function getBoundingClientRect() {
          var boundingBox = null;
          if (this.mesh) boundingBox = this.mesh.boundingBox;
          return (0, _bounding_box.default)(boundingBox, this.renderMatrix);
        }
      }, {
        key: "getPathLength",
        value: function getPathLength() {
          if (this.mesh) {
            return this.mesh.getTotalLength();
          }

          return 0;
        }
      }, {
        key: "getPointAtLength",
        value: function getPointAtLength(len) {
          if (this.mesh) {
            var point = this.mesh.getPointAtLength(len);

            if (point) {
              return [point.x, point.y];
            }
          }

          return [0, 0];
        }
        /* override */

      }, {
        key: "onPropertyChange",
        value: function onPropertyChange(key, newValue, oldValue) {
          (0, _get2.default)((0, _getPrototypeOf2.default)(Path.prototype), "onPropertyChange", this).call(this, key, newValue, oldValue);

          if (key === 'd' || key === 'normalize') {
            this.updateContours();
          } // if(key === 'opacity') {
          //   if(this[_mesh]) this[_mesh].setOpacity(this.opacity);
          // }


          if (this[_mesh] && (key === 'fillColor' || key === 'fillRule')) {
            var _this$attributes = this.attributes,
                fillColor = _this$attributes.fillColor,
                fillRule = _this$attributes.fillRule;
            (0, color.setFillColor)(this[_mesh], {
              color: fillColor,
              rule: fillRule
            });
          }

          if (this[_mesh] && (key === 'strokeColor' || key === 'lineWidth' || key === 'lineCap' || key === 'lineJoin' || key === 'lineDash' || key === 'lineDashOffset' || key === 'roundSegments')) {
            var _this$attributes2 = this.attributes,
                strokeColor = _this$attributes2.strokeColor,
                lineWidth = _this$attributes2.lineWidth;

            if (strokeColor && lineWidth > 0) {
              var _this$attributes3 = this.attributes,
                  lineCap = _this$attributes3.lineCap,
                  lineJoin = _this$attributes3.lineJoin,
                  lineDash = _this$attributes3.lineDash,
                  lineDashOffset = _this$attributes3.lineDashOffset,
                  miterLimit = _this$attributes3.miterLimit,
                  roundSegments = _this$attributes3.roundSegments;
              (0, color.setStrokeColor)(this[_mesh], {
                color: strokeColor,
                lineCap: lineCap,
                lineJoin: lineJoin,
                lineWidth: lineWidth,
                lineDash: lineDash,
                lineDashOffset: lineDashOffset,
                miterLimit: miterLimit,
                roundSegments: roundSegments
              });
            }
          }

          if (this[_mesh] && key === 'clipPath') {
            this[_mesh].setClipPath(newValue);
          }

          if (key === 'texture') {
            (0, texture.applyTexture)(this, newValue);
          }
        }
        /* override */

      }, {
        key: "updateContours",
        value: function updateContours() {
          this.path = new mesh.Figure2D();
          this.path.addPath(this.attributes.d);

          if (this.attributes.normalize) {
            var _this$path;

            (_this$path = this.path).normalize.apply(_this$path, (0, _toConsumableArray2.default)(this.path.boundingCenter));
          }
        }
      }, {
        key: "isVisible",
        get: function get() {
          return !!this.d;
        }
      }, {
        key: "mesh",
        get: function get() {
          if (this.attributes.display === 'none') return null;
          var path = this.path;

          if (path) {
            var _mesh2;

            var mesh$1 = this[_mesh];

            if (!mesh$1) {
              mesh$1 = new mesh.Mesh2D(this.path);
              mesh$1.path = path;
              var fillColor = this.attributes.fillColor;
              var fillRule = this.attributes.fillRule;

              if (fillColor) {
                (0, color.setFillColor)(mesh$1, {
                  color: fillColor,
                  rule: fillRule
                });
              }

              var lineWidth = this.attributes.lineWidth;
              var strokeColor = this.attributes.strokeColor;

              if (strokeColor && lineWidth > 0) {
                var _this$attributes4 = this.attributes,
                    lineCap = _this$attributes4.lineCap,
                    lineJoin = _this$attributes4.lineJoin,
                    miterLimit = _this$attributes4.miterLimit,
                    lineDash = _this$attributes4.lineDash,
                    lineDashOffset = _this$attributes4.lineDashOffset,
                    roundSegments = _this$attributes4.roundSegments;
                (0, color.setStrokeColor)(mesh$1, {
                  color: strokeColor,
                  lineWidth: lineWidth,
                  lineCap: lineCap,
                  lineJoin: lineJoin,
                  miterLimit: miterLimit,
                  lineDash: lineDash,
                  lineDashOffset: lineDashOffset,
                  roundSegments: roundSegments
                });
              } // mesh.setOpacity(this.attributes.opacity);


              this[_mesh] = mesh$1;
              var clipPath = this.attributes.clipPath;

              if (clipPath) {
                this[_mesh].setClipPath(clipPath);
              }
            } else if (mesh$1.path !== path) {
              mesh$1.contours = path.contours;
              mesh$1.path = path;
            }

            var opacity = this.opacity;

            if (mesh$1.getOpacity() !== opacity) {
              mesh$1.setOpacity(opacity);
            }

            (_mesh2 = mesh$1).setTransform.apply(_mesh2, (0, _toConsumableArray2.default)(this.renderMatrix));

            return mesh$1;
          }

          return null;
        }
      }, {
        key: "originalContentRect",
        get: function get() {
          if (this.path) {
            var boundingBox = this.path.boundingBox;
            return [boundingBox[0][0], boundingBox[0][1], boundingBox[1][0] - boundingBox[0][0], boundingBox[1][1] - boundingBox[0][1]];
          }

          return [0, 0, 0, 0];
        }
      }, {
        key: "originalClientRect",
        get: function get() {
          if (this.mesh) {
            var boundingBox = this.mesh.boundingBox;
            return [boundingBox[0][0], boundingBox[0][1], boundingBox[1][0] - boundingBox[0][0], boundingBox[1][1] - boundingBox[0][1]];
          }

          return [0, 0, 0, 0];
        }
      }, {
        key: "originalClientCenter",
        get: function get() {
          if (this.mesh) {
            return this.mesh.boundingCenter;
          }

          return [0, 0];
        }
      }, {
        key: "d",
        set: function set(value) {
          this.attributes.d = value;
        },
        get: function get() {
          return this.attributes.d;
        }
      }]);
      return Path;
    }(_node.default);

    exports.default = Path;
    (0, _defineProperty2.default)(Path, "Attr", _path.default);

    _document.default.registerNode(Path, 'path');
  });
  unwrapExports(path);

  var rect$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _path = interopRequireDefault(path$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');
    var declareAlias = Symbol.for('spritejs_declareAlias');

    function getPath(attr) {
      var width = attr.width,
          height = attr.height;
      return "M".concat(0, " ", 0, "L", width, " ", 0, "L").concat(width, " ").concat(height, "L", 0, " ").concat(height, "Z");
    }

    var Rect = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Rect, _Path);

      var _super = _createSuper(Rect);

      function Rect(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Rect);
        _this = _super.call(this, subject);

        _this[setDefault]({
          width: 0,
          height: 0
          /* size */

        });

        _this[declareAlias]('size');

        return _this;
      } // readonly


      (0, _createClass2.default)(Rect, [{
        key: "d",
        get: function get() {
          return this[getAttribute]('d');
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "width",
        get: function get() {
          return this[getAttribute]('width');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('width', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "height",
        get: function get() {
          return this[getAttribute]('height');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('height', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "size",
        get: function get() {
          return [this.width, this.height];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = [value, value];
          this.width = value[0];
          this.height = value[1];
        }
      }]);
      return Rect;
    }(_path.default);

    exports.default = Rect;
  });
  unwrapExports(rect$2);

  var rect$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _path = interopRequireDefault(path);

    var _document = interopRequireDefault(document$1);

    var _rect = interopRequireDefault(rect$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Rect = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Rect, _Path);

      var _super = _createSuper(Rect);

      function Rect() {
        (0, _classCallCheck2.default)(this, Rect);
        return _super.apply(this, arguments);
      }

      (0, _createClass2.default)(Rect, [{
        key: "isVisible",

        /* override */
        get: function get() {
          var _this$attributes = this.attributes,
              width = _this$attributes.width,
              height = _this$attributes.height;
          return width > 0 && height > 0 && (0, _get2.default)((0, _getPrototypeOf2.default)(Rect.prototype), "isVisible", this);
        }
      }]);
      return Rect;
    }(_path.default);

    exports.default = Rect;
    (0, _defineProperty2.default)(Rect, "Attr", _rect.default);

    _document.default.registerNode(Rect, 'rect');
  });
  unwrapExports(rect$1);

  var smooth_curve = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.makeSmoothCurveLine = makeSmoothCurveLine;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    esm$1.glMatrix.setMatrixArrayType(Array);
    /* istanbul ignore file */

    /**
     * 使用 贝塞尔曲线 模拟绘制平滑曲线
     * @param {*} points 绘制点
     */

    function makeSmoothCurveLine(points) {
      var smoothRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];
      /**
       * 获取 模拟贝塞尔曲线关键控制点
       * @param {*} i
       * @param {*} a
       * @param {*} b
       */

      function getCtrlPoint(i) {
        var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.168;
        var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.168;
        var x0;
        var y0;
        var x1;
        var y1;

        if (points[i].x === points[i + 1].x || points[i].y === points[i + 1].y) {
          a = 0;
          b = 0;
        }

        if (i < 1) {
          x0 = points[0].x + (points[1].x - points[0].x) * a;
          y0 = points[0].y + (points[1].y - points[0].y) * a;
        } else {
          x0 = points[i].x + (points[i + 1].x - points[i - 1].x) * a;
          y0 = points[i].y + (points[i + 1].y - points[i - 1].y) * a;
        }

        if (i > points.length - 3) {
          var last = points.length - 1;
          x1 = points[last].x - (points[last].x - points[last - 1].x) * b;
          y1 = points[last].y - (points[last].y - points[last - 1].y) * b;
        } else {
          x1 = points[i + 1].x - (points[i + 2].x - points[i].x) * b;
          y1 = points[i + 1].y - (points[i + 2].y - points[i].y) * b;
        }

        return [{
          x: x0,
          y: y0
        }, {
          x: x1,
          y: y1
        }];
      }

      points = points.map(function (_ref) {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
            x = _ref2[0],
            y = _ref2[1];

        return {
          x: x,
          y: y
        };
      });
      var d = '';
      var j = 0;
      points.forEach(function (point, i) {
        if (i === 0) {
          d += "M".concat(point.x, " ").concat(point.y);
        } else {
          while (i > smoothRange[j]) {
            j++;
          }

          if (j % 2) {
            var _getCtrlPoint = getCtrlPoint(i - 1),
                _getCtrlPoint2 = (0, _slicedToArray2.default)(_getCtrlPoint, 2),
                A = _getCtrlPoint2[0],
                B = _getCtrlPoint2[1];

            d += "C".concat([A.x, A.y, B.x, B.y, point.x, point.y].join(' '));
          } else {
            d += "L".concat(point.x, " ").concat(point.y);
          }
        }
      });
      return d;
    }
  });
  unwrapExports(smooth_curve);
  smooth_curve.makeSmoothCurveLine;

  var polyline$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _path = interopRequireDefault(path$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');
    var declareAlias = Symbol.for('spritejs_declareAlias');

    function getPath(attr) {
      var points = attr.points,
          smooth = attr.smooth,
          smoothRange = attr.smoothRange,
          close = attr.close;
      var p = [];

      for (var i = 0; i < points.length; i += 2) {
        p.push([points[i], points[i + 1]]);
      }

      var d = '';

      if (smooth) {
        // if(close) {
        //   p.push([...p[0]]);
        // }
        d = (0, smooth_curve.makeSmoothCurveLine)(p, smoothRange);
      } else if (p.length) {
        d = "M".concat(p.map(function (v) {
          return v.join(' ');
        }).join('L'));
      }

      if (d && close) {
        d += 'Z';
      }

      return d;
    }

    var Polyline = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Polyline, _Path);

      var _super = _createSuper(Polyline);

      function Polyline(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Polyline);
        _this = _super.call(this, subject);

        _this[setDefault]({
          points: [],
          smooth: false,
          smoothRange: [0],
          closeType: 'none' // none | normal

          /* close */

        });

        _this[declareAlias]('close');

        return _this;
      } // readonly


      (0, _createClass2.default)(Polyline, [{
        key: "d",
        get: function get() {
          return this[getAttribute]('d');
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "close",
        get: function get() {
          return this.closeType !== 'none';
        },
        set: function set(value) {
          value = value ? 'normal' : 'none';
          this.closeType = value;
        }
      }, {
        key: "closeType",
        get: function get() {
          return this[getAttribute]('closeType');
        },
        set: function set(value) {
          if (value != null && value !== 'none' && value !== 'normal') throw new TypeError('Invalid closeType type.');

          if (this[setAttribute]('closeType', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "smooth",
        get: function get() {
          return this[getAttribute]('smooth');
        },
        set: function set(value) {
          if (this[setAttribute]('smooth', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "smoothRange",
        get: function get() {
          return this[getAttribute]('smoothRange');
        },
        set: function set(value) {
          if (value && !Array.isArray(value)) value = [value];

          if (this[setAttribute]('smoothRange', value)) {
            if (this.smooth) {
              var d = getPath(this);
              this[setAttribute]('d', d);
            }
          }
        }
      }, {
        key: "points",
        get: function get() {
          return this[getAttribute]('points');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);

          if (Array.isArray(value)) {
            value = value.reduce(function (a, b) {
              if (Array.isArray(b)) {
                return [].concat((0, _toConsumableArray2.default)(a), (0, _toConsumableArray2.default)(b.map(function (v) {
                  return (0, attribute_value.toNumber)(v);
                })));
              }

              return [].concat((0, _toConsumableArray2.default)(a), [(0, attribute_value.toNumber)(b)]);
            }, []);
          }

          if (this[setAttribute]('points', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }]);
      return Polyline;
    }(_path.default);

    exports.default = Polyline;
  });
  unwrapExports(polyline$1);

  var polyline = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _path = interopRequireDefault(path);

    var _document = interopRequireDefault(document$1);

    var _polyline = interopRequireDefault(polyline$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Polyline = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Polyline, _Path);

      var _super = _createSuper(Polyline);

      function Polyline() {
        (0, _classCallCheck2.default)(this, Polyline);
        return _super.apply(this, arguments);
      }

      (0, _createClass2.default)(Polyline, [{
        key: "isVisible",

        /* override */
        get: function get() {
          var points = this.attributes.points;
          return points.length > 0 && (0, _get2.default)((0, _getPrototypeOf2.default)(Polyline.prototype), "isVisible", this);
        }
      }]);
      return Polyline;
    }(_path.default);

    exports.default = Polyline;
    (0, _defineProperty2.default)(Polyline, "Attr", _polyline.default);

    _document.default.registerNode(Polyline, 'polyline');
  });
  unwrapExports(polyline);

  var set_1 = createCommonjsModule(function (module) {
    function set(target, property, value, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.set) {
        set = Reflect.set;
      } else {
        set = function set(target, property, value, receiver) {
          var base = superPropBase(target, property);
          var desc;

          if (base) {
            desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.set) {
              desc.set.call(receiver, value);
              return true;
            } else if (!desc.writable) {
              return false;
            }
          }

          desc = Object.getOwnPropertyDescriptor(receiver, property);

          if (desc) {
            if (!desc.writable) {
              return false;
            }

            desc.value = value;
            Object.defineProperty(receiver, property, desc);
          } else {
            defineProperty$3(receiver, property, value);
          }

          return true;
        };
      }

      return set(target, property, value, receiver);
    }

    function _set(target, property, value, receiver, isStrict) {
      var s = set(target, property, value, receiver || target);

      if (!s && isStrict) {
        throw new Error('failed to set property');
      }

      return value;
    }

    module.exports = _set, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(set_1);

  var triangle$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _set2 = interopRequireDefault(set_1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _polyline = interopRequireDefault(polyline$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');

    function getPoints(attr) {
      var _attr$sides = (0, _slicedToArray2.default)(attr.sides, 2),
          a = _attr$sides[0],
          b = _attr$sides[1];

      var angle = attr.angle % 360;
      if (angle < 0) angle += 360;
      angle = Math.PI * angle / 180;
      return [0, 0, a, 0, b * Math.cos(angle), b * Math.sin(angle)];
    }

    var Triangle = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Triangle, _Polyline);

      var _super = _createSuper(Triangle);

      function Triangle(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Triangle);
        _this = _super.call(this, subject);

        _this[setDefault]({
          sides: [0, 0],
          angle: 60,
          closeType: 'normal'
        });

        return _this;
      } // readonly


      (0, _createClass2.default)(Triangle, [{
        key: "points",
        get: function get() {
          return (0, _get2.default)((0, _getPrototypeOf2.default)(Triangle.prototype), "points", this);
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "sides",
        get: function get() {
          return this[getAttribute]('sides');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (value != null && !Array.isArray(value)) value = [value, value];

          if (this[setAttribute]('sides', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Triangle.prototype), "points", points, this, true);
          }
        }
      }, {
        key: "angle",
        get: function get() {
          return this[getAttribute]('angle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('angle', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Triangle.prototype), "points", points, this, true);
          }
        }
      }]);
      return Triangle;
    }(_polyline.default);

    exports.default = Triangle;
  });
  unwrapExports(triangle$2);

  var triangle$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _polyline = interopRequireDefault(polyline);

    var _document = interopRequireDefault(document$1);

    var _triangle = interopRequireDefault(triangle$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Triangle = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Triangle, _Polyline);

      var _super = _createSuper(Triangle);

      function Triangle() {
        (0, _classCallCheck2.default)(this, Triangle);
        return _super.apply(this, arguments);
      }

      (0, _createClass2.default)(Triangle, [{
        key: "isVisible",
        get: function get() {
          var sides = this.attributes.sides;
          return sides[0] > 0 && sides[1] > 0 && (0, _get2.default)((0, _getPrototypeOf2.default)(Triangle.prototype), "isVisible", this);
        }
      }]);
      return Triangle;
    }(_polyline.default);

    exports.default = Triangle;
    (0, _defineProperty2.default)(Triangle, "Attr", _triangle.default);

    _document.default.registerNode(Triangle, 'triangle');
  });
  unwrapExports(triangle$1);

  var parallel$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _set2 = interopRequireDefault(set_1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _polyline = interopRequireDefault(polyline$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');

    function getPoints(attr) {
      var _attr$sides = (0, _slicedToArray2.default)(attr.sides, 2),
          a = _attr$sides[0],
          b = _attr$sides[1];

      var angle = attr.angle % 360;
      if (angle < 0) angle += 360;
      angle = Math.PI * angle / 180;
      var x1 = b * Math.cos(angle);
      var y1 = b * Math.sin(angle);
      return [0, 0, a, 0, x1 + a, y1, x1, y1];
    }

    var Parallel = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Parallel, _Polyline);

      var _super = _createSuper(Parallel);

      function Parallel(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Parallel);
        _this = _super.call(this, subject);

        _this[setDefault]({
          sides: [0, 0],
          angle: 90,
          closeType: 'normal'
        });

        return _this;
      } // readonly


      (0, _createClass2.default)(Parallel, [{
        key: "points",
        get: function get() {
          return (0, _get2.default)((0, _getPrototypeOf2.default)(Parallel.prototype), "points", this);
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "sides",
        get: function get() {
          return this[getAttribute]('sides');
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (value != null && !Array.isArray(value)) value = [value, value];

          if (this[setAttribute]('sides', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Parallel.prototype), "points", points, this, true);
          }
        }
      }, {
        key: "angle",
        get: function get() {
          return this[getAttribute]('angle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('angle', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Parallel.prototype), "points", points, this, true);
          }
        }
      }]);
      return Parallel;
    }(_polyline.default);

    exports.default = Parallel;
  });
  unwrapExports(parallel$2);

  var parallel$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _polyline = interopRequireDefault(polyline);

    var _document = interopRequireDefault(document$1);

    var _parallel = interopRequireDefault(parallel$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Parallel = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Parallel, _Polyline);

      var _super = _createSuper(Parallel);

      function Parallel() {
        (0, _classCallCheck2.default)(this, Parallel);
        return _super.apply(this, arguments);
      }

      (0, _createClass2.default)(Parallel, [{
        key: "isVisible",

        /* override */
        get: function get() {
          var sides = this.attributes.sides;
          return sides[0] > 0 && sides[1] > 0 && (0, _get2.default)((0, _getPrototypeOf2.default)(Parallel.prototype), "isVisible", this);
        }
      }]);
      return Parallel;
    }(_polyline.default);

    exports.default = Parallel;
    (0, _defineProperty2.default)(Parallel, "Attr", _parallel.default);

    _document.default.registerNode(Parallel, 'parallel');
  });
  unwrapExports(parallel$1);

  var regular$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _set2 = interopRequireDefault(set_1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _polyline = interopRequireDefault(polyline$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');

    function getPoints(attr) {
      var edges = attr.edges,
          radius = attr.radius,
          offsetAngle = attr.offsetAngle;
      var offset = Math.PI * offsetAngle / 180 - 0.5 * Math.PI;
      if (edges < 3 || radius <= 0) return [];
      var points = [];

      for (var i = 0; i < edges; i++) {
        var angle = i * 2 * Math.PI / edges + offset;
        var x = radius * Math.cos(angle);
        var y = radius * Math.sin(angle);
        points.push(x, y);
      }

      return points;
    }

    var Regular = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Regular, _Polyline);

      var _super = _createSuper(Regular);

      function Regular(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Regular);
        _this = _super.call(this, subject);

        _this[setDefault]({
          edges: 3,
          radius: 0,
          offsetAngle: 0,
          closeType: 'normal'
        });

        return _this;
      } // readonly


      (0, _createClass2.default)(Regular, [{
        key: "points",
        get: function get() {
          return (0, _get2.default)((0, _getPrototypeOf2.default)(Regular.prototype), "points", this);
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "edges",
        get: function get() {
          return this[getAttribute]('edges');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('edges', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Regular.prototype), "points", points, this, true);
          }
        }
      }, {
        key: "radius",
        get: function get() {
          return this[getAttribute]('radius');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('radius', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Regular.prototype), "points", points, this, true);
          }
        }
      }, {
        key: "offsetAngle",
        get: function get() {
          return this[getAttribute]('offsetAngle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('offsetAngle', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Regular.prototype), "points", points, this, true);
          }
        }
      }]);
      return Regular;
    }(_polyline.default);

    exports.default = Regular;
  });
  unwrapExports(regular$1);

  var regular = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _polyline = interopRequireDefault(polyline);

    var _document = interopRequireDefault(document$1);

    var _regular = interopRequireDefault(regular$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Regular = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Regular, _Polyline);

      var _super = _createSuper(Regular);

      function Regular() {
        (0, _classCallCheck2.default)(this, Regular);
        return _super.apply(this, arguments);
      }

      return Regular;
    }(_polyline.default);

    exports.default = Regular;
    (0, _defineProperty2.default)(Regular, "Attr", _regular.default);

    _document.default.registerNode(Regular, 'regular');
  });
  unwrapExports(regular);

  var star$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _set2 = interopRequireDefault(set_1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _polyline = interopRequireDefault(polyline$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');

    function getPoints(attr) {
      var angles = attr.angles,
          innerRadius = attr.innerRadius,
          outerRadius = attr.outerRadius,
          offsetAngle = attr.offsetAngle;
      var offset = Math.PI * offsetAngle / 180 - 0.5 * Math.PI;
      if (angles < 3 || innerRadius <= 0 || outerRadius <= 0) return [];
      var points = [];

      for (var i = 0; i < angles * 2; i++) {
        var angle = i * Math.PI / angles + offset;
        var radius = i % 2 ? innerRadius : outerRadius;
        var x = radius * Math.cos(angle);
        var y = radius * Math.sin(angle);
        points.push(x, y);
      }

      return points;
    }

    var Star = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Star, _Polyline);

      var _super = _createSuper(Star);

      function Star(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Star);
        _this = _super.call(this, subject);

        _this[setDefault]({
          angles: 5,
          innerRadius: 0,
          outerRadius: 0,

          /* radius */
          offsetAngle: 0,
          closeType: 'normal'
        });

        return _this;
      } // readonly


      (0, _createClass2.default)(Star, [{
        key: "points",
        get: function get() {
          return (0, _get2.default)((0, _getPrototypeOf2.default)(Star.prototype), "points", this);
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "angles",
        get: function get() {
          return this[getAttribute]('angles');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('angles', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Star.prototype), "points", points, this, true);
          }
        }
      }, {
        key: "innerRadius",
        get: function get() {
          return this[getAttribute]('innerRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('innerRadius', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Star.prototype), "points", points, this, true);
          }
        }
      }, {
        key: "outerRadius",
        get: function get() {
          return this[getAttribute]('outerRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('outerRadius', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Star.prototype), "points", points, this, true);
          }
        }
      }, {
        key: "radius",
        get: function get() {
          return [this.innerRadius, this.outerRadius];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (!Array.isArray(value)) value = [value, value];
          this.innerRadius = value[0];
          this.outerRadius = value[1];
        }
      }, {
        key: "offsetAngle",
        get: function get() {
          return this[getAttribute]('offsetAngle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('offsetAngle', value)) {
            var points = getPoints(this);
            (0, _set2.default)((0, _getPrototypeOf2.default)(Star.prototype), "points", points, this, true);
          }
        }
      }]);
      return Star;
    }(_polyline.default);

    exports.default = Star;
  });
  unwrapExports(star$2);

  var star$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _polyline = interopRequireDefault(polyline);

    var _document = interopRequireDefault(document$1);

    var _star = interopRequireDefault(star$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Star = /*#__PURE__*/function (_Polyline) {
      (0, _inherits2.default)(Star, _Polyline);

      var _super = _createSuper(Star);

      function Star() {
        (0, _classCallCheck2.default)(this, Star);
        return _super.apply(this, arguments);
      }

      return Star;
    }(_polyline.default);

    exports.default = Star;
    (0, _defineProperty2.default)(Star, "Attr", _star.default);

    _document.default.registerNode(Star, 'star');
  });
  unwrapExports(star$1);

  var ellipse$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _path = interopRequireDefault(path$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');
    var declareAlias = Symbol.for('spritejs_declareAlias');

    function getPath(attr) {
      var radiusX = attr.radiusX,
          radiusY = attr.radiusY,
          startAngle = attr.startAngle,
          endAngle = attr.endAngle,
          direction = attr.direction,
          closeType = attr.closeType;
      var anticlockwise = direction === 'anitclockwise';
      var f = new mesh.Figure2D();

      if (closeType === 'sector') {
        f.moveTo(0, 0);
      }

      f.ellipse(0, 0, radiusX, radiusY, 0, Math.PI * startAngle / 180, Math.PI * endAngle / 180, anticlockwise);

      if (closeType !== 'none') {
        f.closePath();
      }

      var path = f.path;
      var ret = path.reduce(function (a, b) {
        return a + b.join(' ');
      }, '');
      return ret;
    }

    var Ellipse = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Ellipse, _Path);

      var _super = _createSuper(Ellipse);

      function Ellipse(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Ellipse);
        _this = _super.call(this, subject);

        _this[setDefault]({
          radiusX: 0,
          radiusY: 0,

          /* radius */
          startAngle: 0,
          endAngle: 360,

          /* angle */
          direction: 'clockwise',
          // clockwise | anticlockwise
          closeType: 'none' // none | sector | normal

        });

        _this[declareAlias]('radius', 'angle');

        return _this;
      } // readonly


      (0, _createClass2.default)(Ellipse, [{
        key: "d",
        get: function get() {
          return this[getAttribute]('d');
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "radiusX",
        get: function get() {
          return this[getAttribute]('radiusX');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('radiusX', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "radiusY",
        get: function get() {
          return this[getAttribute]('radiusY');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('radiusY', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "radius",
        get: function get() {
          return [this.radiusX, this.radiusY];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (!Array.isArray(value)) value = [value, value];
          this.radiusX = value[0];
          this.radiusY = value[1];
        }
      }, {
        key: "angle",
        get: function get() {
          return [this.startAngle, this.endAngle];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = [value, value];
          this.startAngle = value[0];
          this.endAngle = value[1];
        }
      }, {
        key: "direction",
        get: function get() {
          return this[getAttribute]('direction');
        },
        set: function set(value) {
          if (value != null && value !== 'clockwise' && value !== 'anticlockwise') throw new TypeError('Invalid direction type.');
          this[setAttribute]('direction', value);
        }
      }, {
        key: "startAngle",
        get: function get() {
          return this[getAttribute]('startAngle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('startAngle', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "endAngle",
        get: function get() {
          return this[getAttribute]('endAngle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('endAngle', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "closeType",
        get: function get() {
          return this[getAttribute]('closeType');
        },
        set: function set(value) {
          if (value != null && value !== 'none' && value !== 'sector' && value !== 'normal') throw new TypeError('Invalid closeType type.');

          if (this[setAttribute]('closeType', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }]);
      return Ellipse;
    }(_path.default);

    exports.default = Ellipse;
  });
  unwrapExports(ellipse$1);

  var ellipse = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _path = interopRequireDefault(path);

    var _document = interopRequireDefault(document$1);

    var _ellipse = interopRequireDefault(ellipse$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Ellipse = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Ellipse, _Path);

      var _super = _createSuper(Ellipse);

      function Ellipse() {
        (0, _classCallCheck2.default)(this, Ellipse);
        return _super.apply(this, arguments);
      }

      (0, _createClass2.default)(Ellipse, [{
        key: "isVisible",

        /* override */
        get: function get() {
          var _this$attributes = this.attributes,
              radiusX = _this$attributes.radiusX,
              radiusY = _this$attributes.radiusY,
              startAngle = _this$attributes.startAngle,
              endAngle = _this$attributes.endAngle;
          return radiusX > 0 && radiusY > 0 && startAngle !== endAngle && (0, _get2.default)((0, _getPrototypeOf2.default)(Ellipse.prototype), "isVisible", this);
        }
      }]);
      return Ellipse;
    }(_path.default);

    exports.default = Ellipse;
    (0, _defineProperty2.default)(Ellipse, "Attr", _ellipse.default);

    _document.default.registerNode(Ellipse, 'ellipse');
  });
  unwrapExports(ellipse);

  var arc$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _set2 = interopRequireDefault(set_1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _ellipse = interopRequireDefault(ellipse$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Arc = /*#__PURE__*/function (_Ellipse) {
      (0, _inherits2.default)(Arc, _Ellipse);

      var _super = _createSuper(Arc);

      function Arc() {
        (0, _classCallCheck2.default)(this, Arc);
        return _super.apply(this, arguments);
      }

      (0, _createClass2.default)(Arc, [{
        key: "radius",
        get: function get() {
          return (0, _get2.default)((0, _getPrototypeOf2.default)(Arc.prototype), "radiusX", this);
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);
          (0, _set2.default)((0, _getPrototypeOf2.default)(Arc.prototype), "radiusX", value, this, true);
          (0, _set2.default)((0, _getPrototypeOf2.default)(Arc.prototype), "radiusY", value, this, true);
        }
      }]);
      return Arc;
    }(_ellipse.default);

    exports.default = Arc;
  });
  unwrapExports(arc$1);

  var arc = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _ellipse = interopRequireDefault(ellipse);

    var _document = interopRequireDefault(document$1);

    var _arc = interopRequireDefault(arc$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Arc = /*#__PURE__*/function (_Ellipse) {
      (0, _inherits2.default)(Arc, _Ellipse);

      var _super = _createSuper(Arc);

      function Arc() {
        (0, _classCallCheck2.default)(this, Arc);
        return _super.apply(this, arguments);
      }

      return Arc;
    }(_ellipse.default);

    exports.default = Arc;
    (0, _defineProperty2.default)(Arc, "Attr", _arc.default);

    _document.default.registerNode(Arc, 'arc');
  });
  unwrapExports(arc);

  var ring$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _path = interopRequireDefault(path$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');
    var declareAlias = Symbol.for('spritejs_declareAlias');

    function getPath(attr) {
      var innerRadius = attr.innerRadius,
          outerRadius = attr.outerRadius,
          startAngle = attr.startAngle,
          endAngle = attr.endAngle;
      var f = new mesh.Figure2D();
      startAngle = Math.PI * startAngle / 180;
      endAngle = Math.PI * endAngle / 180;

      if (innerRadius > outerRadius) {
        var _ref = [outerRadius, innerRadius];
        innerRadius = _ref[0];
        outerRadius = _ref[1];
      }

      if (innerRadius <= 0) {
        f.moveTo(0, 0);
      }

      f.arc(0, 0, outerRadius, startAngle, endAngle, false);

      if (innerRadius > 0) {
        var PI2 = Math.PI * 2;

        if (endAngle < startAngle) {
          endAngle = startAngle + PI2 + (endAngle - startAngle) % PI2;
        }

        if (endAngle - startAngle >= PI2) {
          endAngle = startAngle + PI2 - 1e-6;
        }

        f.arc(0, 0, innerRadius, endAngle, startAngle, true);
      }

      f.closePath();
      var path = f.path;
      var ret = path.reduce(function (a, b) {
        return a + b.join(' ');
      }, '');
      return ret;
    }

    var Ring = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Ring, _Path);

      var _super = _createSuper(Ring);

      function Ring(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Ring);
        _this = _super.call(this, subject);

        _this[setDefault]({
          innerRadius: 0,
          outerRadius: 0,

          /* radius */
          startAngle: 0,
          endAngle: 360
          /* angle */

        });

        _this[declareAlias]('radius', 'angle');

        return _this;
      } // readonly


      (0, _createClass2.default)(Ring, [{
        key: "d",
        get: function get() {
          return this[getAttribute]('d');
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "innerRadius",
        get: function get() {
          return this[getAttribute]('innerRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('innerRadius', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "outerRadius",
        get: function get() {
          return this[getAttribute]('outerRadius');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('outerRadius', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "radius",
        get: function get() {
          return [this.innerRadius, this.outerRadius];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value, true);
          if (!Array.isArray(value)) value = [value, value];
          this.innerRadius = value[0];
          this.outerRadius = value[1];
        }
      }, {
        key: "startAngle",
        get: function get() {
          return this[getAttribute]('startAngle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('startAngle', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "endAngle",
        get: function get() {
          return this[getAttribute]('endAngle');
        },
        set: function set(value) {
          value = (0, attribute_value.toNumber)(value);

          if (this[setAttribute]('endAngle', value)) {
            var d = getPath(this);
            this[setAttribute]('d', d);
          }
        }
      }, {
        key: "angle",
        get: function get() {
          return [this.startAngle, this.endAngle];
        },
        set: function set(value) {
          value = (0, attribute_value.toArray)(value);
          if (!Array.isArray(value)) value = [value, value];
          this.startAngle = value[0];
          this.endAngle = value[1];
        }
      }]);
      return Ring;
    }(_path.default);

    exports.default = Ring;
  });
  unwrapExports(ring$2);

  var ring$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _path = interopRequireDefault(path);

    var _document = interopRequireDefault(document$1);

    var _ring = interopRequireDefault(ring$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var Ring = /*#__PURE__*/function (_Path) {
      (0, _inherits2.default)(Ring, _Path);

      var _super = _createSuper(Ring);

      function Ring() {
        (0, _classCallCheck2.default)(this, Ring);
        return _super.apply(this, arguments);
      }

      (0, _createClass2.default)(Ring, [{
        key: "isVisible",

        /* override */
        get: function get() {
          var _this$attributes = this.attributes,
              innerRadius = _this$attributes.innerRadius,
              outerRadius = _this$attributes.outerRadius,
              startAngle = _this$attributes.startAngle,
              endAngle = _this$attributes.endAngle;
          return (innerRadius > 0 || outerRadius > 0) && startAngle !== endAngle && (0, _get2.default)((0, _getPrototypeOf2.default)(Ring.prototype), "isVisible", this);
        }
      }]);
      return Ring;
    }(_path.default);

    exports.default = Ring;
    (0, _defineProperty2.default)(Ring, "Attr", _ring.default);

    _document.default.registerNode(Ring, 'ring');
  });
  unwrapExports(ring$1);

  var label$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _block = interopRequireDefault(block$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var setDefault = Symbol.for('spritejs_setAttributeDefault');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var getAttribute = Symbol.for('spritejs_getAttribute');
    var declareAlias = Symbol.for('spritejs_declareAlias');

    var Label = /*#__PURE__*/function (_Block) {
      (0, _inherits2.default)(Label, _Block);

      var _super = _createSuper(Label);

      function Label(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, Label);
        _this = _super.call(this, subject);

        _this[setDefault]({
          text: '',
          fontSize: 16,
          fontFamily: 'Helvetica,Arial,sans-serif',
          fontStyle: 'normal',
          fontVariant: 'normal',
          fontWeight: 'normal',
          fontStretch: 'normal',
          lineHeight: '',

          /* font */
          textAlign: 'left',
          strokeColor: undefined,
          strokeWidth: 1,
          fillColor: undefined,
          verticalAlign: 'middle'
        });

        _this[declareAlias]('font');

        return _this;
      }

      (0, _createClass2.default)(Label, [{
        key: "text",
        get: function get() {
          return this[getAttribute]('text') || ' ';
        },
        set: function set(value) {
          this[setAttribute]('text', value);
        }
      }, {
        key: "fontSize",
        get: function get() {
          return this[getAttribute]('fontSize');
        },
        set: function set(value) {
          this[setAttribute]('fontSize', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "fontFamily",
        get: function get() {
          return this[getAttribute]('fontFamily');
        },
        set: function set(value) {
          this[setAttribute]('fontFamily', value);
        }
      }, {
        key: "fontStyle",
        get: function get() {
          return this[getAttribute]('fontStyle');
        },
        set: function set(value) {
          this[setAttribute]('fontStyle', value);
        }
      }, {
        key: "fontVariant",
        get: function get() {
          return this[getAttribute]('fontVariant');
        },
        set: function set(value) {
          this[setAttribute]('fontVariant', value);
        }
      }, {
        key: "fontWeight",
        get: function get() {
          return this[getAttribute]('fontWeight');
        },
        set: function set(value) {
          this[setAttribute]('fontWeight', value);
        }
      }, {
        key: "fontStretch",
        get: function get() {
          return this[getAttribute]('fontStretch');
        },
        set: function set(value) {
          this[setAttribute]('fontStretch', value);
        }
      }, {
        key: "lineHeight",
        get: function get() {
          return this[getAttribute]('lineHeight') || this.fontSize;
        },
        set: function set(value) {
          this[setAttribute]('lineHeight', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "textAlign",
        get: function get() {
          return this[getAttribute]('textAlign');
        },
        set: function set(value) {
          this[setAttribute]('textAlign', value);
        }
      }, {
        key: "strokeColor",
        get: function get() {
          return this[getAttribute]('strokeColor');
        },
        set: function set(value) {
          this[setAttribute]('strokeColor', (0, color.parseColor)(value));
        }
      }, {
        key: "strokeWidth",
        get: function get() {
          return this[getAttribute]('strokeWidth');
        },
        set: function set(value) {
          this[setAttribute]('strokeWidth', (0, attribute_value.toNumber)(value));
        }
      }, {
        key: "verticalAlign",
        get: function get() {
          return this[getAttribute]('verticalAlign');
        },
        set: function set(value) {
          this[setAttribute]('verticalAlign', value);
        }
      }, {
        key: "fillColor",
        get: function get() {
          return this[getAttribute]('fillColor');
        },
        set: function set(value) {
          this[setAttribute]('fillColor', (0, color.parseColor)(value));
        }
      }, {
        key: "font",
        get: function get() {
          var fontStyle = this.fontStyle,
              fontVariant = this.fontVariant,
              fontWeight = this.fontWeight,
              fontStretch = this.fontStretch,
              fontSize = this.fontSize,
              lineHeight = this.lineHeight,
              fontFamily = this.fontFamily;
          return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontStretch, " ").concat(fontSize, "px/").concat(lineHeight, "px ").concat(fontFamily);
        },
        set: function set(value) {
          if (value == null) {
            this.fontStyle = null;
            this.fontVariant = null;
            this.fontWeight = null;
            this.fontStretch = null;
            this.fontSize = null;
            this.lineHeight = null;
            this.fontFamily = null;
          } else {
            var fontInfo = (0, mesh.parseFont)(value);
            this.fontStyle = fontInfo.style;
            this.fontVariant = fontInfo.variant;
            this.fontWeight = fontInfo.weight;
            this.fontStretch = fontInfo.stretch;
            this.fontSize = (0, attribute_value.toNumber)("".concat(fontInfo.size).concat(fontInfo.unit));

            if (fontInfo.lineHeight) {
              this.lineHeight = fontInfo.pxLineHeight;
            }

            this.fontFamily = fontInfo.family;
          }
        }
      }]);
      return Label;
    }(_block.default);

    exports.default = Label;
  });
  unwrapExports(label$1);

  var label = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get4 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _block = interopRequireDefault(block$1);

    var _label = interopRequireDefault(label$1);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _textImage = Symbol('textImage');

    var _textImageTask = Symbol('textImageTask');

    var _textureContext = Symbol('textureContext');

    var _updateTextureRect = Symbol('updateTextureRect');

    var _textCanvas = Symbol('textCanvas');

    var Label = /*#__PURE__*/function (_Block) {
      (0, _inherits2.default)(Label, _Block);

      var _super = _createSuper(Label);

      function Label() {
        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Label);
        if (typeof attrs === 'string') attrs = {
          text: attrs
        };
        return _super.call(this, attrs);
      }
      /* override */


      (0, _createClass2.default)(Label, [{
        key: "draw",

        /* override */
        value: function draw(meshes) {
          (0, _get4.default)((0, _getPrototypeOf2.default)(Label.prototype), "draw", this).call(this, meshes);
          var mesh = this.mesh;

          if (mesh) {
            var textImage = this[_textImage];

            if (textImage) {
              var texture$1 = mesh.texture;

              if (!texture$1 || this[_textureContext] && this[_textureContext] !== this.renderer || textImage.needsUpdate) {
                textImage.needsUpdate = false;
                (0, texture.deleteTexture)(textImage.image, this.renderer);
                texture$1 = (0, texture.createTexture)(textImage.image, this.renderer);
                this[_updateTextureRect] = true;
              } else {
                texture$1 = mesh.uniforms.u_texSampler;
              }

              if (this[_updateTextureRect]) {
                var _textImage$rect$slice = textImage.rect.slice(2),
                    _textImage$rect$slice2 = (0, _slicedToArray2.default)(_textImage$rect$slice, 2),
                    width = _textImage$rect$slice2[0],
                    height = _textImage$rect$slice2[1];

                var _this$contentSize = (0, _slicedToArray2.default)(this.contentSize, 2),
                    w = _this$contentSize[0];
                    _this$contentSize[1];

                var textAlign = this.attributes.textAlign;
                var verticalAlign = this.attributes.verticalAlign;
                var x = 0;

                if (textAlign === 'center') {
                  x = (w - width) / 2;
                } else if (textAlign === 'right' || textAlign === 'end') {
                  x = w - width;
                }

                var fontHeight = this.attributes.fontSize;
                var lineHeight = this.attributes.lineHeight;
                var y = 0; // middle

                if (verticalAlign === 'top') {
                  y = (fontHeight - lineHeight) / 2;
                } else if (verticalAlign === 'bottom') {
                  y = (lineHeight - fontHeight) / 2;
                }

                var _this$attributes = this.attributes,
                    paddingLeft = _this$attributes.paddingLeft,
                    paddingTop = _this$attributes.paddingTop;
                var borderWidth = this.attributes.borderWidth;
                x += paddingLeft + borderWidth;
                y += paddingTop + borderWidth;
                var _this$attributes2 = this.attributes,
                    anchorX = _this$attributes2.anchorX,
                    anchorY = _this$attributes2.anchorY;
                x -= this.clientSize[0] * anchorX;
                y -= this.clientSize[1] * anchorY;
                mesh.setTexture(texture$1, {
                  rect: [x, y, width, height]
                });
                this[_updateTextureRect] = false;
                this[_textureContext] = this.renderer;
              }
            }
          }

          return meshes;
        }
        /* override */

      }, {
        key: "onPropertyChange",
        value: function onPropertyChange(key, newValue, oldValue) {
          if (key === 'text' || key === 'fontSize' || key === 'fontFamily' || key === 'fontStyle' || key === 'fontVariant' || key === 'fontWeight' || key === 'fontStretch' || key === 'lineHeight' || key === 'strokeColor' || key === 'fillColor' || key === 'strokeWidth') {
            this.updateText();
          } else {
            if (key === 'textAlign' || key === 'verticalAlign') {
              this[_updateTextureRect] = true;
            }

            (0, _get4.default)((0, _getPrototypeOf2.default)(Label.prototype), "onPropertyChange", this).call(this, key, newValue, oldValue);
          }
        }
        /* override */

      }, {
        key: "updateContours",
        value: function updateContours() {
          (0, _get4.default)((0, _getPrototypeOf2.default)(Label.prototype), "updateContours", this).call(this);
          this[_updateTextureRect] = true;
        }
      }, {
        key: "updateText",
        value: function updateText() {
          var _this = this;

          if (!this[_textImageTask]) {
            this[_textImageTask] = Promise.resolve().then(function () {
              _this[_textImageTask] = null;
              var _this$attributes3 = _this.attributes,
                  text = _this$attributes3.text,
                  font = _this$attributes3.font,
                  fillColor = _this$attributes3.fillColor,
                  strokeColor = _this$attributes3.strokeColor,
                  strokeWidth = _this$attributes3.strokeWidth;
              var ratio = _this.layer ? _this.layer.displayRatio : 1;
              _this[_textCanvas] = _this[_textCanvas] || mesh.ENV.createCanvas(1, 1);
              _this[_textImage] = mesh.ENV.createText(text, {
                font: font,
                fillColor: fillColor,
                strokeColor: strokeColor,
                strokeWidth: strokeWidth,
                parseFont: mesh.parseFont,
                ratio: ratio,
                textCanvas: _this[_textCanvas]
              });
              _this[_textImage].needsUpdate = true;

              _this.updateContours();

              _this.forceUpdate();

              return _this[_textImage];
            });
          }
        }
      }, {
        key: "contentSize",
        get: function get() {
          var _get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(Label.prototype), "contentSize", this),
              _get3 = (0, _slicedToArray2.default)(_get2, 2),
              w = _get3[0],
              h = _get3[1];

          var _this$attributes4 = this.attributes,
              width = _this$attributes4.width,
              height = _this$attributes4.height;

          if (width == null || height == null) {
            var img = this[_textImage];

            if (img) {
              if (width == null) w = img.rect[2];
              if (height == null) h = img.rect[3];
            }
          }

          return [w, h];
        }
      }, {
        key: "text",
        get: function get() {
          return this.attributes.text;
        },
        set: function set(value) {
          this.attributes.text = value;
        }
      }, {
        key: "textContent",
        get: function get() {
          return this.attributes.text;
        },
        set: function set(value) {
          this.attributes.text = value;
        }
      }, {
        key: "textImage",
        get: function get() {
          return this[_textImage] || {};
        }
      }, {
        key: "textImageReady",
        get: function get() {
          return this[_textImageTask] || Promise.resolve();
        }
      }]);
      return Label;
    }(_block.default);

    exports.default = Label;
    (0, _defineProperty2.default)(Label, "Attr", _label.default);

    _document.default.registerNode(Label, 'label');
  });
  unwrapExports(label);

  var group$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _block = interopRequireDefault(block$2);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    } // const setDefault = Symbol.for('spritejs_setAttributeDefault');


    var Group = /*#__PURE__*/function (_Block) {
      (0, _inherits2.default)(Group, _Block);

      var _super = _createSuper(Group);

      function Group() {
        (0, _classCallCheck2.default)(this, Group);
        return _super.apply(this, arguments);
      }

      return Group;
    }(_block.default);

    exports.default = Group;
  });
  unwrapExports(group$1);

  //Types of elements found in the DOM
  var domelementtype = {
    Text: "text",
    //Text
    Directive: "directive",
    //<? ... ?>
    Comment: "comment",
    //<!-- ... -->
    Script: "script",
    //<script> tags
    Style: "style",
    //<style> tags
    Tag: "tag",
    //Any tag
    CDATA: "cdata",
    //<![CDATA[ ... ]]>
    Doctype: "doctype",
    isTag: function (elem) {
      return elem.type === "tag" || elem.type === "script" || elem.type === "style";
    }
  };

  /** Types of elements found in htmlparser2's DOM */
  var ElementType;

  (function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */

    ElementType["Text"] = "text";
    /** Type for <? ... ?> */

    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */

    ElementType["Comment"] = "comment";
    /** Type for <script> tags */

    ElementType["Script"] = "script";
    /** Type for <style> tags */

    ElementType["Style"] = "style";
    /** Type for Any tag */

    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */

    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */

    ElementType["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  /**
   * Tests whether an element is a tag or not.
   *
   * @param elem Element to test
   */


  function isTag$2(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  } // Exports for backwards compatibility

  /** Type for the root element of a document */

  const Root = ElementType.Root;
  /** Type for Text */

  const Text = ElementType.Text;
  /** Type for <? ... ?> */

  const Directive = ElementType.Directive;
  /** Type for <!-- ... --> */

  const Comment = ElementType.Comment;
  /** Type for <script> tags */

  const Script = ElementType.Script;
  /** Type for <style> tags */

  const Style = ElementType.Style;
  /** Type for Any tag */

  const Tag = ElementType.Tag;
  /** Type for <![CDATA[ ... ]]> */

  const CDATA = ElementType.CDATA;
  /** Type for <!doctype ...> */

  const Doctype = ElementType.Doctype;

  var esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get ElementType () { return ElementType; },
    isTag: isTag$2,
    Root: Root,
    Text: Text,
    Directive: Directive,
    Comment: Comment,
    Script: Script,
    Style: Style,
    Tag: Tag,
    CDATA: CDATA,
    Doctype: Doctype
  });

  var Aacute$1 = "Á";
  var aacute$1 = "á";
  var Abreve = "Ă";
  var abreve = "ă";
  var ac = "∾";
  var acd = "∿";
  var acE = "∾̳";
  var Acirc$1 = "Â";
  var acirc$1 = "â";
  var acute$1 = "´";
  var Acy = "А";
  var acy = "а";
  var AElig$1 = "Æ";
  var aelig$1 = "æ";
  var af = "⁡";
  var Afr = "𝔄";
  var afr = "𝔞";
  var Agrave$1 = "À";
  var agrave$1 = "à";
  var alefsym = "ℵ";
  var aleph = "ℵ";
  var Alpha = "Α";
  var alpha = "α";
  var Amacr = "Ā";
  var amacr = "ā";
  var amalg = "⨿";
  var amp$2 = "&";
  var AMP$1 = "&";
  var andand = "⩕";
  var And = "⩓";
  var and = "∧";
  var andd = "⩜";
  var andslope = "⩘";
  var andv = "⩚";
  var ang = "∠";
  var ange = "⦤";
  var angle = "∠";
  var angmsdaa = "⦨";
  var angmsdab = "⦩";
  var angmsdac = "⦪";
  var angmsdad = "⦫";
  var angmsdae = "⦬";
  var angmsdaf = "⦭";
  var angmsdag = "⦮";
  var angmsdah = "⦯";
  var angmsd = "∡";
  var angrt = "∟";
  var angrtvb = "⊾";
  var angrtvbd = "⦝";
  var angsph = "∢";
  var angst = "Å";
  var angzarr = "⍼";
  var Aogon = "Ą";
  var aogon = "ą";
  var Aopf = "𝔸";
  var aopf = "𝕒";
  var apacir = "⩯";
  var ap = "≈";
  var apE = "⩰";
  var ape = "≊";
  var apid = "≋";
  var apos$1 = "'";
  var ApplyFunction = "⁡";
  var approx = "≈";
  var approxeq = "≊";
  var Aring$1 = "Å";
  var aring$1 = "å";
  var Ascr = "𝒜";
  var ascr = "𝒶";
  var Assign = "≔";
  var ast = "*";
  var asymp = "≈";
  var asympeq = "≍";
  var Atilde$1 = "Ã";
  var atilde$1 = "ã";
  var Auml$1 = "Ä";
  var auml$1 = "ä";
  var awconint = "∳";
  var awint = "⨑";
  var backcong = "≌";
  var backepsilon = "϶";
  var backprime = "‵";
  var backsim = "∽";
  var backsimeq = "⋍";
  var Backslash = "∖";
  var Barv = "⫧";
  var barvee = "⊽";
  var barwed = "⌅";
  var Barwed = "⌆";
  var barwedge = "⌅";
  var bbrk = "⎵";
  var bbrktbrk = "⎶";
  var bcong = "≌";
  var Bcy = "Б";
  var bcy = "б";
  var bdquo = "„";
  var becaus = "∵";
  var because = "∵";
  var Because = "∵";
  var bemptyv = "⦰";
  var bepsi = "϶";
  var bernou = "ℬ";
  var Bernoullis = "ℬ";
  var Beta = "Β";
  var beta = "β";
  var beth = "ℶ";
  var between = "≬";
  var Bfr = "𝔅";
  var bfr = "𝔟";
  var bigcap = "⋂";
  var bigcirc = "◯";
  var bigcup = "⋃";
  var bigodot = "⨀";
  var bigoplus = "⨁";
  var bigotimes = "⨂";
  var bigsqcup = "⨆";
  var bigstar = "★";
  var bigtriangledown = "▽";
  var bigtriangleup = "△";
  var biguplus = "⨄";
  var bigvee = "⋁";
  var bigwedge = "⋀";
  var bkarow = "⤍";
  var blacklozenge = "⧫";
  var blacksquare = "▪";
  var blacktriangle = "▴";
  var blacktriangledown = "▾";
  var blacktriangleleft = "◂";
  var blacktriangleright = "▸";
  var blank = "␣";
  var blk12 = "▒";
  var blk14 = "░";
  var blk34 = "▓";
  var block = "█";
  var bne = "=⃥";
  var bnequiv = "≡⃥";
  var bNot = "⫭";
  var bnot = "⌐";
  var Bopf = "𝔹";
  var bopf = "𝕓";
  var bot = "⊥";
  var bottom = "⊥";
  var bowtie = "⋈";
  var boxbox = "⧉";
  var boxdl = "┐";
  var boxdL = "╕";
  var boxDl = "╖";
  var boxDL = "╗";
  var boxdr = "┌";
  var boxdR = "╒";
  var boxDr = "╓";
  var boxDR = "╔";
  var boxh = "─";
  var boxH = "═";
  var boxhd = "┬";
  var boxHd = "╤";
  var boxhD = "╥";
  var boxHD = "╦";
  var boxhu = "┴";
  var boxHu = "╧";
  var boxhU = "╨";
  var boxHU = "╩";
  var boxminus = "⊟";
  var boxplus = "⊞";
  var boxtimes = "⊠";
  var boxul = "┘";
  var boxuL = "╛";
  var boxUl = "╜";
  var boxUL = "╝";
  var boxur = "└";
  var boxuR = "╘";
  var boxUr = "╙";
  var boxUR = "╚";
  var boxv = "│";
  var boxV = "║";
  var boxvh = "┼";
  var boxvH = "╪";
  var boxVh = "╫";
  var boxVH = "╬";
  var boxvl = "┤";
  var boxvL = "╡";
  var boxVl = "╢";
  var boxVL = "╣";
  var boxvr = "├";
  var boxvR = "╞";
  var boxVr = "╟";
  var boxVR = "╠";
  var bprime = "‵";
  var breve = "˘";
  var Breve = "˘";
  var brvbar$1 = "¦";
  var bscr = "𝒷";
  var Bscr = "ℬ";
  var bsemi = "⁏";
  var bsim = "∽";
  var bsime = "⋍";
  var bsolb = "⧅";
  var bsol = "\\";
  var bsolhsub = "⟈";
  var bull = "•";
  var bullet = "•";
  var bump = "≎";
  var bumpE = "⪮";
  var bumpe = "≏";
  var Bumpeq = "≎";
  var bumpeq = "≏";
  var Cacute = "Ć";
  var cacute = "ć";
  var capand = "⩄";
  var capbrcup = "⩉";
  var capcap = "⩋";
  var cap = "∩";
  var Cap = "⋒";
  var capcup = "⩇";
  var capdot = "⩀";
  var CapitalDifferentialD = "ⅅ";
  var caps = "∩︀";
  var caret = "⁁";
  var caron = "ˇ";
  var Cayleys = "ℭ";
  var ccaps = "⩍";
  var Ccaron = "Č";
  var ccaron = "č";
  var Ccedil$1 = "Ç";
  var ccedil$1 = "ç";
  var Ccirc = "Ĉ";
  var ccirc = "ĉ";
  var Cconint = "∰";
  var ccups = "⩌";
  var ccupssm = "⩐";
  var Cdot = "Ċ";
  var cdot = "ċ";
  var cedil$1 = "¸";
  var Cedilla = "¸";
  var cemptyv = "⦲";
  var cent$1 = "¢";
  var centerdot = "·";
  var CenterDot = "·";
  var cfr = "𝔠";
  var Cfr = "ℭ";
  var CHcy = "Ч";
  var chcy = "ч";
  var check = "✓";
  var checkmark = "✓";
  var Chi = "Χ";
  var chi = "χ";
  var circ = "ˆ";
  var circeq = "≗";
  var circlearrowleft = "↺";
  var circlearrowright = "↻";
  var circledast = "⊛";
  var circledcirc = "⊚";
  var circleddash = "⊝";
  var CircleDot = "⊙";
  var circledR = "®";
  var circledS = "Ⓢ";
  var CircleMinus = "⊖";
  var CirclePlus = "⊕";
  var CircleTimes = "⊗";
  var cir = "○";
  var cirE = "⧃";
  var cire = "≗";
  var cirfnint = "⨐";
  var cirmid = "⫯";
  var cirscir = "⧂";
  var ClockwiseContourIntegral = "∲";
  var CloseCurlyDoubleQuote = "”";
  var CloseCurlyQuote = "’";
  var clubs = "♣";
  var clubsuit = "♣";
  var colon = ":";
  var Colon = "∷";
  var Colone = "⩴";
  var colone = "≔";
  var coloneq = "≔";
  var comma = ",";
  var commat = "@";
  var comp = "∁";
  var compfn = "∘";
  var complement = "∁";
  var complexes = "ℂ";
  var cong = "≅";
  var congdot = "⩭";
  var Congruent = "≡";
  var conint = "∮";
  var Conint = "∯";
  var ContourIntegral = "∮";
  var copf = "𝕔";
  var Copf = "ℂ";
  var coprod = "∐";
  var Coproduct = "∐";
  var copy$1 = "©";
  var COPY$1 = "©";
  var copysr = "℗";
  var CounterClockwiseContourIntegral = "∳";
  var crarr = "↵";
  var cross = "✗";
  var Cross = "⨯";
  var Cscr = "𝒞";
  var cscr = "𝒸";
  var csub = "⫏";
  var csube = "⫑";
  var csup = "⫐";
  var csupe = "⫒";
  var ctdot = "⋯";
  var cudarrl = "⤸";
  var cudarrr = "⤵";
  var cuepr = "⋞";
  var cuesc = "⋟";
  var cularr = "↶";
  var cularrp = "⤽";
  var cupbrcap = "⩈";
  var cupcap = "⩆";
  var CupCap = "≍";
  var cup = "∪";
  var Cup = "⋓";
  var cupcup = "⩊";
  var cupdot = "⊍";
  var cupor = "⩅";
  var cups = "∪︀";
  var curarr = "↷";
  var curarrm = "⤼";
  var curlyeqprec = "⋞";
  var curlyeqsucc = "⋟";
  var curlyvee = "⋎";
  var curlywedge = "⋏";
  var curren$1 = "¤";
  var curvearrowleft = "↶";
  var curvearrowright = "↷";
  var cuvee = "⋎";
  var cuwed = "⋏";
  var cwconint = "∲";
  var cwint = "∱";
  var cylcty = "⌭";
  var dagger = "†";
  var Dagger = "‡";
  var daleth = "ℸ";
  var darr = "↓";
  var Darr = "↡";
  var dArr = "⇓";
  var dash = "‐";
  var Dashv = "⫤";
  var dashv = "⊣";
  var dbkarow = "⤏";
  var dblac = "˝";
  var Dcaron = "Ď";
  var dcaron = "ď";
  var Dcy = "Д";
  var dcy = "д";
  var ddagger = "‡";
  var ddarr = "⇊";
  var DD = "ⅅ";
  var dd = "ⅆ";
  var DDotrahd = "⤑";
  var ddotseq = "⩷";
  var deg$1 = "°";
  var Del = "∇";
  var Delta = "Δ";
  var delta = "δ";
  var demptyv = "⦱";
  var dfisht = "⥿";
  var Dfr = "𝔇";
  var dfr = "𝔡";
  var dHar = "⥥";
  var dharl = "⇃";
  var dharr = "⇂";
  var DiacriticalAcute = "´";
  var DiacriticalDot = "˙";
  var DiacriticalDoubleAcute = "˝";
  var DiacriticalGrave = "`";
  var DiacriticalTilde = "˜";
  var diam = "⋄";
  var diamond = "⋄";
  var Diamond = "⋄";
  var diamondsuit = "♦";
  var diams = "♦";
  var die = "¨";
  var DifferentialD = "ⅆ";
  var digamma = "ϝ";
  var disin = "⋲";
  var div = "÷";
  var divide$1 = "÷";
  var divideontimes = "⋇";
  var divonx = "⋇";
  var DJcy = "Ђ";
  var djcy = "ђ";
  var dlcorn = "⌞";
  var dlcrop = "⌍";
  var dollar = "$";
  var Dopf = "𝔻";
  var dopf = "𝕕";
  var Dot = "¨";
  var dot = "˙";
  var DotDot = "⃜";
  var doteq = "≐";
  var doteqdot = "≑";
  var DotEqual = "≐";
  var dotminus = "∸";
  var dotplus = "∔";
  var dotsquare = "⊡";
  var doublebarwedge = "⌆";
  var DoubleContourIntegral = "∯";
  var DoubleDot = "¨";
  var DoubleDownArrow = "⇓";
  var DoubleLeftArrow = "⇐";
  var DoubleLeftRightArrow = "⇔";
  var DoubleLeftTee = "⫤";
  var DoubleLongLeftArrow = "⟸";
  var DoubleLongLeftRightArrow = "⟺";
  var DoubleLongRightArrow = "⟹";
  var DoubleRightArrow = "⇒";
  var DoubleRightTee = "⊨";
  var DoubleUpArrow = "⇑";
  var DoubleUpDownArrow = "⇕";
  var DoubleVerticalBar = "∥";
  var DownArrowBar = "⤓";
  var downarrow = "↓";
  var DownArrow = "↓";
  var Downarrow = "⇓";
  var DownArrowUpArrow = "⇵";
  var DownBreve = "̑";
  var downdownarrows = "⇊";
  var downharpoonleft = "⇃";
  var downharpoonright = "⇂";
  var DownLeftRightVector = "⥐";
  var DownLeftTeeVector = "⥞";
  var DownLeftVectorBar = "⥖";
  var DownLeftVector = "↽";
  var DownRightTeeVector = "⥟";
  var DownRightVectorBar = "⥗";
  var DownRightVector = "⇁";
  var DownTeeArrow = "↧";
  var DownTee = "⊤";
  var drbkarow = "⤐";
  var drcorn = "⌟";
  var drcrop = "⌌";
  var Dscr = "𝒟";
  var dscr = "𝒹";
  var DScy = "Ѕ";
  var dscy = "ѕ";
  var dsol = "⧶";
  var Dstrok = "Đ";
  var dstrok = "đ";
  var dtdot = "⋱";
  var dtri = "▿";
  var dtrif = "▾";
  var duarr = "⇵";
  var duhar = "⥯";
  var dwangle = "⦦";
  var DZcy = "Џ";
  var dzcy = "џ";
  var dzigrarr = "⟿";
  var Eacute$1 = "É";
  var eacute$1 = "é";
  var easter = "⩮";
  var Ecaron = "Ě";
  var ecaron = "ě";
  var Ecirc$1 = "Ê";
  var ecirc$1 = "ê";
  var ecir = "≖";
  var ecolon = "≕";
  var Ecy = "Э";
  var ecy = "э";
  var eDDot = "⩷";
  var Edot = "Ė";
  var edot = "ė";
  var eDot = "≑";
  var ee = "ⅇ";
  var efDot = "≒";
  var Efr = "𝔈";
  var efr = "𝔢";
  var eg = "⪚";
  var Egrave$1 = "È";
  var egrave$1 = "è";
  var egs = "⪖";
  var egsdot = "⪘";
  var el = "⪙";
  var Element = "∈";
  var elinters = "⏧";
  var ell = "ℓ";
  var els = "⪕";
  var elsdot = "⪗";
  var Emacr = "Ē";
  var emacr = "ē";
  var empty = "∅";
  var emptyset = "∅";
  var EmptySmallSquare = "◻";
  var emptyv = "∅";
  var EmptyVerySmallSquare = "▫";
  var emsp13 = " ";
  var emsp14 = " ";
  var emsp = " ";
  var ENG = "Ŋ";
  var eng = "ŋ";
  var ensp = " ";
  var Eogon = "Ę";
  var eogon = "ę";
  var Eopf = "𝔼";
  var eopf = "𝕖";
  var epar = "⋕";
  var eparsl = "⧣";
  var eplus = "⩱";
  var epsi = "ε";
  var Epsilon = "Ε";
  var epsilon = "ε";
  var epsiv = "ϵ";
  var eqcirc = "≖";
  var eqcolon = "≕";
  var eqsim = "≂";
  var eqslantgtr = "⪖";
  var eqslantless = "⪕";
  var Equal = "⩵";
  var equals = "=";
  var EqualTilde = "≂";
  var equest = "≟";
  var Equilibrium = "⇌";
  var equiv = "≡";
  var equivDD = "⩸";
  var eqvparsl = "⧥";
  var erarr = "⥱";
  var erDot = "≓";
  var escr = "ℯ";
  var Escr = "ℰ";
  var esdot = "≐";
  var Esim = "⩳";
  var esim = "≂";
  var Eta = "Η";
  var eta = "η";
  var ETH$1 = "Ð";
  var eth$1 = "ð";
  var Euml$1 = "Ë";
  var euml$1 = "ë";
  var euro = "€";
  var excl = "!";
  var exist = "∃";
  var Exists = "∃";
  var expectation = "ℰ";
  var exponentiale = "ⅇ";
  var ExponentialE = "ⅇ";
  var fallingdotseq = "≒";
  var Fcy = "Ф";
  var fcy = "ф";
  var female = "♀";
  var ffilig = "ﬃ";
  var fflig = "ﬀ";
  var ffllig = "ﬄ";
  var Ffr = "𝔉";
  var ffr = "𝔣";
  var filig = "ﬁ";
  var FilledSmallSquare = "◼";
  var FilledVerySmallSquare = "▪";
  var fjlig = "fj";
  var flat = "♭";
  var fllig = "ﬂ";
  var fltns = "▱";
  var fnof = "ƒ";
  var Fopf = "𝔽";
  var fopf = "𝕗";
  var forall = "∀";
  var ForAll = "∀";
  var fork = "⋔";
  var forkv = "⫙";
  var Fouriertrf = "ℱ";
  var fpartint = "⨍";
  var frac12$1 = "½";
  var frac13 = "⅓";
  var frac14$1 = "¼";
  var frac15 = "⅕";
  var frac16 = "⅙";
  var frac18 = "⅛";
  var frac23 = "⅔";
  var frac25 = "⅖";
  var frac34$1 = "¾";
  var frac35 = "⅗";
  var frac38 = "⅜";
  var frac45 = "⅘";
  var frac56 = "⅚";
  var frac58 = "⅝";
  var frac78 = "⅞";
  var frasl = "⁄";
  var frown = "⌢";
  var fscr = "𝒻";
  var Fscr = "ℱ";
  var gacute = "ǵ";
  var Gamma = "Γ";
  var gamma = "γ";
  var Gammad = "Ϝ";
  var gammad = "ϝ";
  var gap = "⪆";
  var Gbreve = "Ğ";
  var gbreve = "ğ";
  var Gcedil = "Ģ";
  var Gcirc = "Ĝ";
  var gcirc = "ĝ";
  var Gcy = "Г";
  var gcy = "г";
  var Gdot = "Ġ";
  var gdot = "ġ";
  var ge = "≥";
  var gE = "≧";
  var gEl = "⪌";
  var gel = "⋛";
  var geq = "≥";
  var geqq = "≧";
  var geqslant = "⩾";
  var gescc = "⪩";
  var ges = "⩾";
  var gesdot = "⪀";
  var gesdoto = "⪂";
  var gesdotol = "⪄";
  var gesl = "⋛︀";
  var gesles = "⪔";
  var Gfr = "𝔊";
  var gfr = "𝔤";
  var gg = "≫";
  var Gg = "⋙";
  var ggg = "⋙";
  var gimel = "ℷ";
  var GJcy = "Ѓ";
  var gjcy = "ѓ";
  var gla = "⪥";
  var gl = "≷";
  var glE = "⪒";
  var glj = "⪤";
  var gnap = "⪊";
  var gnapprox = "⪊";
  var gne = "⪈";
  var gnE = "≩";
  var gneq = "⪈";
  var gneqq = "≩";
  var gnsim = "⋧";
  var Gopf = "𝔾";
  var gopf = "𝕘";
  var grave = "`";
  var GreaterEqual = "≥";
  var GreaterEqualLess = "⋛";
  var GreaterFullEqual = "≧";
  var GreaterGreater = "⪢";
  var GreaterLess = "≷";
  var GreaterSlantEqual = "⩾";
  var GreaterTilde = "≳";
  var Gscr = "𝒢";
  var gscr = "ℊ";
  var gsim = "≳";
  var gsime = "⪎";
  var gsiml = "⪐";
  var gtcc = "⪧";
  var gtcir = "⩺";
  var gt$2 = ">";
  var GT$1 = ">";
  var Gt = "≫";
  var gtdot = "⋗";
  var gtlPar = "⦕";
  var gtquest = "⩼";
  var gtrapprox = "⪆";
  var gtrarr = "⥸";
  var gtrdot = "⋗";
  var gtreqless = "⋛";
  var gtreqqless = "⪌";
  var gtrless = "≷";
  var gtrsim = "≳";
  var gvertneqq = "≩︀";
  var gvnE = "≩︀";
  var Hacek = "ˇ";
  var hairsp = " ";
  var half = "½";
  var hamilt = "ℋ";
  var HARDcy = "Ъ";
  var hardcy = "ъ";
  var harrcir = "⥈";
  var harr = "↔";
  var hArr = "⇔";
  var harrw = "↭";
  var Hat = "^";
  var hbar = "ℏ";
  var Hcirc = "Ĥ";
  var hcirc = "ĥ";
  var hearts = "♥";
  var heartsuit = "♥";
  var hellip = "…";
  var hercon = "⊹";
  var hfr = "𝔥";
  var Hfr = "ℌ";
  var HilbertSpace = "ℋ";
  var hksearow = "⤥";
  var hkswarow = "⤦";
  var hoarr = "⇿";
  var homtht = "∻";
  var hookleftarrow = "↩";
  var hookrightarrow = "↪";
  var hopf = "𝕙";
  var Hopf = "ℍ";
  var horbar = "―";
  var HorizontalLine = "─";
  var hscr = "𝒽";
  var Hscr = "ℋ";
  var hslash = "ℏ";
  var Hstrok = "Ħ";
  var hstrok = "ħ";
  var HumpDownHump = "≎";
  var HumpEqual = "≏";
  var hybull = "⁃";
  var hyphen = "‐";
  var Iacute$1 = "Í";
  var iacute$1 = "í";
  var ic = "⁣";
  var Icirc$1 = "Î";
  var icirc$1 = "î";
  var Icy = "И";
  var icy = "и";
  var Idot = "İ";
  var IEcy = "Е";
  var iecy = "е";
  var iexcl$1 = "¡";
  var iff = "⇔";
  var ifr = "𝔦";
  var Ifr = "ℑ";
  var Igrave$1 = "Ì";
  var igrave$1 = "ì";
  var ii = "ⅈ";
  var iiiint = "⨌";
  var iiint = "∭";
  var iinfin = "⧜";
  var iiota = "℩";
  var IJlig = "Ĳ";
  var ijlig = "ĳ";
  var Imacr = "Ī";
  var imacr = "ī";
  var image = "ℑ";
  var ImaginaryI = "ⅈ";
  var imagline = "ℐ";
  var imagpart = "ℑ";
  var imath = "ı";
  var Im = "ℑ";
  var imof = "⊷";
  var imped = "Ƶ";
  var Implies = "⇒";
  var incare = "℅";
  var infin = "∞";
  var infintie = "⧝";
  var inodot = "ı";
  var intcal = "⊺";
  var int = "∫";
  var Int = "∬";
  var integers = "ℤ";
  var Integral = "∫";
  var intercal = "⊺";
  var Intersection = "⋂";
  var intlarhk = "⨗";
  var intprod = "⨼";
  var InvisibleComma = "⁣";
  var InvisibleTimes = "⁢";
  var IOcy = "Ё";
  var iocy = "ё";
  var Iogon = "Į";
  var iogon = "į";
  var Iopf = "𝕀";
  var iopf = "𝕚";
  var Iota = "Ι";
  var iota = "ι";
  var iprod = "⨼";
  var iquest$1 = "¿";
  var iscr = "𝒾";
  var Iscr = "ℐ";
  var isin = "∈";
  var isindot = "⋵";
  var isinE = "⋹";
  var isins = "⋴";
  var isinsv = "⋳";
  var isinv = "∈";
  var it = "⁢";
  var Itilde = "Ĩ";
  var itilde = "ĩ";
  var Iukcy = "І";
  var iukcy = "і";
  var Iuml$1 = "Ï";
  var iuml$1 = "ï";
  var Jcirc = "Ĵ";
  var jcirc = "ĵ";
  var Jcy = "Й";
  var jcy = "й";
  var Jfr = "𝔍";
  var jfr = "𝔧";
  var jmath = "ȷ";
  var Jopf = "𝕁";
  var jopf = "𝕛";
  var Jscr = "𝒥";
  var jscr = "𝒿";
  var Jsercy = "Ј";
  var jsercy = "ј";
  var Jukcy = "Є";
  var jukcy = "є";
  var Kappa = "Κ";
  var kappa = "κ";
  var kappav = "ϰ";
  var Kcedil = "Ķ";
  var kcedil = "ķ";
  var Kcy = "К";
  var kcy = "к";
  var Kfr = "𝔎";
  var kfr = "𝔨";
  var kgreen = "ĸ";
  var KHcy = "Х";
  var khcy = "х";
  var KJcy = "Ќ";
  var kjcy = "ќ";
  var Kopf = "𝕂";
  var kopf = "𝕜";
  var Kscr = "𝒦";
  var kscr = "𝓀";
  var lAarr = "⇚";
  var Lacute = "Ĺ";
  var lacute = "ĺ";
  var laemptyv = "⦴";
  var lagran = "ℒ";
  var Lambda = "Λ";
  var lambda = "λ";
  var lang = "⟨";
  var Lang = "⟪";
  var langd = "⦑";
  var langle = "⟨";
  var lap = "⪅";
  var Laplacetrf = "ℒ";
  var laquo$1 = "«";
  var larrb = "⇤";
  var larrbfs = "⤟";
  var larr = "←";
  var Larr = "↞";
  var lArr = "⇐";
  var larrfs = "⤝";
  var larrhk = "↩";
  var larrlp = "↫";
  var larrpl = "⤹";
  var larrsim = "⥳";
  var larrtl = "↢";
  var latail = "⤙";
  var lAtail = "⤛";
  var lat = "⪫";
  var late = "⪭";
  var lates = "⪭︀";
  var lbarr = "⤌";
  var lBarr = "⤎";
  var lbbrk = "❲";
  var lbrace = "{";
  var lbrack = "[";
  var lbrke = "⦋";
  var lbrksld = "⦏";
  var lbrkslu = "⦍";
  var Lcaron = "Ľ";
  var lcaron = "ľ";
  var Lcedil = "Ļ";
  var lcedil = "ļ";
  var lceil = "⌈";
  var lcub = "{";
  var Lcy = "Л";
  var lcy = "л";
  var ldca = "⤶";
  var ldquo = "“";
  var ldquor = "„";
  var ldrdhar = "⥧";
  var ldrushar = "⥋";
  var ldsh = "↲";
  var le = "≤";
  var lE = "≦";
  var LeftAngleBracket = "⟨";
  var LeftArrowBar = "⇤";
  var leftarrow = "←";
  var LeftArrow = "←";
  var Leftarrow = "⇐";
  var LeftArrowRightArrow = "⇆";
  var leftarrowtail = "↢";
  var LeftCeiling = "⌈";
  var LeftDoubleBracket = "⟦";
  var LeftDownTeeVector = "⥡";
  var LeftDownVectorBar = "⥙";
  var LeftDownVector = "⇃";
  var LeftFloor = "⌊";
  var leftharpoondown = "↽";
  var leftharpoonup = "↼";
  var leftleftarrows = "⇇";
  var leftrightarrow = "↔";
  var LeftRightArrow = "↔";
  var Leftrightarrow = "⇔";
  var leftrightarrows = "⇆";
  var leftrightharpoons = "⇋";
  var leftrightsquigarrow = "↭";
  var LeftRightVector = "⥎";
  var LeftTeeArrow = "↤";
  var LeftTee = "⊣";
  var LeftTeeVector = "⥚";
  var leftthreetimes = "⋋";
  var LeftTriangleBar = "⧏";
  var LeftTriangle = "⊲";
  var LeftTriangleEqual = "⊴";
  var LeftUpDownVector = "⥑";
  var LeftUpTeeVector = "⥠";
  var LeftUpVectorBar = "⥘";
  var LeftUpVector = "↿";
  var LeftVectorBar = "⥒";
  var LeftVector = "↼";
  var lEg = "⪋";
  var leg = "⋚";
  var leq = "≤";
  var leqq = "≦";
  var leqslant = "⩽";
  var lescc = "⪨";
  var les = "⩽";
  var lesdot = "⩿";
  var lesdoto = "⪁";
  var lesdotor = "⪃";
  var lesg = "⋚︀";
  var lesges = "⪓";
  var lessapprox = "⪅";
  var lessdot = "⋖";
  var lesseqgtr = "⋚";
  var lesseqqgtr = "⪋";
  var LessEqualGreater = "⋚";
  var LessFullEqual = "≦";
  var LessGreater = "≶";
  var lessgtr = "≶";
  var LessLess = "⪡";
  var lesssim = "≲";
  var LessSlantEqual = "⩽";
  var LessTilde = "≲";
  var lfisht = "⥼";
  var lfloor = "⌊";
  var Lfr = "𝔏";
  var lfr = "𝔩";
  var lg = "≶";
  var lgE = "⪑";
  var lHar = "⥢";
  var lhard = "↽";
  var lharu = "↼";
  var lharul = "⥪";
  var lhblk = "▄";
  var LJcy = "Љ";
  var ljcy = "љ";
  var llarr = "⇇";
  var ll = "≪";
  var Ll = "⋘";
  var llcorner = "⌞";
  var Lleftarrow = "⇚";
  var llhard = "⥫";
  var lltri = "◺";
  var Lmidot = "Ŀ";
  var lmidot = "ŀ";
  var lmoustache = "⎰";
  var lmoust = "⎰";
  var lnap = "⪉";
  var lnapprox = "⪉";
  var lne = "⪇";
  var lnE = "≨";
  var lneq = "⪇";
  var lneqq = "≨";
  var lnsim = "⋦";
  var loang = "⟬";
  var loarr = "⇽";
  var lobrk = "⟦";
  var longleftarrow = "⟵";
  var LongLeftArrow = "⟵";
  var Longleftarrow = "⟸";
  var longleftrightarrow = "⟷";
  var LongLeftRightArrow = "⟷";
  var Longleftrightarrow = "⟺";
  var longmapsto = "⟼";
  var longrightarrow = "⟶";
  var LongRightArrow = "⟶";
  var Longrightarrow = "⟹";
  var looparrowleft = "↫";
  var looparrowright = "↬";
  var lopar = "⦅";
  var Lopf = "𝕃";
  var lopf = "𝕝";
  var loplus = "⨭";
  var lotimes = "⨴";
  var lowast = "∗";
  var lowbar = "_";
  var LowerLeftArrow = "↙";
  var LowerRightArrow = "↘";
  var loz = "◊";
  var lozenge = "◊";
  var lozf = "⧫";
  var lpar = "(";
  var lparlt = "⦓";
  var lrarr = "⇆";
  var lrcorner = "⌟";
  var lrhar = "⇋";
  var lrhard = "⥭";
  var lrm = "‎";
  var lrtri = "⊿";
  var lsaquo = "‹";
  var lscr = "𝓁";
  var Lscr = "ℒ";
  var lsh = "↰";
  var Lsh = "↰";
  var lsim = "≲";
  var lsime = "⪍";
  var lsimg = "⪏";
  var lsqb = "[";
  var lsquo = "‘";
  var lsquor = "‚";
  var Lstrok = "Ł";
  var lstrok = "ł";
  var ltcc = "⪦";
  var ltcir = "⩹";
  var lt$2 = "<";
  var LT$1 = "<";
  var Lt = "≪";
  var ltdot = "⋖";
  var lthree = "⋋";
  var ltimes = "⋉";
  var ltlarr = "⥶";
  var ltquest = "⩻";
  var ltri = "◃";
  var ltrie = "⊴";
  var ltrif = "◂";
  var ltrPar = "⦖";
  var lurdshar = "⥊";
  var luruhar = "⥦";
  var lvertneqq = "≨︀";
  var lvnE = "≨︀";
  var macr$1 = "¯";
  var male = "♂";
  var malt = "✠";
  var maltese = "✠";
  var map = "↦";
  var mapsto = "↦";
  var mapstodown = "↧";
  var mapstoleft = "↤";
  var mapstoup = "↥";
  var marker = "▮";
  var mcomma = "⨩";
  var Mcy = "М";
  var mcy = "м";
  var mdash = "—";
  var mDDot = "∺";
  var measuredangle = "∡";
  var MediumSpace = " ";
  var Mellintrf = "ℳ";
  var Mfr = "𝔐";
  var mfr = "𝔪";
  var mho = "℧";
  var micro$1 = "µ";
  var midast = "*";
  var midcir = "⫰";
  var mid = "∣";
  var middot$1 = "·";
  var minusb = "⊟";
  var minus = "−";
  var minusd = "∸";
  var minusdu = "⨪";
  var MinusPlus = "∓";
  var mlcp = "⫛";
  var mldr = "…";
  var mnplus = "∓";
  var models = "⊧";
  var Mopf = "𝕄";
  var mopf = "𝕞";
  var mp = "∓";
  var mscr = "𝓂";
  var Mscr = "ℳ";
  var mstpos = "∾";
  var Mu = "Μ";
  var mu = "μ";
  var multimap = "⊸";
  var mumap = "⊸";
  var nabla = "∇";
  var Nacute = "Ń";
  var nacute = "ń";
  var nang = "∠⃒";
  var nap = "≉";
  var napE = "⩰̸";
  var napid = "≋̸";
  var napos = "ŉ";
  var napprox = "≉";
  var natural = "♮";
  var naturals = "ℕ";
  var natur = "♮";
  var nbsp$1 = " ";
  var nbump = "≎̸";
  var nbumpe = "≏̸";
  var ncap = "⩃";
  var Ncaron = "Ň";
  var ncaron = "ň";
  var Ncedil = "Ņ";
  var ncedil = "ņ";
  var ncong = "≇";
  var ncongdot = "⩭̸";
  var ncup = "⩂";
  var Ncy = "Н";
  var ncy = "н";
  var ndash = "–";
  var nearhk = "⤤";
  var nearr = "↗";
  var neArr = "⇗";
  var nearrow = "↗";
  var ne = "≠";
  var nedot = "≐̸";
  var NegativeMediumSpace = "​";
  var NegativeThickSpace = "​";
  var NegativeThinSpace = "​";
  var NegativeVeryThinSpace = "​";
  var nequiv = "≢";
  var nesear = "⤨";
  var nesim = "≂̸";
  var NestedGreaterGreater = "≫";
  var NestedLessLess = "≪";
  var NewLine = "\n";
  var nexist = "∄";
  var nexists = "∄";
  var Nfr = "𝔑";
  var nfr = "𝔫";
  var ngE = "≧̸";
  var nge = "≱";
  var ngeq = "≱";
  var ngeqq = "≧̸";
  var ngeqslant = "⩾̸";
  var nges = "⩾̸";
  var nGg = "⋙̸";
  var ngsim = "≵";
  var nGt = "≫⃒";
  var ngt = "≯";
  var ngtr = "≯";
  var nGtv = "≫̸";
  var nharr = "↮";
  var nhArr = "⇎";
  var nhpar = "⫲";
  var ni = "∋";
  var nis = "⋼";
  var nisd = "⋺";
  var niv = "∋";
  var NJcy = "Њ";
  var njcy = "њ";
  var nlarr = "↚";
  var nlArr = "⇍";
  var nldr = "‥";
  var nlE = "≦̸";
  var nle = "≰";
  var nleftarrow = "↚";
  var nLeftarrow = "⇍";
  var nleftrightarrow = "↮";
  var nLeftrightarrow = "⇎";
  var nleq = "≰";
  var nleqq = "≦̸";
  var nleqslant = "⩽̸";
  var nles = "⩽̸";
  var nless = "≮";
  var nLl = "⋘̸";
  var nlsim = "≴";
  var nLt = "≪⃒";
  var nlt = "≮";
  var nltri = "⋪";
  var nltrie = "⋬";
  var nLtv = "≪̸";
  var nmid = "∤";
  var NoBreak = "⁠";
  var NonBreakingSpace = " ";
  var nopf = "𝕟";
  var Nopf = "ℕ";
  var Not = "⫬";
  var not$1 = "¬";
  var NotCongruent = "≢";
  var NotCupCap = "≭";
  var NotDoubleVerticalBar = "∦";
  var NotElement = "∉";
  var NotEqual = "≠";
  var NotEqualTilde = "≂̸";
  var NotExists = "∄";
  var NotGreater = "≯";
  var NotGreaterEqual = "≱";
  var NotGreaterFullEqual = "≧̸";
  var NotGreaterGreater = "≫̸";
  var NotGreaterLess = "≹";
  var NotGreaterSlantEqual = "⩾̸";
  var NotGreaterTilde = "≵";
  var NotHumpDownHump = "≎̸";
  var NotHumpEqual = "≏̸";
  var notin = "∉";
  var notindot = "⋵̸";
  var notinE = "⋹̸";
  var notinva = "∉";
  var notinvb = "⋷";
  var notinvc = "⋶";
  var NotLeftTriangleBar = "⧏̸";
  var NotLeftTriangle = "⋪";
  var NotLeftTriangleEqual = "⋬";
  var NotLess = "≮";
  var NotLessEqual = "≰";
  var NotLessGreater = "≸";
  var NotLessLess = "≪̸";
  var NotLessSlantEqual = "⩽̸";
  var NotLessTilde = "≴";
  var NotNestedGreaterGreater = "⪢̸";
  var NotNestedLessLess = "⪡̸";
  var notni = "∌";
  var notniva = "∌";
  var notnivb = "⋾";
  var notnivc = "⋽";
  var NotPrecedes = "⊀";
  var NotPrecedesEqual = "⪯̸";
  var NotPrecedesSlantEqual = "⋠";
  var NotReverseElement = "∌";
  var NotRightTriangleBar = "⧐̸";
  var NotRightTriangle = "⋫";
  var NotRightTriangleEqual = "⋭";
  var NotSquareSubset = "⊏̸";
  var NotSquareSubsetEqual = "⋢";
  var NotSquareSuperset = "⊐̸";
  var NotSquareSupersetEqual = "⋣";
  var NotSubset = "⊂⃒";
  var NotSubsetEqual = "⊈";
  var NotSucceeds = "⊁";
  var NotSucceedsEqual = "⪰̸";
  var NotSucceedsSlantEqual = "⋡";
  var NotSucceedsTilde = "≿̸";
  var NotSuperset = "⊃⃒";
  var NotSupersetEqual = "⊉";
  var NotTilde = "≁";
  var NotTildeEqual = "≄";
  var NotTildeFullEqual = "≇";
  var NotTildeTilde = "≉";
  var NotVerticalBar = "∤";
  var nparallel = "∦";
  var npar = "∦";
  var nparsl = "⫽⃥";
  var npart = "∂̸";
  var npolint = "⨔";
  var npr = "⊀";
  var nprcue = "⋠";
  var nprec = "⊀";
  var npreceq = "⪯̸";
  var npre = "⪯̸";
  var nrarrc = "⤳̸";
  var nrarr = "↛";
  var nrArr = "⇏";
  var nrarrw = "↝̸";
  var nrightarrow = "↛";
  var nRightarrow = "⇏";
  var nrtri = "⋫";
  var nrtrie = "⋭";
  var nsc = "⊁";
  var nsccue = "⋡";
  var nsce = "⪰̸";
  var Nscr = "𝒩";
  var nscr = "𝓃";
  var nshortmid = "∤";
  var nshortparallel = "∦";
  var nsim = "≁";
  var nsime = "≄";
  var nsimeq = "≄";
  var nsmid = "∤";
  var nspar = "∦";
  var nsqsube = "⋢";
  var nsqsupe = "⋣";
  var nsub = "⊄";
  var nsubE = "⫅̸";
  var nsube = "⊈";
  var nsubset = "⊂⃒";
  var nsubseteq = "⊈";
  var nsubseteqq = "⫅̸";
  var nsucc = "⊁";
  var nsucceq = "⪰̸";
  var nsup = "⊅";
  var nsupE = "⫆̸";
  var nsupe = "⊉";
  var nsupset = "⊃⃒";
  var nsupseteq = "⊉";
  var nsupseteqq = "⫆̸";
  var ntgl = "≹";
  var Ntilde$1 = "Ñ";
  var ntilde$1 = "ñ";
  var ntlg = "≸";
  var ntriangleleft = "⋪";
  var ntrianglelefteq = "⋬";
  var ntriangleright = "⋫";
  var ntrianglerighteq = "⋭";
  var Nu = "Ν";
  var nu = "ν";
  var num = "#";
  var numero = "№";
  var numsp = " ";
  var nvap = "≍⃒";
  var nvdash = "⊬";
  var nvDash = "⊭";
  var nVdash = "⊮";
  var nVDash = "⊯";
  var nvge = "≥⃒";
  var nvgt = ">⃒";
  var nvHarr = "⤄";
  var nvinfin = "⧞";
  var nvlArr = "⤂";
  var nvle = "≤⃒";
  var nvlt = "<⃒";
  var nvltrie = "⊴⃒";
  var nvrArr = "⤃";
  var nvrtrie = "⊵⃒";
  var nvsim = "∼⃒";
  var nwarhk = "⤣";
  var nwarr = "↖";
  var nwArr = "⇖";
  var nwarrow = "↖";
  var nwnear = "⤧";
  var Oacute$1 = "Ó";
  var oacute$1 = "ó";
  var oast = "⊛";
  var Ocirc$1 = "Ô";
  var ocirc$1 = "ô";
  var ocir = "⊚";
  var Ocy = "О";
  var ocy = "о";
  var odash = "⊝";
  var Odblac = "Ő";
  var odblac = "ő";
  var odiv = "⨸";
  var odot = "⊙";
  var odsold = "⦼";
  var OElig = "Œ";
  var oelig = "œ";
  var ofcir = "⦿";
  var Ofr = "𝔒";
  var ofr = "𝔬";
  var ogon = "˛";
  var Ograve$1 = "Ò";
  var ograve$1 = "ò";
  var ogt = "⧁";
  var ohbar = "⦵";
  var ohm = "Ω";
  var oint = "∮";
  var olarr = "↺";
  var olcir = "⦾";
  var olcross = "⦻";
  var oline = "‾";
  var olt = "⧀";
  var Omacr = "Ō";
  var omacr = "ō";
  var Omega = "Ω";
  var omega = "ω";
  var Omicron = "Ο";
  var omicron = "ο";
  var omid = "⦶";
  var ominus = "⊖";
  var Oopf = "𝕆";
  var oopf = "𝕠";
  var opar = "⦷";
  var OpenCurlyDoubleQuote = "“";
  var OpenCurlyQuote = "‘";
  var operp = "⦹";
  var oplus = "⊕";
  var orarr = "↻";
  var Or = "⩔";
  var or = "∨";
  var ord = "⩝";
  var order = "ℴ";
  var orderof = "ℴ";
  var ordf$1 = "ª";
  var ordm$1 = "º";
  var origof = "⊶";
  var oror = "⩖";
  var orslope = "⩗";
  var orv = "⩛";
  var oS = "Ⓢ";
  var Oscr = "𝒪";
  var oscr = "ℴ";
  var Oslash$1 = "Ø";
  var oslash$1 = "ø";
  var osol = "⊘";
  var Otilde$1 = "Õ";
  var otilde$1 = "õ";
  var otimesas = "⨶";
  var Otimes = "⨷";
  var otimes = "⊗";
  var Ouml$1 = "Ö";
  var ouml$1 = "ö";
  var ovbar = "⌽";
  var OverBar = "‾";
  var OverBrace = "⏞";
  var OverBracket = "⎴";
  var OverParenthesis = "⏜";
  var para$1 = "¶";
  var parallel = "∥";
  var par = "∥";
  var parsim = "⫳";
  var parsl = "⫽";
  var part = "∂";
  var PartialD = "∂";
  var Pcy = "П";
  var pcy = "п";
  var percnt = "%";
  var period = ".";
  var permil = "‰";
  var perp = "⊥";
  var pertenk = "‱";
  var Pfr = "𝔓";
  var pfr = "𝔭";
  var Phi = "Φ";
  var phi = "φ";
  var phiv = "ϕ";
  var phmmat = "ℳ";
  var phone = "☎";
  var Pi = "Π";
  var pi = "π";
  var pitchfork = "⋔";
  var piv = "ϖ";
  var planck = "ℏ";
  var planckh = "ℎ";
  var plankv = "ℏ";
  var plusacir = "⨣";
  var plusb = "⊞";
  var pluscir = "⨢";
  var plus = "+";
  var plusdo = "∔";
  var plusdu = "⨥";
  var pluse = "⩲";
  var PlusMinus = "±";
  var plusmn$1 = "±";
  var plussim = "⨦";
  var plustwo = "⨧";
  var pm = "±";
  var Poincareplane = "ℌ";
  var pointint = "⨕";
  var popf = "𝕡";
  var Popf = "ℙ";
  var pound$1 = "£";
  var prap = "⪷";
  var Pr = "⪻";
  var pr = "≺";
  var prcue = "≼";
  var precapprox = "⪷";
  var prec = "≺";
  var preccurlyeq = "≼";
  var Precedes = "≺";
  var PrecedesEqual = "⪯";
  var PrecedesSlantEqual = "≼";
  var PrecedesTilde = "≾";
  var preceq = "⪯";
  var precnapprox = "⪹";
  var precneqq = "⪵";
  var precnsim = "⋨";
  var pre = "⪯";
  var prE = "⪳";
  var precsim = "≾";
  var prime = "′";
  var Prime = "″";
  var primes = "ℙ";
  var prnap = "⪹";
  var prnE = "⪵";
  var prnsim = "⋨";
  var prod = "∏";
  var Product = "∏";
  var profalar = "⌮";
  var profline = "⌒";
  var profsurf = "⌓";
  var prop = "∝";
  var Proportional = "∝";
  var Proportion = "∷";
  var propto = "∝";
  var prsim = "≾";
  var prurel = "⊰";
  var Pscr = "𝒫";
  var pscr = "𝓅";
  var Psi = "Ψ";
  var psi = "ψ";
  var puncsp = " ";
  var Qfr = "𝔔";
  var qfr = "𝔮";
  var qint = "⨌";
  var qopf = "𝕢";
  var Qopf = "ℚ";
  var qprime = "⁗";
  var Qscr = "𝒬";
  var qscr = "𝓆";
  var quaternions = "ℍ";
  var quatint = "⨖";
  var quest = "?";
  var questeq = "≟";
  var quot$2 = "\"";
  var QUOT$1 = "\"";
  var rAarr = "⇛";
  var race = "∽̱";
  var Racute = "Ŕ";
  var racute = "ŕ";
  var radic = "√";
  var raemptyv = "⦳";
  var rang = "⟩";
  var Rang = "⟫";
  var rangd = "⦒";
  var range = "⦥";
  var rangle = "⟩";
  var raquo$1 = "»";
  var rarrap = "⥵";
  var rarrb = "⇥";
  var rarrbfs = "⤠";
  var rarrc = "⤳";
  var rarr = "→";
  var Rarr = "↠";
  var rArr = "⇒";
  var rarrfs = "⤞";
  var rarrhk = "↪";
  var rarrlp = "↬";
  var rarrpl = "⥅";
  var rarrsim = "⥴";
  var Rarrtl = "⤖";
  var rarrtl = "↣";
  var rarrw = "↝";
  var ratail = "⤚";
  var rAtail = "⤜";
  var ratio = "∶";
  var rationals = "ℚ";
  var rbarr = "⤍";
  var rBarr = "⤏";
  var RBarr = "⤐";
  var rbbrk = "❳";
  var rbrace = "}";
  var rbrack = "]";
  var rbrke = "⦌";
  var rbrksld = "⦎";
  var rbrkslu = "⦐";
  var Rcaron = "Ř";
  var rcaron = "ř";
  var Rcedil = "Ŗ";
  var rcedil = "ŗ";
  var rceil = "⌉";
  var rcub = "}";
  var Rcy = "Р";
  var rcy = "р";
  var rdca = "⤷";
  var rdldhar = "⥩";
  var rdquo = "”";
  var rdquor = "”";
  var rdsh = "↳";
  var real = "ℜ";
  var realine = "ℛ";
  var realpart = "ℜ";
  var reals = "ℝ";
  var Re = "ℜ";
  var rect = "▭";
  var reg$1 = "®";
  var REG$1 = "®";
  var ReverseElement = "∋";
  var ReverseEquilibrium = "⇋";
  var ReverseUpEquilibrium = "⥯";
  var rfisht = "⥽";
  var rfloor = "⌋";
  var rfr = "𝔯";
  var Rfr = "ℜ";
  var rHar = "⥤";
  var rhard = "⇁";
  var rharu = "⇀";
  var rharul = "⥬";
  var Rho = "Ρ";
  var rho = "ρ";
  var rhov = "ϱ";
  var RightAngleBracket = "⟩";
  var RightArrowBar = "⇥";
  var rightarrow = "→";
  var RightArrow = "→";
  var Rightarrow = "⇒";
  var RightArrowLeftArrow = "⇄";
  var rightarrowtail = "↣";
  var RightCeiling = "⌉";
  var RightDoubleBracket = "⟧";
  var RightDownTeeVector = "⥝";
  var RightDownVectorBar = "⥕";
  var RightDownVector = "⇂";
  var RightFloor = "⌋";
  var rightharpoondown = "⇁";
  var rightharpoonup = "⇀";
  var rightleftarrows = "⇄";
  var rightleftharpoons = "⇌";
  var rightrightarrows = "⇉";
  var rightsquigarrow = "↝";
  var RightTeeArrow = "↦";
  var RightTee = "⊢";
  var RightTeeVector = "⥛";
  var rightthreetimes = "⋌";
  var RightTriangleBar = "⧐";
  var RightTriangle = "⊳";
  var RightTriangleEqual = "⊵";
  var RightUpDownVector = "⥏";
  var RightUpTeeVector = "⥜";
  var RightUpVectorBar = "⥔";
  var RightUpVector = "↾";
  var RightVectorBar = "⥓";
  var RightVector = "⇀";
  var ring = "˚";
  var risingdotseq = "≓";
  var rlarr = "⇄";
  var rlhar = "⇌";
  var rlm = "‏";
  var rmoustache = "⎱";
  var rmoust = "⎱";
  var rnmid = "⫮";
  var roang = "⟭";
  var roarr = "⇾";
  var robrk = "⟧";
  var ropar = "⦆";
  var ropf = "𝕣";
  var Ropf = "ℝ";
  var roplus = "⨮";
  var rotimes = "⨵";
  var RoundImplies = "⥰";
  var rpar = ")";
  var rpargt = "⦔";
  var rppolint = "⨒";
  var rrarr = "⇉";
  var Rrightarrow = "⇛";
  var rsaquo = "›";
  var rscr = "𝓇";
  var Rscr = "ℛ";
  var rsh = "↱";
  var Rsh = "↱";
  var rsqb = "]";
  var rsquo = "’";
  var rsquor = "’";
  var rthree = "⋌";
  var rtimes = "⋊";
  var rtri = "▹";
  var rtrie = "⊵";
  var rtrif = "▸";
  var rtriltri = "⧎";
  var RuleDelayed = "⧴";
  var ruluhar = "⥨";
  var rx = "℞";
  var Sacute = "Ś";
  var sacute = "ś";
  var sbquo = "‚";
  var scap = "⪸";
  var Scaron = "Š";
  var scaron = "š";
  var Sc = "⪼";
  var sc = "≻";
  var sccue = "≽";
  var sce = "⪰";
  var scE = "⪴";
  var Scedil = "Ş";
  var scedil = "ş";
  var Scirc = "Ŝ";
  var scirc = "ŝ";
  var scnap = "⪺";
  var scnE = "⪶";
  var scnsim = "⋩";
  var scpolint = "⨓";
  var scsim = "≿";
  var Scy = "С";
  var scy = "с";
  var sdotb = "⊡";
  var sdot = "⋅";
  var sdote = "⩦";
  var searhk = "⤥";
  var searr = "↘";
  var seArr = "⇘";
  var searrow = "↘";
  var sect$1 = "§";
  var semi = ";";
  var seswar = "⤩";
  var setminus = "∖";
  var setmn = "∖";
  var sext = "✶";
  var Sfr = "𝔖";
  var sfr = "𝔰";
  var sfrown = "⌢";
  var sharp = "♯";
  var SHCHcy = "Щ";
  var shchcy = "щ";
  var SHcy = "Ш";
  var shcy = "ш";
  var ShortDownArrow = "↓";
  var ShortLeftArrow = "←";
  var shortmid = "∣";
  var shortparallel = "∥";
  var ShortRightArrow = "→";
  var ShortUpArrow = "↑";
  var shy$1 = "­";
  var Sigma = "Σ";
  var sigma = "σ";
  var sigmaf = "ς";
  var sigmav = "ς";
  var sim = "∼";
  var simdot = "⩪";
  var sime = "≃";
  var simeq = "≃";
  var simg = "⪞";
  var simgE = "⪠";
  var siml = "⪝";
  var simlE = "⪟";
  var simne = "≆";
  var simplus = "⨤";
  var simrarr = "⥲";
  var slarr = "←";
  var SmallCircle = "∘";
  var smallsetminus = "∖";
  var smashp = "⨳";
  var smeparsl = "⧤";
  var smid = "∣";
  var smile = "⌣";
  var smt = "⪪";
  var smte = "⪬";
  var smtes = "⪬︀";
  var SOFTcy = "Ь";
  var softcy = "ь";
  var solbar = "⌿";
  var solb = "⧄";
  var sol = "/";
  var Sopf = "𝕊";
  var sopf = "𝕤";
  var spades = "♠";
  var spadesuit = "♠";
  var spar = "∥";
  var sqcap = "⊓";
  var sqcaps = "⊓︀";
  var sqcup = "⊔";
  var sqcups = "⊔︀";
  var Sqrt = "√";
  var sqsub = "⊏";
  var sqsube = "⊑";
  var sqsubset = "⊏";
  var sqsubseteq = "⊑";
  var sqsup = "⊐";
  var sqsupe = "⊒";
  var sqsupset = "⊐";
  var sqsupseteq = "⊒";
  var square = "□";
  var Square = "□";
  var SquareIntersection = "⊓";
  var SquareSubset = "⊏";
  var SquareSubsetEqual = "⊑";
  var SquareSuperset = "⊐";
  var SquareSupersetEqual = "⊒";
  var SquareUnion = "⊔";
  var squarf = "▪";
  var squ = "□";
  var squf = "▪";
  var srarr = "→";
  var Sscr = "𝒮";
  var sscr = "𝓈";
  var ssetmn = "∖";
  var ssmile = "⌣";
  var sstarf = "⋆";
  var Star = "⋆";
  var star = "☆";
  var starf = "★";
  var straightepsilon = "ϵ";
  var straightphi = "ϕ";
  var strns = "¯";
  var sub = "⊂";
  var Sub = "⋐";
  var subdot = "⪽";
  var subE = "⫅";
  var sube = "⊆";
  var subedot = "⫃";
  var submult = "⫁";
  var subnE = "⫋";
  var subne = "⊊";
  var subplus = "⪿";
  var subrarr = "⥹";
  var subset = "⊂";
  var Subset = "⋐";
  var subseteq = "⊆";
  var subseteqq = "⫅";
  var SubsetEqual = "⊆";
  var subsetneq = "⊊";
  var subsetneqq = "⫋";
  var subsim = "⫇";
  var subsub = "⫕";
  var subsup = "⫓";
  var succapprox = "⪸";
  var succ = "≻";
  var succcurlyeq = "≽";
  var Succeeds = "≻";
  var SucceedsEqual = "⪰";
  var SucceedsSlantEqual = "≽";
  var SucceedsTilde = "≿";
  var succeq = "⪰";
  var succnapprox = "⪺";
  var succneqq = "⪶";
  var succnsim = "⋩";
  var succsim = "≿";
  var SuchThat = "∋";
  var sum = "∑";
  var Sum = "∑";
  var sung = "♪";
  var sup1$1 = "¹";
  var sup2$1 = "²";
  var sup3$1 = "³";
  var sup = "⊃";
  var Sup = "⋑";
  var supdot = "⪾";
  var supdsub = "⫘";
  var supE = "⫆";
  var supe = "⊇";
  var supedot = "⫄";
  var Superset = "⊃";
  var SupersetEqual = "⊇";
  var suphsol = "⟉";
  var suphsub = "⫗";
  var suplarr = "⥻";
  var supmult = "⫂";
  var supnE = "⫌";
  var supne = "⊋";
  var supplus = "⫀";
  var supset = "⊃";
  var Supset = "⋑";
  var supseteq = "⊇";
  var supseteqq = "⫆";
  var supsetneq = "⊋";
  var supsetneqq = "⫌";
  var supsim = "⫈";
  var supsub = "⫔";
  var supsup = "⫖";
  var swarhk = "⤦";
  var swarr = "↙";
  var swArr = "⇙";
  var swarrow = "↙";
  var swnwar = "⤪";
  var szlig$1 = "ß";
  var Tab = "\t";
  var target = "⌖";
  var Tau = "Τ";
  var tau = "τ";
  var tbrk = "⎴";
  var Tcaron = "Ť";
  var tcaron = "ť";
  var Tcedil = "Ţ";
  var tcedil = "ţ";
  var Tcy = "Т";
  var tcy = "т";
  var tdot = "⃛";
  var telrec = "⌕";
  var Tfr = "𝔗";
  var tfr = "𝔱";
  var there4 = "∴";
  var therefore = "∴";
  var Therefore = "∴";
  var Theta = "Θ";
  var theta = "θ";
  var thetasym = "ϑ";
  var thetav = "ϑ";
  var thickapprox = "≈";
  var thicksim = "∼";
  var ThickSpace = "  ";
  var ThinSpace = " ";
  var thinsp = " ";
  var thkap = "≈";
  var thksim = "∼";
  var THORN$1 = "Þ";
  var thorn$1 = "þ";
  var tilde = "˜";
  var Tilde = "∼";
  var TildeEqual = "≃";
  var TildeFullEqual = "≅";
  var TildeTilde = "≈";
  var timesbar = "⨱";
  var timesb = "⊠";
  var times$1 = "×";
  var timesd = "⨰";
  var tint = "∭";
  var toea = "⤨";
  var topbot = "⌶";
  var topcir = "⫱";
  var top = "⊤";
  var Topf = "𝕋";
  var topf = "𝕥";
  var topfork = "⫚";
  var tosa = "⤩";
  var tprime = "‴";
  var trade = "™";
  var TRADE = "™";
  var triangle = "▵";
  var triangledown = "▿";
  var triangleleft = "◃";
  var trianglelefteq = "⊴";
  var triangleq = "≜";
  var triangleright = "▹";
  var trianglerighteq = "⊵";
  var tridot = "◬";
  var trie = "≜";
  var triminus = "⨺";
  var TripleDot = "⃛";
  var triplus = "⨹";
  var trisb = "⧍";
  var tritime = "⨻";
  var trpezium = "⏢";
  var Tscr = "𝒯";
  var tscr = "𝓉";
  var TScy = "Ц";
  var tscy = "ц";
  var TSHcy = "Ћ";
  var tshcy = "ћ";
  var Tstrok = "Ŧ";
  var tstrok = "ŧ";
  var twixt = "≬";
  var twoheadleftarrow = "↞";
  var twoheadrightarrow = "↠";
  var Uacute$1 = "Ú";
  var uacute$1 = "ú";
  var uarr = "↑";
  var Uarr = "↟";
  var uArr = "⇑";
  var Uarrocir = "⥉";
  var Ubrcy = "Ў";
  var ubrcy = "ў";
  var Ubreve = "Ŭ";
  var ubreve = "ŭ";
  var Ucirc$1 = "Û";
  var ucirc$1 = "û";
  var Ucy = "У";
  var ucy = "у";
  var udarr = "⇅";
  var Udblac = "Ű";
  var udblac = "ű";
  var udhar = "⥮";
  var ufisht = "⥾";
  var Ufr = "𝔘";
  var ufr = "𝔲";
  var Ugrave$1 = "Ù";
  var ugrave$1 = "ù";
  var uHar = "⥣";
  var uharl = "↿";
  var uharr = "↾";
  var uhblk = "▀";
  var ulcorn = "⌜";
  var ulcorner = "⌜";
  var ulcrop = "⌏";
  var ultri = "◸";
  var Umacr = "Ū";
  var umacr = "ū";
  var uml$1 = "¨";
  var UnderBar = "_";
  var UnderBrace = "⏟";
  var UnderBracket = "⎵";
  var UnderParenthesis = "⏝";
  var Union = "⋃";
  var UnionPlus = "⊎";
  var Uogon = "Ų";
  var uogon = "ų";
  var Uopf = "𝕌";
  var uopf = "𝕦";
  var UpArrowBar = "⤒";
  var uparrow = "↑";
  var UpArrow = "↑";
  var Uparrow = "⇑";
  var UpArrowDownArrow = "⇅";
  var updownarrow = "↕";
  var UpDownArrow = "↕";
  var Updownarrow = "⇕";
  var UpEquilibrium = "⥮";
  var upharpoonleft = "↿";
  var upharpoonright = "↾";
  var uplus = "⊎";
  var UpperLeftArrow = "↖";
  var UpperRightArrow = "↗";
  var upsi = "υ";
  var Upsi = "ϒ";
  var upsih = "ϒ";
  var Upsilon = "Υ";
  var upsilon = "υ";
  var UpTeeArrow = "↥";
  var UpTee = "⊥";
  var upuparrows = "⇈";
  var urcorn = "⌝";
  var urcorner = "⌝";
  var urcrop = "⌎";
  var Uring = "Ů";
  var uring = "ů";
  var urtri = "◹";
  var Uscr = "𝒰";
  var uscr = "𝓊";
  var utdot = "⋰";
  var Utilde = "Ũ";
  var utilde = "ũ";
  var utri = "▵";
  var utrif = "▴";
  var uuarr = "⇈";
  var Uuml$1 = "Ü";
  var uuml$1 = "ü";
  var uwangle = "⦧";
  var vangrt = "⦜";
  var varepsilon = "ϵ";
  var varkappa = "ϰ";
  var varnothing = "∅";
  var varphi = "ϕ";
  var varpi = "ϖ";
  var varpropto = "∝";
  var varr = "↕";
  var vArr = "⇕";
  var varrho = "ϱ";
  var varsigma = "ς";
  var varsubsetneq = "⊊︀";
  var varsubsetneqq = "⫋︀";
  var varsupsetneq = "⊋︀";
  var varsupsetneqq = "⫌︀";
  var vartheta = "ϑ";
  var vartriangleleft = "⊲";
  var vartriangleright = "⊳";
  var vBar = "⫨";
  var Vbar = "⫫";
  var vBarv = "⫩";
  var Vcy = "В";
  var vcy = "в";
  var vdash = "⊢";
  var vDash = "⊨";
  var Vdash = "⊩";
  var VDash = "⊫";
  var Vdashl = "⫦";
  var veebar = "⊻";
  var vee = "∨";
  var Vee = "⋁";
  var veeeq = "≚";
  var vellip = "⋮";
  var verbar = "|";
  var Verbar = "‖";
  var vert = "|";
  var Vert = "‖";
  var VerticalBar = "∣";
  var VerticalLine = "|";
  var VerticalSeparator = "❘";
  var VerticalTilde = "≀";
  var VeryThinSpace = " ";
  var Vfr = "𝔙";
  var vfr = "𝔳";
  var vltri = "⊲";
  var vnsub = "⊂⃒";
  var vnsup = "⊃⃒";
  var Vopf = "𝕍";
  var vopf = "𝕧";
  var vprop = "∝";
  var vrtri = "⊳";
  var Vscr = "𝒱";
  var vscr = "𝓋";
  var vsubnE = "⫋︀";
  var vsubne = "⊊︀";
  var vsupnE = "⫌︀";
  var vsupne = "⊋︀";
  var Vvdash = "⊪";
  var vzigzag = "⦚";
  var Wcirc = "Ŵ";
  var wcirc = "ŵ";
  var wedbar = "⩟";
  var wedge = "∧";
  var Wedge = "⋀";
  var wedgeq = "≙";
  var weierp = "℘";
  var Wfr = "𝔚";
  var wfr = "𝔴";
  var Wopf = "𝕎";
  var wopf = "𝕨";
  var wp = "℘";
  var wr = "≀";
  var wreath = "≀";
  var Wscr = "𝒲";
  var wscr = "𝓌";
  var xcap = "⋂";
  var xcirc = "◯";
  var xcup = "⋃";
  var xdtri = "▽";
  var Xfr = "𝔛";
  var xfr = "𝔵";
  var xharr = "⟷";
  var xhArr = "⟺";
  var Xi = "Ξ";
  var xi = "ξ";
  var xlarr = "⟵";
  var xlArr = "⟸";
  var xmap = "⟼";
  var xnis = "⋻";
  var xodot = "⨀";
  var Xopf = "𝕏";
  var xopf = "𝕩";
  var xoplus = "⨁";
  var xotime = "⨂";
  var xrarr = "⟶";
  var xrArr = "⟹";
  var Xscr = "𝒳";
  var xscr = "𝓍";
  var xsqcup = "⨆";
  var xuplus = "⨄";
  var xutri = "△";
  var xvee = "⋁";
  var xwedge = "⋀";
  var Yacute$1 = "Ý";
  var yacute$1 = "ý";
  var YAcy = "Я";
  var yacy = "я";
  var Ycirc = "Ŷ";
  var ycirc = "ŷ";
  var Ycy = "Ы";
  var ycy = "ы";
  var yen$1 = "¥";
  var Yfr = "𝔜";
  var yfr = "𝔶";
  var YIcy = "Ї";
  var yicy = "ї";
  var Yopf = "𝕐";
  var yopf = "𝕪";
  var Yscr = "𝒴";
  var yscr = "𝓎";
  var YUcy = "Ю";
  var yucy = "ю";
  var yuml$1 = "ÿ";
  var Yuml = "Ÿ";
  var Zacute = "Ź";
  var zacute = "ź";
  var Zcaron = "Ž";
  var zcaron = "ž";
  var Zcy = "З";
  var zcy = "з";
  var Zdot = "Ż";
  var zdot = "ż";
  var zeetrf = "ℨ";
  var ZeroWidthSpace = "​";
  var Zeta = "Ζ";
  var zeta = "ζ";
  var zfr = "𝔷";
  var Zfr = "ℨ";
  var ZHcy = "Ж";
  var zhcy = "ж";
  var zigrarr = "⇝";
  var zopf = "𝕫";
  var Zopf = "ℤ";
  var Zscr = "𝒵";
  var zscr = "𝓏";
  var zwj = "‍";
  var zwnj = "‌";
  var entities$1 = {
  	Aacute: Aacute$1,
  	aacute: aacute$1,
  	Abreve: Abreve,
  	abreve: abreve,
  	ac: ac,
  	acd: acd,
  	acE: acE,
  	Acirc: Acirc$1,
  	acirc: acirc$1,
  	acute: acute$1,
  	Acy: Acy,
  	acy: acy,
  	AElig: AElig$1,
  	aelig: aelig$1,
  	af: af,
  	Afr: Afr,
  	afr: afr,
  	Agrave: Agrave$1,
  	agrave: agrave$1,
  	alefsym: alefsym,
  	aleph: aleph,
  	Alpha: Alpha,
  	alpha: alpha,
  	Amacr: Amacr,
  	amacr: amacr,
  	amalg: amalg,
  	amp: amp$2,
  	AMP: AMP$1,
  	andand: andand,
  	And: And,
  	and: and,
  	andd: andd,
  	andslope: andslope,
  	andv: andv,
  	ang: ang,
  	ange: ange,
  	angle: angle,
  	angmsdaa: angmsdaa,
  	angmsdab: angmsdab,
  	angmsdac: angmsdac,
  	angmsdad: angmsdad,
  	angmsdae: angmsdae,
  	angmsdaf: angmsdaf,
  	angmsdag: angmsdag,
  	angmsdah: angmsdah,
  	angmsd: angmsd,
  	angrt: angrt,
  	angrtvb: angrtvb,
  	angrtvbd: angrtvbd,
  	angsph: angsph,
  	angst: angst,
  	angzarr: angzarr,
  	Aogon: Aogon,
  	aogon: aogon,
  	Aopf: Aopf,
  	aopf: aopf,
  	apacir: apacir,
  	ap: ap,
  	apE: apE,
  	ape: ape,
  	apid: apid,
  	apos: apos$1,
  	ApplyFunction: ApplyFunction,
  	approx: approx,
  	approxeq: approxeq,
  	Aring: Aring$1,
  	aring: aring$1,
  	Ascr: Ascr,
  	ascr: ascr,
  	Assign: Assign,
  	ast: ast,
  	asymp: asymp,
  	asympeq: asympeq,
  	Atilde: Atilde$1,
  	atilde: atilde$1,
  	Auml: Auml$1,
  	auml: auml$1,
  	awconint: awconint,
  	awint: awint,
  	backcong: backcong,
  	backepsilon: backepsilon,
  	backprime: backprime,
  	backsim: backsim,
  	backsimeq: backsimeq,
  	Backslash: Backslash,
  	Barv: Barv,
  	barvee: barvee,
  	barwed: barwed,
  	Barwed: Barwed,
  	barwedge: barwedge,
  	bbrk: bbrk,
  	bbrktbrk: bbrktbrk,
  	bcong: bcong,
  	Bcy: Bcy,
  	bcy: bcy,
  	bdquo: bdquo,
  	becaus: becaus,
  	because: because,
  	Because: Because,
  	bemptyv: bemptyv,
  	bepsi: bepsi,
  	bernou: bernou,
  	Bernoullis: Bernoullis,
  	Beta: Beta,
  	beta: beta,
  	beth: beth,
  	between: between,
  	Bfr: Bfr,
  	bfr: bfr,
  	bigcap: bigcap,
  	bigcirc: bigcirc,
  	bigcup: bigcup,
  	bigodot: bigodot,
  	bigoplus: bigoplus,
  	bigotimes: bigotimes,
  	bigsqcup: bigsqcup,
  	bigstar: bigstar,
  	bigtriangledown: bigtriangledown,
  	bigtriangleup: bigtriangleup,
  	biguplus: biguplus,
  	bigvee: bigvee,
  	bigwedge: bigwedge,
  	bkarow: bkarow,
  	blacklozenge: blacklozenge,
  	blacksquare: blacksquare,
  	blacktriangle: blacktriangle,
  	blacktriangledown: blacktriangledown,
  	blacktriangleleft: blacktriangleleft,
  	blacktriangleright: blacktriangleright,
  	blank: blank,
  	blk12: blk12,
  	blk14: blk14,
  	blk34: blk34,
  	block: block,
  	bne: bne,
  	bnequiv: bnequiv,
  	bNot: bNot,
  	bnot: bnot,
  	Bopf: Bopf,
  	bopf: bopf,
  	bot: bot,
  	bottom: bottom,
  	bowtie: bowtie,
  	boxbox: boxbox,
  	boxdl: boxdl,
  	boxdL: boxdL,
  	boxDl: boxDl,
  	boxDL: boxDL,
  	boxdr: boxdr,
  	boxdR: boxdR,
  	boxDr: boxDr,
  	boxDR: boxDR,
  	boxh: boxh,
  	boxH: boxH,
  	boxhd: boxhd,
  	boxHd: boxHd,
  	boxhD: boxhD,
  	boxHD: boxHD,
  	boxhu: boxhu,
  	boxHu: boxHu,
  	boxhU: boxhU,
  	boxHU: boxHU,
  	boxminus: boxminus,
  	boxplus: boxplus,
  	boxtimes: boxtimes,
  	boxul: boxul,
  	boxuL: boxuL,
  	boxUl: boxUl,
  	boxUL: boxUL,
  	boxur: boxur,
  	boxuR: boxuR,
  	boxUr: boxUr,
  	boxUR: boxUR,
  	boxv: boxv,
  	boxV: boxV,
  	boxvh: boxvh,
  	boxvH: boxvH,
  	boxVh: boxVh,
  	boxVH: boxVH,
  	boxvl: boxvl,
  	boxvL: boxvL,
  	boxVl: boxVl,
  	boxVL: boxVL,
  	boxvr: boxvr,
  	boxvR: boxvR,
  	boxVr: boxVr,
  	boxVR: boxVR,
  	bprime: bprime,
  	breve: breve,
  	Breve: Breve,
  	brvbar: brvbar$1,
  	bscr: bscr,
  	Bscr: Bscr,
  	bsemi: bsemi,
  	bsim: bsim,
  	bsime: bsime,
  	bsolb: bsolb,
  	bsol: bsol,
  	bsolhsub: bsolhsub,
  	bull: bull,
  	bullet: bullet,
  	bump: bump,
  	bumpE: bumpE,
  	bumpe: bumpe,
  	Bumpeq: Bumpeq,
  	bumpeq: bumpeq,
  	Cacute: Cacute,
  	cacute: cacute,
  	capand: capand,
  	capbrcup: capbrcup,
  	capcap: capcap,
  	cap: cap,
  	Cap: Cap,
  	capcup: capcup,
  	capdot: capdot,
  	CapitalDifferentialD: CapitalDifferentialD,
  	caps: caps,
  	caret: caret,
  	caron: caron,
  	Cayleys: Cayleys,
  	ccaps: ccaps,
  	Ccaron: Ccaron,
  	ccaron: ccaron,
  	Ccedil: Ccedil$1,
  	ccedil: ccedil$1,
  	Ccirc: Ccirc,
  	ccirc: ccirc,
  	Cconint: Cconint,
  	ccups: ccups,
  	ccupssm: ccupssm,
  	Cdot: Cdot,
  	cdot: cdot,
  	cedil: cedil$1,
  	Cedilla: Cedilla,
  	cemptyv: cemptyv,
  	cent: cent$1,
  	centerdot: centerdot,
  	CenterDot: CenterDot,
  	cfr: cfr,
  	Cfr: Cfr,
  	CHcy: CHcy,
  	chcy: chcy,
  	check: check,
  	checkmark: checkmark,
  	Chi: Chi,
  	chi: chi,
  	circ: circ,
  	circeq: circeq,
  	circlearrowleft: circlearrowleft,
  	circlearrowright: circlearrowright,
  	circledast: circledast,
  	circledcirc: circledcirc,
  	circleddash: circleddash,
  	CircleDot: CircleDot,
  	circledR: circledR,
  	circledS: circledS,
  	CircleMinus: CircleMinus,
  	CirclePlus: CirclePlus,
  	CircleTimes: CircleTimes,
  	cir: cir,
  	cirE: cirE,
  	cire: cire,
  	cirfnint: cirfnint,
  	cirmid: cirmid,
  	cirscir: cirscir,
  	ClockwiseContourIntegral: ClockwiseContourIntegral,
  	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
  	CloseCurlyQuote: CloseCurlyQuote,
  	clubs: clubs,
  	clubsuit: clubsuit,
  	colon: colon,
  	Colon: Colon,
  	Colone: Colone,
  	colone: colone,
  	coloneq: coloneq,
  	comma: comma,
  	commat: commat,
  	comp: comp,
  	compfn: compfn,
  	complement: complement,
  	complexes: complexes,
  	cong: cong,
  	congdot: congdot,
  	Congruent: Congruent,
  	conint: conint,
  	Conint: Conint,
  	ContourIntegral: ContourIntegral,
  	copf: copf,
  	Copf: Copf,
  	coprod: coprod,
  	Coproduct: Coproduct,
  	copy: copy$1,
  	COPY: COPY$1,
  	copysr: copysr,
  	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
  	crarr: crarr,
  	cross: cross,
  	Cross: Cross,
  	Cscr: Cscr,
  	cscr: cscr,
  	csub: csub,
  	csube: csube,
  	csup: csup,
  	csupe: csupe,
  	ctdot: ctdot,
  	cudarrl: cudarrl,
  	cudarrr: cudarrr,
  	cuepr: cuepr,
  	cuesc: cuesc,
  	cularr: cularr,
  	cularrp: cularrp,
  	cupbrcap: cupbrcap,
  	cupcap: cupcap,
  	CupCap: CupCap,
  	cup: cup,
  	Cup: Cup,
  	cupcup: cupcup,
  	cupdot: cupdot,
  	cupor: cupor,
  	cups: cups,
  	curarr: curarr,
  	curarrm: curarrm,
  	curlyeqprec: curlyeqprec,
  	curlyeqsucc: curlyeqsucc,
  	curlyvee: curlyvee,
  	curlywedge: curlywedge,
  	curren: curren$1,
  	curvearrowleft: curvearrowleft,
  	curvearrowright: curvearrowright,
  	cuvee: cuvee,
  	cuwed: cuwed,
  	cwconint: cwconint,
  	cwint: cwint,
  	cylcty: cylcty,
  	dagger: dagger,
  	Dagger: Dagger,
  	daleth: daleth,
  	darr: darr,
  	Darr: Darr,
  	dArr: dArr,
  	dash: dash,
  	Dashv: Dashv,
  	dashv: dashv,
  	dbkarow: dbkarow,
  	dblac: dblac,
  	Dcaron: Dcaron,
  	dcaron: dcaron,
  	Dcy: Dcy,
  	dcy: dcy,
  	ddagger: ddagger,
  	ddarr: ddarr,
  	DD: DD,
  	dd: dd,
  	DDotrahd: DDotrahd,
  	ddotseq: ddotseq,
  	deg: deg$1,
  	Del: Del,
  	Delta: Delta,
  	delta: delta,
  	demptyv: demptyv,
  	dfisht: dfisht,
  	Dfr: Dfr,
  	dfr: dfr,
  	dHar: dHar,
  	dharl: dharl,
  	dharr: dharr,
  	DiacriticalAcute: DiacriticalAcute,
  	DiacriticalDot: DiacriticalDot,
  	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
  	DiacriticalGrave: DiacriticalGrave,
  	DiacriticalTilde: DiacriticalTilde,
  	diam: diam,
  	diamond: diamond,
  	Diamond: Diamond,
  	diamondsuit: diamondsuit,
  	diams: diams,
  	die: die,
  	DifferentialD: DifferentialD,
  	digamma: digamma,
  	disin: disin,
  	div: div,
  	divide: divide$1,
  	divideontimes: divideontimes,
  	divonx: divonx,
  	DJcy: DJcy,
  	djcy: djcy,
  	dlcorn: dlcorn,
  	dlcrop: dlcrop,
  	dollar: dollar,
  	Dopf: Dopf,
  	dopf: dopf,
  	Dot: Dot,
  	dot: dot,
  	DotDot: DotDot,
  	doteq: doteq,
  	doteqdot: doteqdot,
  	DotEqual: DotEqual,
  	dotminus: dotminus,
  	dotplus: dotplus,
  	dotsquare: dotsquare,
  	doublebarwedge: doublebarwedge,
  	DoubleContourIntegral: DoubleContourIntegral,
  	DoubleDot: DoubleDot,
  	DoubleDownArrow: DoubleDownArrow,
  	DoubleLeftArrow: DoubleLeftArrow,
  	DoubleLeftRightArrow: DoubleLeftRightArrow,
  	DoubleLeftTee: DoubleLeftTee,
  	DoubleLongLeftArrow: DoubleLongLeftArrow,
  	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
  	DoubleLongRightArrow: DoubleLongRightArrow,
  	DoubleRightArrow: DoubleRightArrow,
  	DoubleRightTee: DoubleRightTee,
  	DoubleUpArrow: DoubleUpArrow,
  	DoubleUpDownArrow: DoubleUpDownArrow,
  	DoubleVerticalBar: DoubleVerticalBar,
  	DownArrowBar: DownArrowBar,
  	downarrow: downarrow,
  	DownArrow: DownArrow,
  	Downarrow: Downarrow,
  	DownArrowUpArrow: DownArrowUpArrow,
  	DownBreve: DownBreve,
  	downdownarrows: downdownarrows,
  	downharpoonleft: downharpoonleft,
  	downharpoonright: downharpoonright,
  	DownLeftRightVector: DownLeftRightVector,
  	DownLeftTeeVector: DownLeftTeeVector,
  	DownLeftVectorBar: DownLeftVectorBar,
  	DownLeftVector: DownLeftVector,
  	DownRightTeeVector: DownRightTeeVector,
  	DownRightVectorBar: DownRightVectorBar,
  	DownRightVector: DownRightVector,
  	DownTeeArrow: DownTeeArrow,
  	DownTee: DownTee,
  	drbkarow: drbkarow,
  	drcorn: drcorn,
  	drcrop: drcrop,
  	Dscr: Dscr,
  	dscr: dscr,
  	DScy: DScy,
  	dscy: dscy,
  	dsol: dsol,
  	Dstrok: Dstrok,
  	dstrok: dstrok,
  	dtdot: dtdot,
  	dtri: dtri,
  	dtrif: dtrif,
  	duarr: duarr,
  	duhar: duhar,
  	dwangle: dwangle,
  	DZcy: DZcy,
  	dzcy: dzcy,
  	dzigrarr: dzigrarr,
  	Eacute: Eacute$1,
  	eacute: eacute$1,
  	easter: easter,
  	Ecaron: Ecaron,
  	ecaron: ecaron,
  	Ecirc: Ecirc$1,
  	ecirc: ecirc$1,
  	ecir: ecir,
  	ecolon: ecolon,
  	Ecy: Ecy,
  	ecy: ecy,
  	eDDot: eDDot,
  	Edot: Edot,
  	edot: edot,
  	eDot: eDot,
  	ee: ee,
  	efDot: efDot,
  	Efr: Efr,
  	efr: efr,
  	eg: eg,
  	Egrave: Egrave$1,
  	egrave: egrave$1,
  	egs: egs,
  	egsdot: egsdot,
  	el: el,
  	Element: Element,
  	elinters: elinters,
  	ell: ell,
  	els: els,
  	elsdot: elsdot,
  	Emacr: Emacr,
  	emacr: emacr,
  	empty: empty,
  	emptyset: emptyset,
  	EmptySmallSquare: EmptySmallSquare,
  	emptyv: emptyv,
  	EmptyVerySmallSquare: EmptyVerySmallSquare,
  	emsp13: emsp13,
  	emsp14: emsp14,
  	emsp: emsp,
  	ENG: ENG,
  	eng: eng,
  	ensp: ensp,
  	Eogon: Eogon,
  	eogon: eogon,
  	Eopf: Eopf,
  	eopf: eopf,
  	epar: epar,
  	eparsl: eparsl,
  	eplus: eplus,
  	epsi: epsi,
  	Epsilon: Epsilon,
  	epsilon: epsilon,
  	epsiv: epsiv,
  	eqcirc: eqcirc,
  	eqcolon: eqcolon,
  	eqsim: eqsim,
  	eqslantgtr: eqslantgtr,
  	eqslantless: eqslantless,
  	Equal: Equal,
  	equals: equals,
  	EqualTilde: EqualTilde,
  	equest: equest,
  	Equilibrium: Equilibrium,
  	equiv: equiv,
  	equivDD: equivDD,
  	eqvparsl: eqvparsl,
  	erarr: erarr,
  	erDot: erDot,
  	escr: escr,
  	Escr: Escr,
  	esdot: esdot,
  	Esim: Esim,
  	esim: esim,
  	Eta: Eta,
  	eta: eta,
  	ETH: ETH$1,
  	eth: eth$1,
  	Euml: Euml$1,
  	euml: euml$1,
  	euro: euro,
  	excl: excl,
  	exist: exist,
  	Exists: Exists,
  	expectation: expectation,
  	exponentiale: exponentiale,
  	ExponentialE: ExponentialE,
  	fallingdotseq: fallingdotseq,
  	Fcy: Fcy,
  	fcy: fcy,
  	female: female,
  	ffilig: ffilig,
  	fflig: fflig,
  	ffllig: ffllig,
  	Ffr: Ffr,
  	ffr: ffr,
  	filig: filig,
  	FilledSmallSquare: FilledSmallSquare,
  	FilledVerySmallSquare: FilledVerySmallSquare,
  	fjlig: fjlig,
  	flat: flat,
  	fllig: fllig,
  	fltns: fltns,
  	fnof: fnof,
  	Fopf: Fopf,
  	fopf: fopf,
  	forall: forall,
  	ForAll: ForAll,
  	fork: fork,
  	forkv: forkv,
  	Fouriertrf: Fouriertrf,
  	fpartint: fpartint,
  	frac12: frac12$1,
  	frac13: frac13,
  	frac14: frac14$1,
  	frac15: frac15,
  	frac16: frac16,
  	frac18: frac18,
  	frac23: frac23,
  	frac25: frac25,
  	frac34: frac34$1,
  	frac35: frac35,
  	frac38: frac38,
  	frac45: frac45,
  	frac56: frac56,
  	frac58: frac58,
  	frac78: frac78,
  	frasl: frasl,
  	frown: frown,
  	fscr: fscr,
  	Fscr: Fscr,
  	gacute: gacute,
  	Gamma: Gamma,
  	gamma: gamma,
  	Gammad: Gammad,
  	gammad: gammad,
  	gap: gap,
  	Gbreve: Gbreve,
  	gbreve: gbreve,
  	Gcedil: Gcedil,
  	Gcirc: Gcirc,
  	gcirc: gcirc,
  	Gcy: Gcy,
  	gcy: gcy,
  	Gdot: Gdot,
  	gdot: gdot,
  	ge: ge,
  	gE: gE,
  	gEl: gEl,
  	gel: gel,
  	geq: geq,
  	geqq: geqq,
  	geqslant: geqslant,
  	gescc: gescc,
  	ges: ges,
  	gesdot: gesdot,
  	gesdoto: gesdoto,
  	gesdotol: gesdotol,
  	gesl: gesl,
  	gesles: gesles,
  	Gfr: Gfr,
  	gfr: gfr,
  	gg: gg,
  	Gg: Gg,
  	ggg: ggg,
  	gimel: gimel,
  	GJcy: GJcy,
  	gjcy: gjcy,
  	gla: gla,
  	gl: gl,
  	glE: glE,
  	glj: glj,
  	gnap: gnap,
  	gnapprox: gnapprox,
  	gne: gne,
  	gnE: gnE,
  	gneq: gneq,
  	gneqq: gneqq,
  	gnsim: gnsim,
  	Gopf: Gopf,
  	gopf: gopf,
  	grave: grave,
  	GreaterEqual: GreaterEqual,
  	GreaterEqualLess: GreaterEqualLess,
  	GreaterFullEqual: GreaterFullEqual,
  	GreaterGreater: GreaterGreater,
  	GreaterLess: GreaterLess,
  	GreaterSlantEqual: GreaterSlantEqual,
  	GreaterTilde: GreaterTilde,
  	Gscr: Gscr,
  	gscr: gscr,
  	gsim: gsim,
  	gsime: gsime,
  	gsiml: gsiml,
  	gtcc: gtcc,
  	gtcir: gtcir,
  	gt: gt$2,
  	GT: GT$1,
  	Gt: Gt,
  	gtdot: gtdot,
  	gtlPar: gtlPar,
  	gtquest: gtquest,
  	gtrapprox: gtrapprox,
  	gtrarr: gtrarr,
  	gtrdot: gtrdot,
  	gtreqless: gtreqless,
  	gtreqqless: gtreqqless,
  	gtrless: gtrless,
  	gtrsim: gtrsim,
  	gvertneqq: gvertneqq,
  	gvnE: gvnE,
  	Hacek: Hacek,
  	hairsp: hairsp,
  	half: half,
  	hamilt: hamilt,
  	HARDcy: HARDcy,
  	hardcy: hardcy,
  	harrcir: harrcir,
  	harr: harr,
  	hArr: hArr,
  	harrw: harrw,
  	Hat: Hat,
  	hbar: hbar,
  	Hcirc: Hcirc,
  	hcirc: hcirc,
  	hearts: hearts,
  	heartsuit: heartsuit,
  	hellip: hellip,
  	hercon: hercon,
  	hfr: hfr,
  	Hfr: Hfr,
  	HilbertSpace: HilbertSpace,
  	hksearow: hksearow,
  	hkswarow: hkswarow,
  	hoarr: hoarr,
  	homtht: homtht,
  	hookleftarrow: hookleftarrow,
  	hookrightarrow: hookrightarrow,
  	hopf: hopf,
  	Hopf: Hopf,
  	horbar: horbar,
  	HorizontalLine: HorizontalLine,
  	hscr: hscr,
  	Hscr: Hscr,
  	hslash: hslash,
  	Hstrok: Hstrok,
  	hstrok: hstrok,
  	HumpDownHump: HumpDownHump,
  	HumpEqual: HumpEqual,
  	hybull: hybull,
  	hyphen: hyphen,
  	Iacute: Iacute$1,
  	iacute: iacute$1,
  	ic: ic,
  	Icirc: Icirc$1,
  	icirc: icirc$1,
  	Icy: Icy,
  	icy: icy,
  	Idot: Idot,
  	IEcy: IEcy,
  	iecy: iecy,
  	iexcl: iexcl$1,
  	iff: iff,
  	ifr: ifr,
  	Ifr: Ifr,
  	Igrave: Igrave$1,
  	igrave: igrave$1,
  	ii: ii,
  	iiiint: iiiint,
  	iiint: iiint,
  	iinfin: iinfin,
  	iiota: iiota,
  	IJlig: IJlig,
  	ijlig: ijlig,
  	Imacr: Imacr,
  	imacr: imacr,
  	image: image,
  	ImaginaryI: ImaginaryI,
  	imagline: imagline,
  	imagpart: imagpart,
  	imath: imath,
  	Im: Im,
  	imof: imof,
  	imped: imped,
  	Implies: Implies,
  	incare: incare,
  	"in": "∈",
  	infin: infin,
  	infintie: infintie,
  	inodot: inodot,
  	intcal: intcal,
  	int: int,
  	Int: Int,
  	integers: integers,
  	Integral: Integral,
  	intercal: intercal,
  	Intersection: Intersection,
  	intlarhk: intlarhk,
  	intprod: intprod,
  	InvisibleComma: InvisibleComma,
  	InvisibleTimes: InvisibleTimes,
  	IOcy: IOcy,
  	iocy: iocy,
  	Iogon: Iogon,
  	iogon: iogon,
  	Iopf: Iopf,
  	iopf: iopf,
  	Iota: Iota,
  	iota: iota,
  	iprod: iprod,
  	iquest: iquest$1,
  	iscr: iscr,
  	Iscr: Iscr,
  	isin: isin,
  	isindot: isindot,
  	isinE: isinE,
  	isins: isins,
  	isinsv: isinsv,
  	isinv: isinv,
  	it: it,
  	Itilde: Itilde,
  	itilde: itilde,
  	Iukcy: Iukcy,
  	iukcy: iukcy,
  	Iuml: Iuml$1,
  	iuml: iuml$1,
  	Jcirc: Jcirc,
  	jcirc: jcirc,
  	Jcy: Jcy,
  	jcy: jcy,
  	Jfr: Jfr,
  	jfr: jfr,
  	jmath: jmath,
  	Jopf: Jopf,
  	jopf: jopf,
  	Jscr: Jscr,
  	jscr: jscr,
  	Jsercy: Jsercy,
  	jsercy: jsercy,
  	Jukcy: Jukcy,
  	jukcy: jukcy,
  	Kappa: Kappa,
  	kappa: kappa,
  	kappav: kappav,
  	Kcedil: Kcedil,
  	kcedil: kcedil,
  	Kcy: Kcy,
  	kcy: kcy,
  	Kfr: Kfr,
  	kfr: kfr,
  	kgreen: kgreen,
  	KHcy: KHcy,
  	khcy: khcy,
  	KJcy: KJcy,
  	kjcy: kjcy,
  	Kopf: Kopf,
  	kopf: kopf,
  	Kscr: Kscr,
  	kscr: kscr,
  	lAarr: lAarr,
  	Lacute: Lacute,
  	lacute: lacute,
  	laemptyv: laemptyv,
  	lagran: lagran,
  	Lambda: Lambda,
  	lambda: lambda,
  	lang: lang,
  	Lang: Lang,
  	langd: langd,
  	langle: langle,
  	lap: lap,
  	Laplacetrf: Laplacetrf,
  	laquo: laquo$1,
  	larrb: larrb,
  	larrbfs: larrbfs,
  	larr: larr,
  	Larr: Larr,
  	lArr: lArr,
  	larrfs: larrfs,
  	larrhk: larrhk,
  	larrlp: larrlp,
  	larrpl: larrpl,
  	larrsim: larrsim,
  	larrtl: larrtl,
  	latail: latail,
  	lAtail: lAtail,
  	lat: lat,
  	late: late,
  	lates: lates,
  	lbarr: lbarr,
  	lBarr: lBarr,
  	lbbrk: lbbrk,
  	lbrace: lbrace,
  	lbrack: lbrack,
  	lbrke: lbrke,
  	lbrksld: lbrksld,
  	lbrkslu: lbrkslu,
  	Lcaron: Lcaron,
  	lcaron: lcaron,
  	Lcedil: Lcedil,
  	lcedil: lcedil,
  	lceil: lceil,
  	lcub: lcub,
  	Lcy: Lcy,
  	lcy: lcy,
  	ldca: ldca,
  	ldquo: ldquo,
  	ldquor: ldquor,
  	ldrdhar: ldrdhar,
  	ldrushar: ldrushar,
  	ldsh: ldsh,
  	le: le,
  	lE: lE,
  	LeftAngleBracket: LeftAngleBracket,
  	LeftArrowBar: LeftArrowBar,
  	leftarrow: leftarrow,
  	LeftArrow: LeftArrow,
  	Leftarrow: Leftarrow,
  	LeftArrowRightArrow: LeftArrowRightArrow,
  	leftarrowtail: leftarrowtail,
  	LeftCeiling: LeftCeiling,
  	LeftDoubleBracket: LeftDoubleBracket,
  	LeftDownTeeVector: LeftDownTeeVector,
  	LeftDownVectorBar: LeftDownVectorBar,
  	LeftDownVector: LeftDownVector,
  	LeftFloor: LeftFloor,
  	leftharpoondown: leftharpoondown,
  	leftharpoonup: leftharpoonup,
  	leftleftarrows: leftleftarrows,
  	leftrightarrow: leftrightarrow,
  	LeftRightArrow: LeftRightArrow,
  	Leftrightarrow: Leftrightarrow,
  	leftrightarrows: leftrightarrows,
  	leftrightharpoons: leftrightharpoons,
  	leftrightsquigarrow: leftrightsquigarrow,
  	LeftRightVector: LeftRightVector,
  	LeftTeeArrow: LeftTeeArrow,
  	LeftTee: LeftTee,
  	LeftTeeVector: LeftTeeVector,
  	leftthreetimes: leftthreetimes,
  	LeftTriangleBar: LeftTriangleBar,
  	LeftTriangle: LeftTriangle,
  	LeftTriangleEqual: LeftTriangleEqual,
  	LeftUpDownVector: LeftUpDownVector,
  	LeftUpTeeVector: LeftUpTeeVector,
  	LeftUpVectorBar: LeftUpVectorBar,
  	LeftUpVector: LeftUpVector,
  	LeftVectorBar: LeftVectorBar,
  	LeftVector: LeftVector,
  	lEg: lEg,
  	leg: leg,
  	leq: leq,
  	leqq: leqq,
  	leqslant: leqslant,
  	lescc: lescc,
  	les: les,
  	lesdot: lesdot,
  	lesdoto: lesdoto,
  	lesdotor: lesdotor,
  	lesg: lesg,
  	lesges: lesges,
  	lessapprox: lessapprox,
  	lessdot: lessdot,
  	lesseqgtr: lesseqgtr,
  	lesseqqgtr: lesseqqgtr,
  	LessEqualGreater: LessEqualGreater,
  	LessFullEqual: LessFullEqual,
  	LessGreater: LessGreater,
  	lessgtr: lessgtr,
  	LessLess: LessLess,
  	lesssim: lesssim,
  	LessSlantEqual: LessSlantEqual,
  	LessTilde: LessTilde,
  	lfisht: lfisht,
  	lfloor: lfloor,
  	Lfr: Lfr,
  	lfr: lfr,
  	lg: lg,
  	lgE: lgE,
  	lHar: lHar,
  	lhard: lhard,
  	lharu: lharu,
  	lharul: lharul,
  	lhblk: lhblk,
  	LJcy: LJcy,
  	ljcy: ljcy,
  	llarr: llarr,
  	ll: ll,
  	Ll: Ll,
  	llcorner: llcorner,
  	Lleftarrow: Lleftarrow,
  	llhard: llhard,
  	lltri: lltri,
  	Lmidot: Lmidot,
  	lmidot: lmidot,
  	lmoustache: lmoustache,
  	lmoust: lmoust,
  	lnap: lnap,
  	lnapprox: lnapprox,
  	lne: lne,
  	lnE: lnE,
  	lneq: lneq,
  	lneqq: lneqq,
  	lnsim: lnsim,
  	loang: loang,
  	loarr: loarr,
  	lobrk: lobrk,
  	longleftarrow: longleftarrow,
  	LongLeftArrow: LongLeftArrow,
  	Longleftarrow: Longleftarrow,
  	longleftrightarrow: longleftrightarrow,
  	LongLeftRightArrow: LongLeftRightArrow,
  	Longleftrightarrow: Longleftrightarrow,
  	longmapsto: longmapsto,
  	longrightarrow: longrightarrow,
  	LongRightArrow: LongRightArrow,
  	Longrightarrow: Longrightarrow,
  	looparrowleft: looparrowleft,
  	looparrowright: looparrowright,
  	lopar: lopar,
  	Lopf: Lopf,
  	lopf: lopf,
  	loplus: loplus,
  	lotimes: lotimes,
  	lowast: lowast,
  	lowbar: lowbar,
  	LowerLeftArrow: LowerLeftArrow,
  	LowerRightArrow: LowerRightArrow,
  	loz: loz,
  	lozenge: lozenge,
  	lozf: lozf,
  	lpar: lpar,
  	lparlt: lparlt,
  	lrarr: lrarr,
  	lrcorner: lrcorner,
  	lrhar: lrhar,
  	lrhard: lrhard,
  	lrm: lrm,
  	lrtri: lrtri,
  	lsaquo: lsaquo,
  	lscr: lscr,
  	Lscr: Lscr,
  	lsh: lsh,
  	Lsh: Lsh,
  	lsim: lsim,
  	lsime: lsime,
  	lsimg: lsimg,
  	lsqb: lsqb,
  	lsquo: lsquo,
  	lsquor: lsquor,
  	Lstrok: Lstrok,
  	lstrok: lstrok,
  	ltcc: ltcc,
  	ltcir: ltcir,
  	lt: lt$2,
  	LT: LT$1,
  	Lt: Lt,
  	ltdot: ltdot,
  	lthree: lthree,
  	ltimes: ltimes,
  	ltlarr: ltlarr,
  	ltquest: ltquest,
  	ltri: ltri,
  	ltrie: ltrie,
  	ltrif: ltrif,
  	ltrPar: ltrPar,
  	lurdshar: lurdshar,
  	luruhar: luruhar,
  	lvertneqq: lvertneqq,
  	lvnE: lvnE,
  	macr: macr$1,
  	male: male,
  	malt: malt,
  	maltese: maltese,
  	"Map": "⤅",
  	map: map,
  	mapsto: mapsto,
  	mapstodown: mapstodown,
  	mapstoleft: mapstoleft,
  	mapstoup: mapstoup,
  	marker: marker,
  	mcomma: mcomma,
  	Mcy: Mcy,
  	mcy: mcy,
  	mdash: mdash,
  	mDDot: mDDot,
  	measuredangle: measuredangle,
  	MediumSpace: MediumSpace,
  	Mellintrf: Mellintrf,
  	Mfr: Mfr,
  	mfr: mfr,
  	mho: mho,
  	micro: micro$1,
  	midast: midast,
  	midcir: midcir,
  	mid: mid,
  	middot: middot$1,
  	minusb: minusb,
  	minus: minus,
  	minusd: minusd,
  	minusdu: minusdu,
  	MinusPlus: MinusPlus,
  	mlcp: mlcp,
  	mldr: mldr,
  	mnplus: mnplus,
  	models: models,
  	Mopf: Mopf,
  	mopf: mopf,
  	mp: mp,
  	mscr: mscr,
  	Mscr: Mscr,
  	mstpos: mstpos,
  	Mu: Mu,
  	mu: mu,
  	multimap: multimap,
  	mumap: mumap,
  	nabla: nabla,
  	Nacute: Nacute,
  	nacute: nacute,
  	nang: nang,
  	nap: nap,
  	napE: napE,
  	napid: napid,
  	napos: napos,
  	napprox: napprox,
  	natural: natural,
  	naturals: naturals,
  	natur: natur,
  	nbsp: nbsp$1,
  	nbump: nbump,
  	nbumpe: nbumpe,
  	ncap: ncap,
  	Ncaron: Ncaron,
  	ncaron: ncaron,
  	Ncedil: Ncedil,
  	ncedil: ncedil,
  	ncong: ncong,
  	ncongdot: ncongdot,
  	ncup: ncup,
  	Ncy: Ncy,
  	ncy: ncy,
  	ndash: ndash,
  	nearhk: nearhk,
  	nearr: nearr,
  	neArr: neArr,
  	nearrow: nearrow,
  	ne: ne,
  	nedot: nedot,
  	NegativeMediumSpace: NegativeMediumSpace,
  	NegativeThickSpace: NegativeThickSpace,
  	NegativeThinSpace: NegativeThinSpace,
  	NegativeVeryThinSpace: NegativeVeryThinSpace,
  	nequiv: nequiv,
  	nesear: nesear,
  	nesim: nesim,
  	NestedGreaterGreater: NestedGreaterGreater,
  	NestedLessLess: NestedLessLess,
  	NewLine: NewLine,
  	nexist: nexist,
  	nexists: nexists,
  	Nfr: Nfr,
  	nfr: nfr,
  	ngE: ngE,
  	nge: nge,
  	ngeq: ngeq,
  	ngeqq: ngeqq,
  	ngeqslant: ngeqslant,
  	nges: nges,
  	nGg: nGg,
  	ngsim: ngsim,
  	nGt: nGt,
  	ngt: ngt,
  	ngtr: ngtr,
  	nGtv: nGtv,
  	nharr: nharr,
  	nhArr: nhArr,
  	nhpar: nhpar,
  	ni: ni,
  	nis: nis,
  	nisd: nisd,
  	niv: niv,
  	NJcy: NJcy,
  	njcy: njcy,
  	nlarr: nlarr,
  	nlArr: nlArr,
  	nldr: nldr,
  	nlE: nlE,
  	nle: nle,
  	nleftarrow: nleftarrow,
  	nLeftarrow: nLeftarrow,
  	nleftrightarrow: nleftrightarrow,
  	nLeftrightarrow: nLeftrightarrow,
  	nleq: nleq,
  	nleqq: nleqq,
  	nleqslant: nleqslant,
  	nles: nles,
  	nless: nless,
  	nLl: nLl,
  	nlsim: nlsim,
  	nLt: nLt,
  	nlt: nlt,
  	nltri: nltri,
  	nltrie: nltrie,
  	nLtv: nLtv,
  	nmid: nmid,
  	NoBreak: NoBreak,
  	NonBreakingSpace: NonBreakingSpace,
  	nopf: nopf,
  	Nopf: Nopf,
  	Not: Not,
  	not: not$1,
  	NotCongruent: NotCongruent,
  	NotCupCap: NotCupCap,
  	NotDoubleVerticalBar: NotDoubleVerticalBar,
  	NotElement: NotElement,
  	NotEqual: NotEqual,
  	NotEqualTilde: NotEqualTilde,
  	NotExists: NotExists,
  	NotGreater: NotGreater,
  	NotGreaterEqual: NotGreaterEqual,
  	NotGreaterFullEqual: NotGreaterFullEqual,
  	NotGreaterGreater: NotGreaterGreater,
  	NotGreaterLess: NotGreaterLess,
  	NotGreaterSlantEqual: NotGreaterSlantEqual,
  	NotGreaterTilde: NotGreaterTilde,
  	NotHumpDownHump: NotHumpDownHump,
  	NotHumpEqual: NotHumpEqual,
  	notin: notin,
  	notindot: notindot,
  	notinE: notinE,
  	notinva: notinva,
  	notinvb: notinvb,
  	notinvc: notinvc,
  	NotLeftTriangleBar: NotLeftTriangleBar,
  	NotLeftTriangle: NotLeftTriangle,
  	NotLeftTriangleEqual: NotLeftTriangleEqual,
  	NotLess: NotLess,
  	NotLessEqual: NotLessEqual,
  	NotLessGreater: NotLessGreater,
  	NotLessLess: NotLessLess,
  	NotLessSlantEqual: NotLessSlantEqual,
  	NotLessTilde: NotLessTilde,
  	NotNestedGreaterGreater: NotNestedGreaterGreater,
  	NotNestedLessLess: NotNestedLessLess,
  	notni: notni,
  	notniva: notniva,
  	notnivb: notnivb,
  	notnivc: notnivc,
  	NotPrecedes: NotPrecedes,
  	NotPrecedesEqual: NotPrecedesEqual,
  	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
  	NotReverseElement: NotReverseElement,
  	NotRightTriangleBar: NotRightTriangleBar,
  	NotRightTriangle: NotRightTriangle,
  	NotRightTriangleEqual: NotRightTriangleEqual,
  	NotSquareSubset: NotSquareSubset,
  	NotSquareSubsetEqual: NotSquareSubsetEqual,
  	NotSquareSuperset: NotSquareSuperset,
  	NotSquareSupersetEqual: NotSquareSupersetEqual,
  	NotSubset: NotSubset,
  	NotSubsetEqual: NotSubsetEqual,
  	NotSucceeds: NotSucceeds,
  	NotSucceedsEqual: NotSucceedsEqual,
  	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
  	NotSucceedsTilde: NotSucceedsTilde,
  	NotSuperset: NotSuperset,
  	NotSupersetEqual: NotSupersetEqual,
  	NotTilde: NotTilde,
  	NotTildeEqual: NotTildeEqual,
  	NotTildeFullEqual: NotTildeFullEqual,
  	NotTildeTilde: NotTildeTilde,
  	NotVerticalBar: NotVerticalBar,
  	nparallel: nparallel,
  	npar: npar,
  	nparsl: nparsl,
  	npart: npart,
  	npolint: npolint,
  	npr: npr,
  	nprcue: nprcue,
  	nprec: nprec,
  	npreceq: npreceq,
  	npre: npre,
  	nrarrc: nrarrc,
  	nrarr: nrarr,
  	nrArr: nrArr,
  	nrarrw: nrarrw,
  	nrightarrow: nrightarrow,
  	nRightarrow: nRightarrow,
  	nrtri: nrtri,
  	nrtrie: nrtrie,
  	nsc: nsc,
  	nsccue: nsccue,
  	nsce: nsce,
  	Nscr: Nscr,
  	nscr: nscr,
  	nshortmid: nshortmid,
  	nshortparallel: nshortparallel,
  	nsim: nsim,
  	nsime: nsime,
  	nsimeq: nsimeq,
  	nsmid: nsmid,
  	nspar: nspar,
  	nsqsube: nsqsube,
  	nsqsupe: nsqsupe,
  	nsub: nsub,
  	nsubE: nsubE,
  	nsube: nsube,
  	nsubset: nsubset,
  	nsubseteq: nsubseteq,
  	nsubseteqq: nsubseteqq,
  	nsucc: nsucc,
  	nsucceq: nsucceq,
  	nsup: nsup,
  	nsupE: nsupE,
  	nsupe: nsupe,
  	nsupset: nsupset,
  	nsupseteq: nsupseteq,
  	nsupseteqq: nsupseteqq,
  	ntgl: ntgl,
  	Ntilde: Ntilde$1,
  	ntilde: ntilde$1,
  	ntlg: ntlg,
  	ntriangleleft: ntriangleleft,
  	ntrianglelefteq: ntrianglelefteq,
  	ntriangleright: ntriangleright,
  	ntrianglerighteq: ntrianglerighteq,
  	Nu: Nu,
  	nu: nu,
  	num: num,
  	numero: numero,
  	numsp: numsp,
  	nvap: nvap,
  	nvdash: nvdash,
  	nvDash: nvDash,
  	nVdash: nVdash,
  	nVDash: nVDash,
  	nvge: nvge,
  	nvgt: nvgt,
  	nvHarr: nvHarr,
  	nvinfin: nvinfin,
  	nvlArr: nvlArr,
  	nvle: nvle,
  	nvlt: nvlt,
  	nvltrie: nvltrie,
  	nvrArr: nvrArr,
  	nvrtrie: nvrtrie,
  	nvsim: nvsim,
  	nwarhk: nwarhk,
  	nwarr: nwarr,
  	nwArr: nwArr,
  	nwarrow: nwarrow,
  	nwnear: nwnear,
  	Oacute: Oacute$1,
  	oacute: oacute$1,
  	oast: oast,
  	Ocirc: Ocirc$1,
  	ocirc: ocirc$1,
  	ocir: ocir,
  	Ocy: Ocy,
  	ocy: ocy,
  	odash: odash,
  	Odblac: Odblac,
  	odblac: odblac,
  	odiv: odiv,
  	odot: odot,
  	odsold: odsold,
  	OElig: OElig,
  	oelig: oelig,
  	ofcir: ofcir,
  	Ofr: Ofr,
  	ofr: ofr,
  	ogon: ogon,
  	Ograve: Ograve$1,
  	ograve: ograve$1,
  	ogt: ogt,
  	ohbar: ohbar,
  	ohm: ohm,
  	oint: oint,
  	olarr: olarr,
  	olcir: olcir,
  	olcross: olcross,
  	oline: oline,
  	olt: olt,
  	Omacr: Omacr,
  	omacr: omacr,
  	Omega: Omega,
  	omega: omega,
  	Omicron: Omicron,
  	omicron: omicron,
  	omid: omid,
  	ominus: ominus,
  	Oopf: Oopf,
  	oopf: oopf,
  	opar: opar,
  	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
  	OpenCurlyQuote: OpenCurlyQuote,
  	operp: operp,
  	oplus: oplus,
  	orarr: orarr,
  	Or: Or,
  	or: or,
  	ord: ord,
  	order: order,
  	orderof: orderof,
  	ordf: ordf$1,
  	ordm: ordm$1,
  	origof: origof,
  	oror: oror,
  	orslope: orslope,
  	orv: orv,
  	oS: oS,
  	Oscr: Oscr,
  	oscr: oscr,
  	Oslash: Oslash$1,
  	oslash: oslash$1,
  	osol: osol,
  	Otilde: Otilde$1,
  	otilde: otilde$1,
  	otimesas: otimesas,
  	Otimes: Otimes,
  	otimes: otimes,
  	Ouml: Ouml$1,
  	ouml: ouml$1,
  	ovbar: ovbar,
  	OverBar: OverBar,
  	OverBrace: OverBrace,
  	OverBracket: OverBracket,
  	OverParenthesis: OverParenthesis,
  	para: para$1,
  	parallel: parallel,
  	par: par,
  	parsim: parsim,
  	parsl: parsl,
  	part: part,
  	PartialD: PartialD,
  	Pcy: Pcy,
  	pcy: pcy,
  	percnt: percnt,
  	period: period,
  	permil: permil,
  	perp: perp,
  	pertenk: pertenk,
  	Pfr: Pfr,
  	pfr: pfr,
  	Phi: Phi,
  	phi: phi,
  	phiv: phiv,
  	phmmat: phmmat,
  	phone: phone,
  	Pi: Pi,
  	pi: pi,
  	pitchfork: pitchfork,
  	piv: piv,
  	planck: planck,
  	planckh: planckh,
  	plankv: plankv,
  	plusacir: plusacir,
  	plusb: plusb,
  	pluscir: pluscir,
  	plus: plus,
  	plusdo: plusdo,
  	plusdu: plusdu,
  	pluse: pluse,
  	PlusMinus: PlusMinus,
  	plusmn: plusmn$1,
  	plussim: plussim,
  	plustwo: plustwo,
  	pm: pm,
  	Poincareplane: Poincareplane,
  	pointint: pointint,
  	popf: popf,
  	Popf: Popf,
  	pound: pound$1,
  	prap: prap,
  	Pr: Pr,
  	pr: pr,
  	prcue: prcue,
  	precapprox: precapprox,
  	prec: prec,
  	preccurlyeq: preccurlyeq,
  	Precedes: Precedes,
  	PrecedesEqual: PrecedesEqual,
  	PrecedesSlantEqual: PrecedesSlantEqual,
  	PrecedesTilde: PrecedesTilde,
  	preceq: preceq,
  	precnapprox: precnapprox,
  	precneqq: precneqq,
  	precnsim: precnsim,
  	pre: pre,
  	prE: prE,
  	precsim: precsim,
  	prime: prime,
  	Prime: Prime,
  	primes: primes,
  	prnap: prnap,
  	prnE: prnE,
  	prnsim: prnsim,
  	prod: prod,
  	Product: Product,
  	profalar: profalar,
  	profline: profline,
  	profsurf: profsurf,
  	prop: prop,
  	Proportional: Proportional,
  	Proportion: Proportion,
  	propto: propto,
  	prsim: prsim,
  	prurel: prurel,
  	Pscr: Pscr,
  	pscr: pscr,
  	Psi: Psi,
  	psi: psi,
  	puncsp: puncsp,
  	Qfr: Qfr,
  	qfr: qfr,
  	qint: qint,
  	qopf: qopf,
  	Qopf: Qopf,
  	qprime: qprime,
  	Qscr: Qscr,
  	qscr: qscr,
  	quaternions: quaternions,
  	quatint: quatint,
  	quest: quest,
  	questeq: questeq,
  	quot: quot$2,
  	QUOT: QUOT$1,
  	rAarr: rAarr,
  	race: race,
  	Racute: Racute,
  	racute: racute,
  	radic: radic,
  	raemptyv: raemptyv,
  	rang: rang,
  	Rang: Rang,
  	rangd: rangd,
  	range: range,
  	rangle: rangle,
  	raquo: raquo$1,
  	rarrap: rarrap,
  	rarrb: rarrb,
  	rarrbfs: rarrbfs,
  	rarrc: rarrc,
  	rarr: rarr,
  	Rarr: Rarr,
  	rArr: rArr,
  	rarrfs: rarrfs,
  	rarrhk: rarrhk,
  	rarrlp: rarrlp,
  	rarrpl: rarrpl,
  	rarrsim: rarrsim,
  	Rarrtl: Rarrtl,
  	rarrtl: rarrtl,
  	rarrw: rarrw,
  	ratail: ratail,
  	rAtail: rAtail,
  	ratio: ratio,
  	rationals: rationals,
  	rbarr: rbarr,
  	rBarr: rBarr,
  	RBarr: RBarr,
  	rbbrk: rbbrk,
  	rbrace: rbrace,
  	rbrack: rbrack,
  	rbrke: rbrke,
  	rbrksld: rbrksld,
  	rbrkslu: rbrkslu,
  	Rcaron: Rcaron,
  	rcaron: rcaron,
  	Rcedil: Rcedil,
  	rcedil: rcedil,
  	rceil: rceil,
  	rcub: rcub,
  	Rcy: Rcy,
  	rcy: rcy,
  	rdca: rdca,
  	rdldhar: rdldhar,
  	rdquo: rdquo,
  	rdquor: rdquor,
  	rdsh: rdsh,
  	real: real,
  	realine: realine,
  	realpart: realpart,
  	reals: reals,
  	Re: Re,
  	rect: rect,
  	reg: reg$1,
  	REG: REG$1,
  	ReverseElement: ReverseElement,
  	ReverseEquilibrium: ReverseEquilibrium,
  	ReverseUpEquilibrium: ReverseUpEquilibrium,
  	rfisht: rfisht,
  	rfloor: rfloor,
  	rfr: rfr,
  	Rfr: Rfr,
  	rHar: rHar,
  	rhard: rhard,
  	rharu: rharu,
  	rharul: rharul,
  	Rho: Rho,
  	rho: rho,
  	rhov: rhov,
  	RightAngleBracket: RightAngleBracket,
  	RightArrowBar: RightArrowBar,
  	rightarrow: rightarrow,
  	RightArrow: RightArrow,
  	Rightarrow: Rightarrow,
  	RightArrowLeftArrow: RightArrowLeftArrow,
  	rightarrowtail: rightarrowtail,
  	RightCeiling: RightCeiling,
  	RightDoubleBracket: RightDoubleBracket,
  	RightDownTeeVector: RightDownTeeVector,
  	RightDownVectorBar: RightDownVectorBar,
  	RightDownVector: RightDownVector,
  	RightFloor: RightFloor,
  	rightharpoondown: rightharpoondown,
  	rightharpoonup: rightharpoonup,
  	rightleftarrows: rightleftarrows,
  	rightleftharpoons: rightleftharpoons,
  	rightrightarrows: rightrightarrows,
  	rightsquigarrow: rightsquigarrow,
  	RightTeeArrow: RightTeeArrow,
  	RightTee: RightTee,
  	RightTeeVector: RightTeeVector,
  	rightthreetimes: rightthreetimes,
  	RightTriangleBar: RightTriangleBar,
  	RightTriangle: RightTriangle,
  	RightTriangleEqual: RightTriangleEqual,
  	RightUpDownVector: RightUpDownVector,
  	RightUpTeeVector: RightUpTeeVector,
  	RightUpVectorBar: RightUpVectorBar,
  	RightUpVector: RightUpVector,
  	RightVectorBar: RightVectorBar,
  	RightVector: RightVector,
  	ring: ring,
  	risingdotseq: risingdotseq,
  	rlarr: rlarr,
  	rlhar: rlhar,
  	rlm: rlm,
  	rmoustache: rmoustache,
  	rmoust: rmoust,
  	rnmid: rnmid,
  	roang: roang,
  	roarr: roarr,
  	robrk: robrk,
  	ropar: ropar,
  	ropf: ropf,
  	Ropf: Ropf,
  	roplus: roplus,
  	rotimes: rotimes,
  	RoundImplies: RoundImplies,
  	rpar: rpar,
  	rpargt: rpargt,
  	rppolint: rppolint,
  	rrarr: rrarr,
  	Rrightarrow: Rrightarrow,
  	rsaquo: rsaquo,
  	rscr: rscr,
  	Rscr: Rscr,
  	rsh: rsh,
  	Rsh: Rsh,
  	rsqb: rsqb,
  	rsquo: rsquo,
  	rsquor: rsquor,
  	rthree: rthree,
  	rtimes: rtimes,
  	rtri: rtri,
  	rtrie: rtrie,
  	rtrif: rtrif,
  	rtriltri: rtriltri,
  	RuleDelayed: RuleDelayed,
  	ruluhar: ruluhar,
  	rx: rx,
  	Sacute: Sacute,
  	sacute: sacute,
  	sbquo: sbquo,
  	scap: scap,
  	Scaron: Scaron,
  	scaron: scaron,
  	Sc: Sc,
  	sc: sc,
  	sccue: sccue,
  	sce: sce,
  	scE: scE,
  	Scedil: Scedil,
  	scedil: scedil,
  	Scirc: Scirc,
  	scirc: scirc,
  	scnap: scnap,
  	scnE: scnE,
  	scnsim: scnsim,
  	scpolint: scpolint,
  	scsim: scsim,
  	Scy: Scy,
  	scy: scy,
  	sdotb: sdotb,
  	sdot: sdot,
  	sdote: sdote,
  	searhk: searhk,
  	searr: searr,
  	seArr: seArr,
  	searrow: searrow,
  	sect: sect$1,
  	semi: semi,
  	seswar: seswar,
  	setminus: setminus,
  	setmn: setmn,
  	sext: sext,
  	Sfr: Sfr,
  	sfr: sfr,
  	sfrown: sfrown,
  	sharp: sharp,
  	SHCHcy: SHCHcy,
  	shchcy: shchcy,
  	SHcy: SHcy,
  	shcy: shcy,
  	ShortDownArrow: ShortDownArrow,
  	ShortLeftArrow: ShortLeftArrow,
  	shortmid: shortmid,
  	shortparallel: shortparallel,
  	ShortRightArrow: ShortRightArrow,
  	ShortUpArrow: ShortUpArrow,
  	shy: shy$1,
  	Sigma: Sigma,
  	sigma: sigma,
  	sigmaf: sigmaf,
  	sigmav: sigmav,
  	sim: sim,
  	simdot: simdot,
  	sime: sime,
  	simeq: simeq,
  	simg: simg,
  	simgE: simgE,
  	siml: siml,
  	simlE: simlE,
  	simne: simne,
  	simplus: simplus,
  	simrarr: simrarr,
  	slarr: slarr,
  	SmallCircle: SmallCircle,
  	smallsetminus: smallsetminus,
  	smashp: smashp,
  	smeparsl: smeparsl,
  	smid: smid,
  	smile: smile,
  	smt: smt,
  	smte: smte,
  	smtes: smtes,
  	SOFTcy: SOFTcy,
  	softcy: softcy,
  	solbar: solbar,
  	solb: solb,
  	sol: sol,
  	Sopf: Sopf,
  	sopf: sopf,
  	spades: spades,
  	spadesuit: spadesuit,
  	spar: spar,
  	sqcap: sqcap,
  	sqcaps: sqcaps,
  	sqcup: sqcup,
  	sqcups: sqcups,
  	Sqrt: Sqrt,
  	sqsub: sqsub,
  	sqsube: sqsube,
  	sqsubset: sqsubset,
  	sqsubseteq: sqsubseteq,
  	sqsup: sqsup,
  	sqsupe: sqsupe,
  	sqsupset: sqsupset,
  	sqsupseteq: sqsupseteq,
  	square: square,
  	Square: Square,
  	SquareIntersection: SquareIntersection,
  	SquareSubset: SquareSubset,
  	SquareSubsetEqual: SquareSubsetEqual,
  	SquareSuperset: SquareSuperset,
  	SquareSupersetEqual: SquareSupersetEqual,
  	SquareUnion: SquareUnion,
  	squarf: squarf,
  	squ: squ,
  	squf: squf,
  	srarr: srarr,
  	Sscr: Sscr,
  	sscr: sscr,
  	ssetmn: ssetmn,
  	ssmile: ssmile,
  	sstarf: sstarf,
  	Star: Star,
  	star: star,
  	starf: starf,
  	straightepsilon: straightepsilon,
  	straightphi: straightphi,
  	strns: strns,
  	sub: sub,
  	Sub: Sub,
  	subdot: subdot,
  	subE: subE,
  	sube: sube,
  	subedot: subedot,
  	submult: submult,
  	subnE: subnE,
  	subne: subne,
  	subplus: subplus,
  	subrarr: subrarr,
  	subset: subset,
  	Subset: Subset,
  	subseteq: subseteq,
  	subseteqq: subseteqq,
  	SubsetEqual: SubsetEqual,
  	subsetneq: subsetneq,
  	subsetneqq: subsetneqq,
  	subsim: subsim,
  	subsub: subsub,
  	subsup: subsup,
  	succapprox: succapprox,
  	succ: succ,
  	succcurlyeq: succcurlyeq,
  	Succeeds: Succeeds,
  	SucceedsEqual: SucceedsEqual,
  	SucceedsSlantEqual: SucceedsSlantEqual,
  	SucceedsTilde: SucceedsTilde,
  	succeq: succeq,
  	succnapprox: succnapprox,
  	succneqq: succneqq,
  	succnsim: succnsim,
  	succsim: succsim,
  	SuchThat: SuchThat,
  	sum: sum,
  	Sum: Sum,
  	sung: sung,
  	sup1: sup1$1,
  	sup2: sup2$1,
  	sup3: sup3$1,
  	sup: sup,
  	Sup: Sup,
  	supdot: supdot,
  	supdsub: supdsub,
  	supE: supE,
  	supe: supe,
  	supedot: supedot,
  	Superset: Superset,
  	SupersetEqual: SupersetEqual,
  	suphsol: suphsol,
  	suphsub: suphsub,
  	suplarr: suplarr,
  	supmult: supmult,
  	supnE: supnE,
  	supne: supne,
  	supplus: supplus,
  	supset: supset,
  	Supset: Supset,
  	supseteq: supseteq,
  	supseteqq: supseteqq,
  	supsetneq: supsetneq,
  	supsetneqq: supsetneqq,
  	supsim: supsim,
  	supsub: supsub,
  	supsup: supsup,
  	swarhk: swarhk,
  	swarr: swarr,
  	swArr: swArr,
  	swarrow: swarrow,
  	swnwar: swnwar,
  	szlig: szlig$1,
  	Tab: Tab,
  	target: target,
  	Tau: Tau,
  	tau: tau,
  	tbrk: tbrk,
  	Tcaron: Tcaron,
  	tcaron: tcaron,
  	Tcedil: Tcedil,
  	tcedil: tcedil,
  	Tcy: Tcy,
  	tcy: tcy,
  	tdot: tdot,
  	telrec: telrec,
  	Tfr: Tfr,
  	tfr: tfr,
  	there4: there4,
  	therefore: therefore,
  	Therefore: Therefore,
  	Theta: Theta,
  	theta: theta,
  	thetasym: thetasym,
  	thetav: thetav,
  	thickapprox: thickapprox,
  	thicksim: thicksim,
  	ThickSpace: ThickSpace,
  	ThinSpace: ThinSpace,
  	thinsp: thinsp,
  	thkap: thkap,
  	thksim: thksim,
  	THORN: THORN$1,
  	thorn: thorn$1,
  	tilde: tilde,
  	Tilde: Tilde,
  	TildeEqual: TildeEqual,
  	TildeFullEqual: TildeFullEqual,
  	TildeTilde: TildeTilde,
  	timesbar: timesbar,
  	timesb: timesb,
  	times: times$1,
  	timesd: timesd,
  	tint: tint,
  	toea: toea,
  	topbot: topbot,
  	topcir: topcir,
  	top: top,
  	Topf: Topf,
  	topf: topf,
  	topfork: topfork,
  	tosa: tosa,
  	tprime: tprime,
  	trade: trade,
  	TRADE: TRADE,
  	triangle: triangle,
  	triangledown: triangledown,
  	triangleleft: triangleleft,
  	trianglelefteq: trianglelefteq,
  	triangleq: triangleq,
  	triangleright: triangleright,
  	trianglerighteq: trianglerighteq,
  	tridot: tridot,
  	trie: trie,
  	triminus: triminus,
  	TripleDot: TripleDot,
  	triplus: triplus,
  	trisb: trisb,
  	tritime: tritime,
  	trpezium: trpezium,
  	Tscr: Tscr,
  	tscr: tscr,
  	TScy: TScy,
  	tscy: tscy,
  	TSHcy: TSHcy,
  	tshcy: tshcy,
  	Tstrok: Tstrok,
  	tstrok: tstrok,
  	twixt: twixt,
  	twoheadleftarrow: twoheadleftarrow,
  	twoheadrightarrow: twoheadrightarrow,
  	Uacute: Uacute$1,
  	uacute: uacute$1,
  	uarr: uarr,
  	Uarr: Uarr,
  	uArr: uArr,
  	Uarrocir: Uarrocir,
  	Ubrcy: Ubrcy,
  	ubrcy: ubrcy,
  	Ubreve: Ubreve,
  	ubreve: ubreve,
  	Ucirc: Ucirc$1,
  	ucirc: ucirc$1,
  	Ucy: Ucy,
  	ucy: ucy,
  	udarr: udarr,
  	Udblac: Udblac,
  	udblac: udblac,
  	udhar: udhar,
  	ufisht: ufisht,
  	Ufr: Ufr,
  	ufr: ufr,
  	Ugrave: Ugrave$1,
  	ugrave: ugrave$1,
  	uHar: uHar,
  	uharl: uharl,
  	uharr: uharr,
  	uhblk: uhblk,
  	ulcorn: ulcorn,
  	ulcorner: ulcorner,
  	ulcrop: ulcrop,
  	ultri: ultri,
  	Umacr: Umacr,
  	umacr: umacr,
  	uml: uml$1,
  	UnderBar: UnderBar,
  	UnderBrace: UnderBrace,
  	UnderBracket: UnderBracket,
  	UnderParenthesis: UnderParenthesis,
  	Union: Union,
  	UnionPlus: UnionPlus,
  	Uogon: Uogon,
  	uogon: uogon,
  	Uopf: Uopf,
  	uopf: uopf,
  	UpArrowBar: UpArrowBar,
  	uparrow: uparrow,
  	UpArrow: UpArrow,
  	Uparrow: Uparrow,
  	UpArrowDownArrow: UpArrowDownArrow,
  	updownarrow: updownarrow,
  	UpDownArrow: UpDownArrow,
  	Updownarrow: Updownarrow,
  	UpEquilibrium: UpEquilibrium,
  	upharpoonleft: upharpoonleft,
  	upharpoonright: upharpoonright,
  	uplus: uplus,
  	UpperLeftArrow: UpperLeftArrow,
  	UpperRightArrow: UpperRightArrow,
  	upsi: upsi,
  	Upsi: Upsi,
  	upsih: upsih,
  	Upsilon: Upsilon,
  	upsilon: upsilon,
  	UpTeeArrow: UpTeeArrow,
  	UpTee: UpTee,
  	upuparrows: upuparrows,
  	urcorn: urcorn,
  	urcorner: urcorner,
  	urcrop: urcrop,
  	Uring: Uring,
  	uring: uring,
  	urtri: urtri,
  	Uscr: Uscr,
  	uscr: uscr,
  	utdot: utdot,
  	Utilde: Utilde,
  	utilde: utilde,
  	utri: utri,
  	utrif: utrif,
  	uuarr: uuarr,
  	Uuml: Uuml$1,
  	uuml: uuml$1,
  	uwangle: uwangle,
  	vangrt: vangrt,
  	varepsilon: varepsilon,
  	varkappa: varkappa,
  	varnothing: varnothing,
  	varphi: varphi,
  	varpi: varpi,
  	varpropto: varpropto,
  	varr: varr,
  	vArr: vArr,
  	varrho: varrho,
  	varsigma: varsigma,
  	varsubsetneq: varsubsetneq,
  	varsubsetneqq: varsubsetneqq,
  	varsupsetneq: varsupsetneq,
  	varsupsetneqq: varsupsetneqq,
  	vartheta: vartheta,
  	vartriangleleft: vartriangleleft,
  	vartriangleright: vartriangleright,
  	vBar: vBar,
  	Vbar: Vbar,
  	vBarv: vBarv,
  	Vcy: Vcy,
  	vcy: vcy,
  	vdash: vdash,
  	vDash: vDash,
  	Vdash: Vdash,
  	VDash: VDash,
  	Vdashl: Vdashl,
  	veebar: veebar,
  	vee: vee,
  	Vee: Vee,
  	veeeq: veeeq,
  	vellip: vellip,
  	verbar: verbar,
  	Verbar: Verbar,
  	vert: vert,
  	Vert: Vert,
  	VerticalBar: VerticalBar,
  	VerticalLine: VerticalLine,
  	VerticalSeparator: VerticalSeparator,
  	VerticalTilde: VerticalTilde,
  	VeryThinSpace: VeryThinSpace,
  	Vfr: Vfr,
  	vfr: vfr,
  	vltri: vltri,
  	vnsub: vnsub,
  	vnsup: vnsup,
  	Vopf: Vopf,
  	vopf: vopf,
  	vprop: vprop,
  	vrtri: vrtri,
  	Vscr: Vscr,
  	vscr: vscr,
  	vsubnE: vsubnE,
  	vsubne: vsubne,
  	vsupnE: vsupnE,
  	vsupne: vsupne,
  	Vvdash: Vvdash,
  	vzigzag: vzigzag,
  	Wcirc: Wcirc,
  	wcirc: wcirc,
  	wedbar: wedbar,
  	wedge: wedge,
  	Wedge: Wedge,
  	wedgeq: wedgeq,
  	weierp: weierp,
  	Wfr: Wfr,
  	wfr: wfr,
  	Wopf: Wopf,
  	wopf: wopf,
  	wp: wp,
  	wr: wr,
  	wreath: wreath,
  	Wscr: Wscr,
  	wscr: wscr,
  	xcap: xcap,
  	xcirc: xcirc,
  	xcup: xcup,
  	xdtri: xdtri,
  	Xfr: Xfr,
  	xfr: xfr,
  	xharr: xharr,
  	xhArr: xhArr,
  	Xi: Xi,
  	xi: xi,
  	xlarr: xlarr,
  	xlArr: xlArr,
  	xmap: xmap,
  	xnis: xnis,
  	xodot: xodot,
  	Xopf: Xopf,
  	xopf: xopf,
  	xoplus: xoplus,
  	xotime: xotime,
  	xrarr: xrarr,
  	xrArr: xrArr,
  	Xscr: Xscr,
  	xscr: xscr,
  	xsqcup: xsqcup,
  	xuplus: xuplus,
  	xutri: xutri,
  	xvee: xvee,
  	xwedge: xwedge,
  	Yacute: Yacute$1,
  	yacute: yacute$1,
  	YAcy: YAcy,
  	yacy: yacy,
  	Ycirc: Ycirc,
  	ycirc: ycirc,
  	Ycy: Ycy,
  	ycy: ycy,
  	yen: yen$1,
  	Yfr: Yfr,
  	yfr: yfr,
  	YIcy: YIcy,
  	yicy: yicy,
  	Yopf: Yopf,
  	yopf: yopf,
  	Yscr: Yscr,
  	yscr: yscr,
  	YUcy: YUcy,
  	yucy: yucy,
  	yuml: yuml$1,
  	Yuml: Yuml,
  	Zacute: Zacute,
  	zacute: zacute,
  	Zcaron: Zcaron,
  	zcaron: zcaron,
  	Zcy: Zcy,
  	zcy: zcy,
  	Zdot: Zdot,
  	zdot: zdot,
  	zeetrf: zeetrf,
  	ZeroWidthSpace: ZeroWidthSpace,
  	Zeta: Zeta,
  	zeta: zeta,
  	zfr: zfr,
  	Zfr: Zfr,
  	ZHcy: ZHcy,
  	zhcy: zhcy,
  	zigrarr: zigrarr,
  	zopf: zopf,
  	Zopf: Zopf,
  	Zscr: Zscr,
  	zscr: zscr,
  	zwj: zwj,
  	zwnj: zwnj
  };

  var entities$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Aacute: Aacute$1,
    aacute: aacute$1,
    Abreve: Abreve,
    abreve: abreve,
    ac: ac,
    acd: acd,
    acE: acE,
    Acirc: Acirc$1,
    acirc: acirc$1,
    acute: acute$1,
    Acy: Acy,
    acy: acy,
    AElig: AElig$1,
    aelig: aelig$1,
    af: af,
    Afr: Afr,
    afr: afr,
    Agrave: Agrave$1,
    agrave: agrave$1,
    alefsym: alefsym,
    aleph: aleph,
    Alpha: Alpha,
    alpha: alpha,
    Amacr: Amacr,
    amacr: amacr,
    amalg: amalg,
    amp: amp$2,
    AMP: AMP$1,
    andand: andand,
    And: And,
    and: and,
    andd: andd,
    andslope: andslope,
    andv: andv,
    ang: ang,
    ange: ange,
    angle: angle,
    angmsdaa: angmsdaa,
    angmsdab: angmsdab,
    angmsdac: angmsdac,
    angmsdad: angmsdad,
    angmsdae: angmsdae,
    angmsdaf: angmsdaf,
    angmsdag: angmsdag,
    angmsdah: angmsdah,
    angmsd: angmsd,
    angrt: angrt,
    angrtvb: angrtvb,
    angrtvbd: angrtvbd,
    angsph: angsph,
    angst: angst,
    angzarr: angzarr,
    Aogon: Aogon,
    aogon: aogon,
    Aopf: Aopf,
    aopf: aopf,
    apacir: apacir,
    ap: ap,
    apE: apE,
    ape: ape,
    apid: apid,
    apos: apos$1,
    ApplyFunction: ApplyFunction,
    approx: approx,
    approxeq: approxeq,
    Aring: Aring$1,
    aring: aring$1,
    Ascr: Ascr,
    ascr: ascr,
    Assign: Assign,
    ast: ast,
    asymp: asymp,
    asympeq: asympeq,
    Atilde: Atilde$1,
    atilde: atilde$1,
    Auml: Auml$1,
    auml: auml$1,
    awconint: awconint,
    awint: awint,
    backcong: backcong,
    backepsilon: backepsilon,
    backprime: backprime,
    backsim: backsim,
    backsimeq: backsimeq,
    Backslash: Backslash,
    Barv: Barv,
    barvee: barvee,
    barwed: barwed,
    Barwed: Barwed,
    barwedge: barwedge,
    bbrk: bbrk,
    bbrktbrk: bbrktbrk,
    bcong: bcong,
    Bcy: Bcy,
    bcy: bcy,
    bdquo: bdquo,
    becaus: becaus,
    because: because,
    Because: Because,
    bemptyv: bemptyv,
    bepsi: bepsi,
    bernou: bernou,
    Bernoullis: Bernoullis,
    Beta: Beta,
    beta: beta,
    beth: beth,
    between: between,
    Bfr: Bfr,
    bfr: bfr,
    bigcap: bigcap,
    bigcirc: bigcirc,
    bigcup: bigcup,
    bigodot: bigodot,
    bigoplus: bigoplus,
    bigotimes: bigotimes,
    bigsqcup: bigsqcup,
    bigstar: bigstar,
    bigtriangledown: bigtriangledown,
    bigtriangleup: bigtriangleup,
    biguplus: biguplus,
    bigvee: bigvee,
    bigwedge: bigwedge,
    bkarow: bkarow,
    blacklozenge: blacklozenge,
    blacksquare: blacksquare,
    blacktriangle: blacktriangle,
    blacktriangledown: blacktriangledown,
    blacktriangleleft: blacktriangleleft,
    blacktriangleright: blacktriangleright,
    blank: blank,
    blk12: blk12,
    blk14: blk14,
    blk34: blk34,
    block: block,
    bne: bne,
    bnequiv: bnequiv,
    bNot: bNot,
    bnot: bnot,
    Bopf: Bopf,
    bopf: bopf,
    bot: bot,
    bottom: bottom,
    bowtie: bowtie,
    boxbox: boxbox,
    boxdl: boxdl,
    boxdL: boxdL,
    boxDl: boxDl,
    boxDL: boxDL,
    boxdr: boxdr,
    boxdR: boxdR,
    boxDr: boxDr,
    boxDR: boxDR,
    boxh: boxh,
    boxH: boxH,
    boxhd: boxhd,
    boxHd: boxHd,
    boxhD: boxhD,
    boxHD: boxHD,
    boxhu: boxhu,
    boxHu: boxHu,
    boxhU: boxhU,
    boxHU: boxHU,
    boxminus: boxminus,
    boxplus: boxplus,
    boxtimes: boxtimes,
    boxul: boxul,
    boxuL: boxuL,
    boxUl: boxUl,
    boxUL: boxUL,
    boxur: boxur,
    boxuR: boxuR,
    boxUr: boxUr,
    boxUR: boxUR,
    boxv: boxv,
    boxV: boxV,
    boxvh: boxvh,
    boxvH: boxvH,
    boxVh: boxVh,
    boxVH: boxVH,
    boxvl: boxvl,
    boxvL: boxvL,
    boxVl: boxVl,
    boxVL: boxVL,
    boxvr: boxvr,
    boxvR: boxvR,
    boxVr: boxVr,
    boxVR: boxVR,
    bprime: bprime,
    breve: breve,
    Breve: Breve,
    brvbar: brvbar$1,
    bscr: bscr,
    Bscr: Bscr,
    bsemi: bsemi,
    bsim: bsim,
    bsime: bsime,
    bsolb: bsolb,
    bsol: bsol,
    bsolhsub: bsolhsub,
    bull: bull,
    bullet: bullet,
    bump: bump,
    bumpE: bumpE,
    bumpe: bumpe,
    Bumpeq: Bumpeq,
    bumpeq: bumpeq,
    Cacute: Cacute,
    cacute: cacute,
    capand: capand,
    capbrcup: capbrcup,
    capcap: capcap,
    cap: cap,
    Cap: Cap,
    capcup: capcup,
    capdot: capdot,
    CapitalDifferentialD: CapitalDifferentialD,
    caps: caps,
    caret: caret,
    caron: caron,
    Cayleys: Cayleys,
    ccaps: ccaps,
    Ccaron: Ccaron,
    ccaron: ccaron,
    Ccedil: Ccedil$1,
    ccedil: ccedil$1,
    Ccirc: Ccirc,
    ccirc: ccirc,
    Cconint: Cconint,
    ccups: ccups,
    ccupssm: ccupssm,
    Cdot: Cdot,
    cdot: cdot,
    cedil: cedil$1,
    Cedilla: Cedilla,
    cemptyv: cemptyv,
    cent: cent$1,
    centerdot: centerdot,
    CenterDot: CenterDot,
    cfr: cfr,
    Cfr: Cfr,
    CHcy: CHcy,
    chcy: chcy,
    check: check,
    checkmark: checkmark,
    Chi: Chi,
    chi: chi,
    circ: circ,
    circeq: circeq,
    circlearrowleft: circlearrowleft,
    circlearrowright: circlearrowright,
    circledast: circledast,
    circledcirc: circledcirc,
    circleddash: circleddash,
    CircleDot: CircleDot,
    circledR: circledR,
    circledS: circledS,
    CircleMinus: CircleMinus,
    CirclePlus: CirclePlus,
    CircleTimes: CircleTimes,
    cir: cir,
    cirE: cirE,
    cire: cire,
    cirfnint: cirfnint,
    cirmid: cirmid,
    cirscir: cirscir,
    ClockwiseContourIntegral: ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    CloseCurlyQuote: CloseCurlyQuote,
    clubs: clubs,
    clubsuit: clubsuit,
    colon: colon,
    Colon: Colon,
    Colone: Colone,
    colone: colone,
    coloneq: coloneq,
    comma: comma,
    commat: commat,
    comp: comp,
    compfn: compfn,
    complement: complement,
    complexes: complexes,
    cong: cong,
    congdot: congdot,
    Congruent: Congruent,
    conint: conint,
    Conint: Conint,
    ContourIntegral: ContourIntegral,
    copf: copf,
    Copf: Copf,
    coprod: coprod,
    Coproduct: Coproduct,
    copy: copy$1,
    COPY: COPY$1,
    copysr: copysr,
    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    crarr: crarr,
    cross: cross,
    Cross: Cross,
    Cscr: Cscr,
    cscr: cscr,
    csub: csub,
    csube: csube,
    csup: csup,
    csupe: csupe,
    ctdot: ctdot,
    cudarrl: cudarrl,
    cudarrr: cudarrr,
    cuepr: cuepr,
    cuesc: cuesc,
    cularr: cularr,
    cularrp: cularrp,
    cupbrcap: cupbrcap,
    cupcap: cupcap,
    CupCap: CupCap,
    cup: cup,
    Cup: Cup,
    cupcup: cupcup,
    cupdot: cupdot,
    cupor: cupor,
    cups: cups,
    curarr: curarr,
    curarrm: curarrm,
    curlyeqprec: curlyeqprec,
    curlyeqsucc: curlyeqsucc,
    curlyvee: curlyvee,
    curlywedge: curlywedge,
    curren: curren$1,
    curvearrowleft: curvearrowleft,
    curvearrowright: curvearrowright,
    cuvee: cuvee,
    cuwed: cuwed,
    cwconint: cwconint,
    cwint: cwint,
    cylcty: cylcty,
    dagger: dagger,
    Dagger: Dagger,
    daleth: daleth,
    darr: darr,
    Darr: Darr,
    dArr: dArr,
    dash: dash,
    Dashv: Dashv,
    dashv: dashv,
    dbkarow: dbkarow,
    dblac: dblac,
    Dcaron: Dcaron,
    dcaron: dcaron,
    Dcy: Dcy,
    dcy: dcy,
    ddagger: ddagger,
    ddarr: ddarr,
    DD: DD,
    dd: dd,
    DDotrahd: DDotrahd,
    ddotseq: ddotseq,
    deg: deg$1,
    Del: Del,
    Delta: Delta,
    delta: delta,
    demptyv: demptyv,
    dfisht: dfisht,
    Dfr: Dfr,
    dfr: dfr,
    dHar: dHar,
    dharl: dharl,
    dharr: dharr,
    DiacriticalAcute: DiacriticalAcute,
    DiacriticalDot: DiacriticalDot,
    DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    DiacriticalGrave: DiacriticalGrave,
    DiacriticalTilde: DiacriticalTilde,
    diam: diam,
    diamond: diamond,
    Diamond: Diamond,
    diamondsuit: diamondsuit,
    diams: diams,
    die: die,
    DifferentialD: DifferentialD,
    digamma: digamma,
    disin: disin,
    div: div,
    divide: divide$1,
    divideontimes: divideontimes,
    divonx: divonx,
    DJcy: DJcy,
    djcy: djcy,
    dlcorn: dlcorn,
    dlcrop: dlcrop,
    dollar: dollar,
    Dopf: Dopf,
    dopf: dopf,
    Dot: Dot,
    dot: dot,
    DotDot: DotDot,
    doteq: doteq,
    doteqdot: doteqdot,
    DotEqual: DotEqual,
    dotminus: dotminus,
    dotplus: dotplus,
    dotsquare: dotsquare,
    doublebarwedge: doublebarwedge,
    DoubleContourIntegral: DoubleContourIntegral,
    DoubleDot: DoubleDot,
    DoubleDownArrow: DoubleDownArrow,
    DoubleLeftArrow: DoubleLeftArrow,
    DoubleLeftRightArrow: DoubleLeftRightArrow,
    DoubleLeftTee: DoubleLeftTee,
    DoubleLongLeftArrow: DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    DoubleLongRightArrow: DoubleLongRightArrow,
    DoubleRightArrow: DoubleRightArrow,
    DoubleRightTee: DoubleRightTee,
    DoubleUpArrow: DoubleUpArrow,
    DoubleUpDownArrow: DoubleUpDownArrow,
    DoubleVerticalBar: DoubleVerticalBar,
    DownArrowBar: DownArrowBar,
    downarrow: downarrow,
    DownArrow: DownArrow,
    Downarrow: Downarrow,
    DownArrowUpArrow: DownArrowUpArrow,
    DownBreve: DownBreve,
    downdownarrows: downdownarrows,
    downharpoonleft: downharpoonleft,
    downharpoonright: downharpoonright,
    DownLeftRightVector: DownLeftRightVector,
    DownLeftTeeVector: DownLeftTeeVector,
    DownLeftVectorBar: DownLeftVectorBar,
    DownLeftVector: DownLeftVector,
    DownRightTeeVector: DownRightTeeVector,
    DownRightVectorBar: DownRightVectorBar,
    DownRightVector: DownRightVector,
    DownTeeArrow: DownTeeArrow,
    DownTee: DownTee,
    drbkarow: drbkarow,
    drcorn: drcorn,
    drcrop: drcrop,
    Dscr: Dscr,
    dscr: dscr,
    DScy: DScy,
    dscy: dscy,
    dsol: dsol,
    Dstrok: Dstrok,
    dstrok: dstrok,
    dtdot: dtdot,
    dtri: dtri,
    dtrif: dtrif,
    duarr: duarr,
    duhar: duhar,
    dwangle: dwangle,
    DZcy: DZcy,
    dzcy: dzcy,
    dzigrarr: dzigrarr,
    Eacute: Eacute$1,
    eacute: eacute$1,
    easter: easter,
    Ecaron: Ecaron,
    ecaron: ecaron,
    Ecirc: Ecirc$1,
    ecirc: ecirc$1,
    ecir: ecir,
    ecolon: ecolon,
    Ecy: Ecy,
    ecy: ecy,
    eDDot: eDDot,
    Edot: Edot,
    edot: edot,
    eDot: eDot,
    ee: ee,
    efDot: efDot,
    Efr: Efr,
    efr: efr,
    eg: eg,
    Egrave: Egrave$1,
    egrave: egrave$1,
    egs: egs,
    egsdot: egsdot,
    el: el,
    Element: Element,
    elinters: elinters,
    ell: ell,
    els: els,
    elsdot: elsdot,
    Emacr: Emacr,
    emacr: emacr,
    empty: empty,
    emptyset: emptyset,
    EmptySmallSquare: EmptySmallSquare,
    emptyv: emptyv,
    EmptyVerySmallSquare: EmptyVerySmallSquare,
    emsp13: emsp13,
    emsp14: emsp14,
    emsp: emsp,
    ENG: ENG,
    eng: eng,
    ensp: ensp,
    Eogon: Eogon,
    eogon: eogon,
    Eopf: Eopf,
    eopf: eopf,
    epar: epar,
    eparsl: eparsl,
    eplus: eplus,
    epsi: epsi,
    Epsilon: Epsilon,
    epsilon: epsilon,
    epsiv: epsiv,
    eqcirc: eqcirc,
    eqcolon: eqcolon,
    eqsim: eqsim,
    eqslantgtr: eqslantgtr,
    eqslantless: eqslantless,
    Equal: Equal,
    equals: equals,
    EqualTilde: EqualTilde,
    equest: equest,
    Equilibrium: Equilibrium,
    equiv: equiv,
    equivDD: equivDD,
    eqvparsl: eqvparsl,
    erarr: erarr,
    erDot: erDot,
    escr: escr,
    Escr: Escr,
    esdot: esdot,
    Esim: Esim,
    esim: esim,
    Eta: Eta,
    eta: eta,
    ETH: ETH$1,
    eth: eth$1,
    Euml: Euml$1,
    euml: euml$1,
    euro: euro,
    excl: excl,
    exist: exist,
    Exists: Exists,
    expectation: expectation,
    exponentiale: exponentiale,
    ExponentialE: ExponentialE,
    fallingdotseq: fallingdotseq,
    Fcy: Fcy,
    fcy: fcy,
    female: female,
    ffilig: ffilig,
    fflig: fflig,
    ffllig: ffllig,
    Ffr: Ffr,
    ffr: ffr,
    filig: filig,
    FilledSmallSquare: FilledSmallSquare,
    FilledVerySmallSquare: FilledVerySmallSquare,
    fjlig: fjlig,
    flat: flat,
    fllig: fllig,
    fltns: fltns,
    fnof: fnof,
    Fopf: Fopf,
    fopf: fopf,
    forall: forall,
    ForAll: ForAll,
    fork: fork,
    forkv: forkv,
    Fouriertrf: Fouriertrf,
    fpartint: fpartint,
    frac12: frac12$1,
    frac13: frac13,
    frac14: frac14$1,
    frac15: frac15,
    frac16: frac16,
    frac18: frac18,
    frac23: frac23,
    frac25: frac25,
    frac34: frac34$1,
    frac35: frac35,
    frac38: frac38,
    frac45: frac45,
    frac56: frac56,
    frac58: frac58,
    frac78: frac78,
    frasl: frasl,
    frown: frown,
    fscr: fscr,
    Fscr: Fscr,
    gacute: gacute,
    Gamma: Gamma,
    gamma: gamma,
    Gammad: Gammad,
    gammad: gammad,
    gap: gap,
    Gbreve: Gbreve,
    gbreve: gbreve,
    Gcedil: Gcedil,
    Gcirc: Gcirc,
    gcirc: gcirc,
    Gcy: Gcy,
    gcy: gcy,
    Gdot: Gdot,
    gdot: gdot,
    ge: ge,
    gE: gE,
    gEl: gEl,
    gel: gel,
    geq: geq,
    geqq: geqq,
    geqslant: geqslant,
    gescc: gescc,
    ges: ges,
    gesdot: gesdot,
    gesdoto: gesdoto,
    gesdotol: gesdotol,
    gesl: gesl,
    gesles: gesles,
    Gfr: Gfr,
    gfr: gfr,
    gg: gg,
    Gg: Gg,
    ggg: ggg,
    gimel: gimel,
    GJcy: GJcy,
    gjcy: gjcy,
    gla: gla,
    gl: gl,
    glE: glE,
    glj: glj,
    gnap: gnap,
    gnapprox: gnapprox,
    gne: gne,
    gnE: gnE,
    gneq: gneq,
    gneqq: gneqq,
    gnsim: gnsim,
    Gopf: Gopf,
    gopf: gopf,
    grave: grave,
    GreaterEqual: GreaterEqual,
    GreaterEqualLess: GreaterEqualLess,
    GreaterFullEqual: GreaterFullEqual,
    GreaterGreater: GreaterGreater,
    GreaterLess: GreaterLess,
    GreaterSlantEqual: GreaterSlantEqual,
    GreaterTilde: GreaterTilde,
    Gscr: Gscr,
    gscr: gscr,
    gsim: gsim,
    gsime: gsime,
    gsiml: gsiml,
    gtcc: gtcc,
    gtcir: gtcir,
    gt: gt$2,
    GT: GT$1,
    Gt: Gt,
    gtdot: gtdot,
    gtlPar: gtlPar,
    gtquest: gtquest,
    gtrapprox: gtrapprox,
    gtrarr: gtrarr,
    gtrdot: gtrdot,
    gtreqless: gtreqless,
    gtreqqless: gtreqqless,
    gtrless: gtrless,
    gtrsim: gtrsim,
    gvertneqq: gvertneqq,
    gvnE: gvnE,
    Hacek: Hacek,
    hairsp: hairsp,
    half: half,
    hamilt: hamilt,
    HARDcy: HARDcy,
    hardcy: hardcy,
    harrcir: harrcir,
    harr: harr,
    hArr: hArr,
    harrw: harrw,
    Hat: Hat,
    hbar: hbar,
    Hcirc: Hcirc,
    hcirc: hcirc,
    hearts: hearts,
    heartsuit: heartsuit,
    hellip: hellip,
    hercon: hercon,
    hfr: hfr,
    Hfr: Hfr,
    HilbertSpace: HilbertSpace,
    hksearow: hksearow,
    hkswarow: hkswarow,
    hoarr: hoarr,
    homtht: homtht,
    hookleftarrow: hookleftarrow,
    hookrightarrow: hookrightarrow,
    hopf: hopf,
    Hopf: Hopf,
    horbar: horbar,
    HorizontalLine: HorizontalLine,
    hscr: hscr,
    Hscr: Hscr,
    hslash: hslash,
    Hstrok: Hstrok,
    hstrok: hstrok,
    HumpDownHump: HumpDownHump,
    HumpEqual: HumpEqual,
    hybull: hybull,
    hyphen: hyphen,
    Iacute: Iacute$1,
    iacute: iacute$1,
    ic: ic,
    Icirc: Icirc$1,
    icirc: icirc$1,
    Icy: Icy,
    icy: icy,
    Idot: Idot,
    IEcy: IEcy,
    iecy: iecy,
    iexcl: iexcl$1,
    iff: iff,
    ifr: ifr,
    Ifr: Ifr,
    Igrave: Igrave$1,
    igrave: igrave$1,
    ii: ii,
    iiiint: iiiint,
    iiint: iiint,
    iinfin: iinfin,
    iiota: iiota,
    IJlig: IJlig,
    ijlig: ijlig,
    Imacr: Imacr,
    imacr: imacr,
    image: image,
    ImaginaryI: ImaginaryI,
    imagline: imagline,
    imagpart: imagpart,
    imath: imath,
    Im: Im,
    imof: imof,
    imped: imped,
    Implies: Implies,
    incare: incare,
    infin: infin,
    infintie: infintie,
    inodot: inodot,
    intcal: intcal,
    int: int,
    Int: Int,
    integers: integers,
    Integral: Integral,
    intercal: intercal,
    Intersection: Intersection,
    intlarhk: intlarhk,
    intprod: intprod,
    InvisibleComma: InvisibleComma,
    InvisibleTimes: InvisibleTimes,
    IOcy: IOcy,
    iocy: iocy,
    Iogon: Iogon,
    iogon: iogon,
    Iopf: Iopf,
    iopf: iopf,
    Iota: Iota,
    iota: iota,
    iprod: iprod,
    iquest: iquest$1,
    iscr: iscr,
    Iscr: Iscr,
    isin: isin,
    isindot: isindot,
    isinE: isinE,
    isins: isins,
    isinsv: isinsv,
    isinv: isinv,
    it: it,
    Itilde: Itilde,
    itilde: itilde,
    Iukcy: Iukcy,
    iukcy: iukcy,
    Iuml: Iuml$1,
    iuml: iuml$1,
    Jcirc: Jcirc,
    jcirc: jcirc,
    Jcy: Jcy,
    jcy: jcy,
    Jfr: Jfr,
    jfr: jfr,
    jmath: jmath,
    Jopf: Jopf,
    jopf: jopf,
    Jscr: Jscr,
    jscr: jscr,
    Jsercy: Jsercy,
    jsercy: jsercy,
    Jukcy: Jukcy,
    jukcy: jukcy,
    Kappa: Kappa,
    kappa: kappa,
    kappav: kappav,
    Kcedil: Kcedil,
    kcedil: kcedil,
    Kcy: Kcy,
    kcy: kcy,
    Kfr: Kfr,
    kfr: kfr,
    kgreen: kgreen,
    KHcy: KHcy,
    khcy: khcy,
    KJcy: KJcy,
    kjcy: kjcy,
    Kopf: Kopf,
    kopf: kopf,
    Kscr: Kscr,
    kscr: kscr,
    lAarr: lAarr,
    Lacute: Lacute,
    lacute: lacute,
    laemptyv: laemptyv,
    lagran: lagran,
    Lambda: Lambda,
    lambda: lambda,
    lang: lang,
    Lang: Lang,
    langd: langd,
    langle: langle,
    lap: lap,
    Laplacetrf: Laplacetrf,
    laquo: laquo$1,
    larrb: larrb,
    larrbfs: larrbfs,
    larr: larr,
    Larr: Larr,
    lArr: lArr,
    larrfs: larrfs,
    larrhk: larrhk,
    larrlp: larrlp,
    larrpl: larrpl,
    larrsim: larrsim,
    larrtl: larrtl,
    latail: latail,
    lAtail: lAtail,
    lat: lat,
    late: late,
    lates: lates,
    lbarr: lbarr,
    lBarr: lBarr,
    lbbrk: lbbrk,
    lbrace: lbrace,
    lbrack: lbrack,
    lbrke: lbrke,
    lbrksld: lbrksld,
    lbrkslu: lbrkslu,
    Lcaron: Lcaron,
    lcaron: lcaron,
    Lcedil: Lcedil,
    lcedil: lcedil,
    lceil: lceil,
    lcub: lcub,
    Lcy: Lcy,
    lcy: lcy,
    ldca: ldca,
    ldquo: ldquo,
    ldquor: ldquor,
    ldrdhar: ldrdhar,
    ldrushar: ldrushar,
    ldsh: ldsh,
    le: le,
    lE: lE,
    LeftAngleBracket: LeftAngleBracket,
    LeftArrowBar: LeftArrowBar,
    leftarrow: leftarrow,
    LeftArrow: LeftArrow,
    Leftarrow: Leftarrow,
    LeftArrowRightArrow: LeftArrowRightArrow,
    leftarrowtail: leftarrowtail,
    LeftCeiling: LeftCeiling,
    LeftDoubleBracket: LeftDoubleBracket,
    LeftDownTeeVector: LeftDownTeeVector,
    LeftDownVectorBar: LeftDownVectorBar,
    LeftDownVector: LeftDownVector,
    LeftFloor: LeftFloor,
    leftharpoondown: leftharpoondown,
    leftharpoonup: leftharpoonup,
    leftleftarrows: leftleftarrows,
    leftrightarrow: leftrightarrow,
    LeftRightArrow: LeftRightArrow,
    Leftrightarrow: Leftrightarrow,
    leftrightarrows: leftrightarrows,
    leftrightharpoons: leftrightharpoons,
    leftrightsquigarrow: leftrightsquigarrow,
    LeftRightVector: LeftRightVector,
    LeftTeeArrow: LeftTeeArrow,
    LeftTee: LeftTee,
    LeftTeeVector: LeftTeeVector,
    leftthreetimes: leftthreetimes,
    LeftTriangleBar: LeftTriangleBar,
    LeftTriangle: LeftTriangle,
    LeftTriangleEqual: LeftTriangleEqual,
    LeftUpDownVector: LeftUpDownVector,
    LeftUpTeeVector: LeftUpTeeVector,
    LeftUpVectorBar: LeftUpVectorBar,
    LeftUpVector: LeftUpVector,
    LeftVectorBar: LeftVectorBar,
    LeftVector: LeftVector,
    lEg: lEg,
    leg: leg,
    leq: leq,
    leqq: leqq,
    leqslant: leqslant,
    lescc: lescc,
    les: les,
    lesdot: lesdot,
    lesdoto: lesdoto,
    lesdotor: lesdotor,
    lesg: lesg,
    lesges: lesges,
    lessapprox: lessapprox,
    lessdot: lessdot,
    lesseqgtr: lesseqgtr,
    lesseqqgtr: lesseqqgtr,
    LessEqualGreater: LessEqualGreater,
    LessFullEqual: LessFullEqual,
    LessGreater: LessGreater,
    lessgtr: lessgtr,
    LessLess: LessLess,
    lesssim: lesssim,
    LessSlantEqual: LessSlantEqual,
    LessTilde: LessTilde,
    lfisht: lfisht,
    lfloor: lfloor,
    Lfr: Lfr,
    lfr: lfr,
    lg: lg,
    lgE: lgE,
    lHar: lHar,
    lhard: lhard,
    lharu: lharu,
    lharul: lharul,
    lhblk: lhblk,
    LJcy: LJcy,
    ljcy: ljcy,
    llarr: llarr,
    ll: ll,
    Ll: Ll,
    llcorner: llcorner,
    Lleftarrow: Lleftarrow,
    llhard: llhard,
    lltri: lltri,
    Lmidot: Lmidot,
    lmidot: lmidot,
    lmoustache: lmoustache,
    lmoust: lmoust,
    lnap: lnap,
    lnapprox: lnapprox,
    lne: lne,
    lnE: lnE,
    lneq: lneq,
    lneqq: lneqq,
    lnsim: lnsim,
    loang: loang,
    loarr: loarr,
    lobrk: lobrk,
    longleftarrow: longleftarrow,
    LongLeftArrow: LongLeftArrow,
    Longleftarrow: Longleftarrow,
    longleftrightarrow: longleftrightarrow,
    LongLeftRightArrow: LongLeftRightArrow,
    Longleftrightarrow: Longleftrightarrow,
    longmapsto: longmapsto,
    longrightarrow: longrightarrow,
    LongRightArrow: LongRightArrow,
    Longrightarrow: Longrightarrow,
    looparrowleft: looparrowleft,
    looparrowright: looparrowright,
    lopar: lopar,
    Lopf: Lopf,
    lopf: lopf,
    loplus: loplus,
    lotimes: lotimes,
    lowast: lowast,
    lowbar: lowbar,
    LowerLeftArrow: LowerLeftArrow,
    LowerRightArrow: LowerRightArrow,
    loz: loz,
    lozenge: lozenge,
    lozf: lozf,
    lpar: lpar,
    lparlt: lparlt,
    lrarr: lrarr,
    lrcorner: lrcorner,
    lrhar: lrhar,
    lrhard: lrhard,
    lrm: lrm,
    lrtri: lrtri,
    lsaquo: lsaquo,
    lscr: lscr,
    Lscr: Lscr,
    lsh: lsh,
    Lsh: Lsh,
    lsim: lsim,
    lsime: lsime,
    lsimg: lsimg,
    lsqb: lsqb,
    lsquo: lsquo,
    lsquor: lsquor,
    Lstrok: Lstrok,
    lstrok: lstrok,
    ltcc: ltcc,
    ltcir: ltcir,
    lt: lt$2,
    LT: LT$1,
    Lt: Lt,
    ltdot: ltdot,
    lthree: lthree,
    ltimes: ltimes,
    ltlarr: ltlarr,
    ltquest: ltquest,
    ltri: ltri,
    ltrie: ltrie,
    ltrif: ltrif,
    ltrPar: ltrPar,
    lurdshar: lurdshar,
    luruhar: luruhar,
    lvertneqq: lvertneqq,
    lvnE: lvnE,
    macr: macr$1,
    male: male,
    malt: malt,
    maltese: maltese,
    map: map,
    mapsto: mapsto,
    mapstodown: mapstodown,
    mapstoleft: mapstoleft,
    mapstoup: mapstoup,
    marker: marker,
    mcomma: mcomma,
    Mcy: Mcy,
    mcy: mcy,
    mdash: mdash,
    mDDot: mDDot,
    measuredangle: measuredangle,
    MediumSpace: MediumSpace,
    Mellintrf: Mellintrf,
    Mfr: Mfr,
    mfr: mfr,
    mho: mho,
    micro: micro$1,
    midast: midast,
    midcir: midcir,
    mid: mid,
    middot: middot$1,
    minusb: minusb,
    minus: minus,
    minusd: minusd,
    minusdu: minusdu,
    MinusPlus: MinusPlus,
    mlcp: mlcp,
    mldr: mldr,
    mnplus: mnplus,
    models: models,
    Mopf: Mopf,
    mopf: mopf,
    mp: mp,
    mscr: mscr,
    Mscr: Mscr,
    mstpos: mstpos,
    Mu: Mu,
    mu: mu,
    multimap: multimap,
    mumap: mumap,
    nabla: nabla,
    Nacute: Nacute,
    nacute: nacute,
    nang: nang,
    nap: nap,
    napE: napE,
    napid: napid,
    napos: napos,
    napprox: napprox,
    natural: natural,
    naturals: naturals,
    natur: natur,
    nbsp: nbsp$1,
    nbump: nbump,
    nbumpe: nbumpe,
    ncap: ncap,
    Ncaron: Ncaron,
    ncaron: ncaron,
    Ncedil: Ncedil,
    ncedil: ncedil,
    ncong: ncong,
    ncongdot: ncongdot,
    ncup: ncup,
    Ncy: Ncy,
    ncy: ncy,
    ndash: ndash,
    nearhk: nearhk,
    nearr: nearr,
    neArr: neArr,
    nearrow: nearrow,
    ne: ne,
    nedot: nedot,
    NegativeMediumSpace: NegativeMediumSpace,
    NegativeThickSpace: NegativeThickSpace,
    NegativeThinSpace: NegativeThinSpace,
    NegativeVeryThinSpace: NegativeVeryThinSpace,
    nequiv: nequiv,
    nesear: nesear,
    nesim: nesim,
    NestedGreaterGreater: NestedGreaterGreater,
    NestedLessLess: NestedLessLess,
    NewLine: NewLine,
    nexist: nexist,
    nexists: nexists,
    Nfr: Nfr,
    nfr: nfr,
    ngE: ngE,
    nge: nge,
    ngeq: ngeq,
    ngeqq: ngeqq,
    ngeqslant: ngeqslant,
    nges: nges,
    nGg: nGg,
    ngsim: ngsim,
    nGt: nGt,
    ngt: ngt,
    ngtr: ngtr,
    nGtv: nGtv,
    nharr: nharr,
    nhArr: nhArr,
    nhpar: nhpar,
    ni: ni,
    nis: nis,
    nisd: nisd,
    niv: niv,
    NJcy: NJcy,
    njcy: njcy,
    nlarr: nlarr,
    nlArr: nlArr,
    nldr: nldr,
    nlE: nlE,
    nle: nle,
    nleftarrow: nleftarrow,
    nLeftarrow: nLeftarrow,
    nleftrightarrow: nleftrightarrow,
    nLeftrightarrow: nLeftrightarrow,
    nleq: nleq,
    nleqq: nleqq,
    nleqslant: nleqslant,
    nles: nles,
    nless: nless,
    nLl: nLl,
    nlsim: nlsim,
    nLt: nLt,
    nlt: nlt,
    nltri: nltri,
    nltrie: nltrie,
    nLtv: nLtv,
    nmid: nmid,
    NoBreak: NoBreak,
    NonBreakingSpace: NonBreakingSpace,
    nopf: nopf,
    Nopf: Nopf,
    Not: Not,
    not: not$1,
    NotCongruent: NotCongruent,
    NotCupCap: NotCupCap,
    NotDoubleVerticalBar: NotDoubleVerticalBar,
    NotElement: NotElement,
    NotEqual: NotEqual,
    NotEqualTilde: NotEqualTilde,
    NotExists: NotExists,
    NotGreater: NotGreater,
    NotGreaterEqual: NotGreaterEqual,
    NotGreaterFullEqual: NotGreaterFullEqual,
    NotGreaterGreater: NotGreaterGreater,
    NotGreaterLess: NotGreaterLess,
    NotGreaterSlantEqual: NotGreaterSlantEqual,
    NotGreaterTilde: NotGreaterTilde,
    NotHumpDownHump: NotHumpDownHump,
    NotHumpEqual: NotHumpEqual,
    notin: notin,
    notindot: notindot,
    notinE: notinE,
    notinva: notinva,
    notinvb: notinvb,
    notinvc: notinvc,
    NotLeftTriangleBar: NotLeftTriangleBar,
    NotLeftTriangle: NotLeftTriangle,
    NotLeftTriangleEqual: NotLeftTriangleEqual,
    NotLess: NotLess,
    NotLessEqual: NotLessEqual,
    NotLessGreater: NotLessGreater,
    NotLessLess: NotLessLess,
    NotLessSlantEqual: NotLessSlantEqual,
    NotLessTilde: NotLessTilde,
    NotNestedGreaterGreater: NotNestedGreaterGreater,
    NotNestedLessLess: NotNestedLessLess,
    notni: notni,
    notniva: notniva,
    notnivb: notnivb,
    notnivc: notnivc,
    NotPrecedes: NotPrecedes,
    NotPrecedesEqual: NotPrecedesEqual,
    NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    NotReverseElement: NotReverseElement,
    NotRightTriangleBar: NotRightTriangleBar,
    NotRightTriangle: NotRightTriangle,
    NotRightTriangleEqual: NotRightTriangleEqual,
    NotSquareSubset: NotSquareSubset,
    NotSquareSubsetEqual: NotSquareSubsetEqual,
    NotSquareSuperset: NotSquareSuperset,
    NotSquareSupersetEqual: NotSquareSupersetEqual,
    NotSubset: NotSubset,
    NotSubsetEqual: NotSubsetEqual,
    NotSucceeds: NotSucceeds,
    NotSucceedsEqual: NotSucceedsEqual,
    NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    NotSucceedsTilde: NotSucceedsTilde,
    NotSuperset: NotSuperset,
    NotSupersetEqual: NotSupersetEqual,
    NotTilde: NotTilde,
    NotTildeEqual: NotTildeEqual,
    NotTildeFullEqual: NotTildeFullEqual,
    NotTildeTilde: NotTildeTilde,
    NotVerticalBar: NotVerticalBar,
    nparallel: nparallel,
    npar: npar,
    nparsl: nparsl,
    npart: npart,
    npolint: npolint,
    npr: npr,
    nprcue: nprcue,
    nprec: nprec,
    npreceq: npreceq,
    npre: npre,
    nrarrc: nrarrc,
    nrarr: nrarr,
    nrArr: nrArr,
    nrarrw: nrarrw,
    nrightarrow: nrightarrow,
    nRightarrow: nRightarrow,
    nrtri: nrtri,
    nrtrie: nrtrie,
    nsc: nsc,
    nsccue: nsccue,
    nsce: nsce,
    Nscr: Nscr,
    nscr: nscr,
    nshortmid: nshortmid,
    nshortparallel: nshortparallel,
    nsim: nsim,
    nsime: nsime,
    nsimeq: nsimeq,
    nsmid: nsmid,
    nspar: nspar,
    nsqsube: nsqsube,
    nsqsupe: nsqsupe,
    nsub: nsub,
    nsubE: nsubE,
    nsube: nsube,
    nsubset: nsubset,
    nsubseteq: nsubseteq,
    nsubseteqq: nsubseteqq,
    nsucc: nsucc,
    nsucceq: nsucceq,
    nsup: nsup,
    nsupE: nsupE,
    nsupe: nsupe,
    nsupset: nsupset,
    nsupseteq: nsupseteq,
    nsupseteqq: nsupseteqq,
    ntgl: ntgl,
    Ntilde: Ntilde$1,
    ntilde: ntilde$1,
    ntlg: ntlg,
    ntriangleleft: ntriangleleft,
    ntrianglelefteq: ntrianglelefteq,
    ntriangleright: ntriangleright,
    ntrianglerighteq: ntrianglerighteq,
    Nu: Nu,
    nu: nu,
    num: num,
    numero: numero,
    numsp: numsp,
    nvap: nvap,
    nvdash: nvdash,
    nvDash: nvDash,
    nVdash: nVdash,
    nVDash: nVDash,
    nvge: nvge,
    nvgt: nvgt,
    nvHarr: nvHarr,
    nvinfin: nvinfin,
    nvlArr: nvlArr,
    nvle: nvle,
    nvlt: nvlt,
    nvltrie: nvltrie,
    nvrArr: nvrArr,
    nvrtrie: nvrtrie,
    nvsim: nvsim,
    nwarhk: nwarhk,
    nwarr: nwarr,
    nwArr: nwArr,
    nwarrow: nwarrow,
    nwnear: nwnear,
    Oacute: Oacute$1,
    oacute: oacute$1,
    oast: oast,
    Ocirc: Ocirc$1,
    ocirc: ocirc$1,
    ocir: ocir,
    Ocy: Ocy,
    ocy: ocy,
    odash: odash,
    Odblac: Odblac,
    odblac: odblac,
    odiv: odiv,
    odot: odot,
    odsold: odsold,
    OElig: OElig,
    oelig: oelig,
    ofcir: ofcir,
    Ofr: Ofr,
    ofr: ofr,
    ogon: ogon,
    Ograve: Ograve$1,
    ograve: ograve$1,
    ogt: ogt,
    ohbar: ohbar,
    ohm: ohm,
    oint: oint,
    olarr: olarr,
    olcir: olcir,
    olcross: olcross,
    oline: oline,
    olt: olt,
    Omacr: Omacr,
    omacr: omacr,
    Omega: Omega,
    omega: omega,
    Omicron: Omicron,
    omicron: omicron,
    omid: omid,
    ominus: ominus,
    Oopf: Oopf,
    oopf: oopf,
    opar: opar,
    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    OpenCurlyQuote: OpenCurlyQuote,
    operp: operp,
    oplus: oplus,
    orarr: orarr,
    Or: Or,
    or: or,
    ord: ord,
    order: order,
    orderof: orderof,
    ordf: ordf$1,
    ordm: ordm$1,
    origof: origof,
    oror: oror,
    orslope: orslope,
    orv: orv,
    oS: oS,
    Oscr: Oscr,
    oscr: oscr,
    Oslash: Oslash$1,
    oslash: oslash$1,
    osol: osol,
    Otilde: Otilde$1,
    otilde: otilde$1,
    otimesas: otimesas,
    Otimes: Otimes,
    otimes: otimes,
    Ouml: Ouml$1,
    ouml: ouml$1,
    ovbar: ovbar,
    OverBar: OverBar,
    OverBrace: OverBrace,
    OverBracket: OverBracket,
    OverParenthesis: OverParenthesis,
    para: para$1,
    parallel: parallel,
    par: par,
    parsim: parsim,
    parsl: parsl,
    part: part,
    PartialD: PartialD,
    Pcy: Pcy,
    pcy: pcy,
    percnt: percnt,
    period: period,
    permil: permil,
    perp: perp,
    pertenk: pertenk,
    Pfr: Pfr,
    pfr: pfr,
    Phi: Phi,
    phi: phi,
    phiv: phiv,
    phmmat: phmmat,
    phone: phone,
    Pi: Pi,
    pi: pi,
    pitchfork: pitchfork,
    piv: piv,
    planck: planck,
    planckh: planckh,
    plankv: plankv,
    plusacir: plusacir,
    plusb: plusb,
    pluscir: pluscir,
    plus: plus,
    plusdo: plusdo,
    plusdu: plusdu,
    pluse: pluse,
    PlusMinus: PlusMinus,
    plusmn: plusmn$1,
    plussim: plussim,
    plustwo: plustwo,
    pm: pm,
    Poincareplane: Poincareplane,
    pointint: pointint,
    popf: popf,
    Popf: Popf,
    pound: pound$1,
    prap: prap,
    Pr: Pr,
    pr: pr,
    prcue: prcue,
    precapprox: precapprox,
    prec: prec,
    preccurlyeq: preccurlyeq,
    Precedes: Precedes,
    PrecedesEqual: PrecedesEqual,
    PrecedesSlantEqual: PrecedesSlantEqual,
    PrecedesTilde: PrecedesTilde,
    preceq: preceq,
    precnapprox: precnapprox,
    precneqq: precneqq,
    precnsim: precnsim,
    pre: pre,
    prE: prE,
    precsim: precsim,
    prime: prime,
    Prime: Prime,
    primes: primes,
    prnap: prnap,
    prnE: prnE,
    prnsim: prnsim,
    prod: prod,
    Product: Product,
    profalar: profalar,
    profline: profline,
    profsurf: profsurf,
    prop: prop,
    Proportional: Proportional,
    Proportion: Proportion,
    propto: propto,
    prsim: prsim,
    prurel: prurel,
    Pscr: Pscr,
    pscr: pscr,
    Psi: Psi,
    psi: psi,
    puncsp: puncsp,
    Qfr: Qfr,
    qfr: qfr,
    qint: qint,
    qopf: qopf,
    Qopf: Qopf,
    qprime: qprime,
    Qscr: Qscr,
    qscr: qscr,
    quaternions: quaternions,
    quatint: quatint,
    quest: quest,
    questeq: questeq,
    quot: quot$2,
    QUOT: QUOT$1,
    rAarr: rAarr,
    race: race,
    Racute: Racute,
    racute: racute,
    radic: radic,
    raemptyv: raemptyv,
    rang: rang,
    Rang: Rang,
    rangd: rangd,
    range: range,
    rangle: rangle,
    raquo: raquo$1,
    rarrap: rarrap,
    rarrb: rarrb,
    rarrbfs: rarrbfs,
    rarrc: rarrc,
    rarr: rarr,
    Rarr: Rarr,
    rArr: rArr,
    rarrfs: rarrfs,
    rarrhk: rarrhk,
    rarrlp: rarrlp,
    rarrpl: rarrpl,
    rarrsim: rarrsim,
    Rarrtl: Rarrtl,
    rarrtl: rarrtl,
    rarrw: rarrw,
    ratail: ratail,
    rAtail: rAtail,
    ratio: ratio,
    rationals: rationals,
    rbarr: rbarr,
    rBarr: rBarr,
    RBarr: RBarr,
    rbbrk: rbbrk,
    rbrace: rbrace,
    rbrack: rbrack,
    rbrke: rbrke,
    rbrksld: rbrksld,
    rbrkslu: rbrkslu,
    Rcaron: Rcaron,
    rcaron: rcaron,
    Rcedil: Rcedil,
    rcedil: rcedil,
    rceil: rceil,
    rcub: rcub,
    Rcy: Rcy,
    rcy: rcy,
    rdca: rdca,
    rdldhar: rdldhar,
    rdquo: rdquo,
    rdquor: rdquor,
    rdsh: rdsh,
    real: real,
    realine: realine,
    realpart: realpart,
    reals: reals,
    Re: Re,
    rect: rect,
    reg: reg$1,
    REG: REG$1,
    ReverseElement: ReverseElement,
    ReverseEquilibrium: ReverseEquilibrium,
    ReverseUpEquilibrium: ReverseUpEquilibrium,
    rfisht: rfisht,
    rfloor: rfloor,
    rfr: rfr,
    Rfr: Rfr,
    rHar: rHar,
    rhard: rhard,
    rharu: rharu,
    rharul: rharul,
    Rho: Rho,
    rho: rho,
    rhov: rhov,
    RightAngleBracket: RightAngleBracket,
    RightArrowBar: RightArrowBar,
    rightarrow: rightarrow,
    RightArrow: RightArrow,
    Rightarrow: Rightarrow,
    RightArrowLeftArrow: RightArrowLeftArrow,
    rightarrowtail: rightarrowtail,
    RightCeiling: RightCeiling,
    RightDoubleBracket: RightDoubleBracket,
    RightDownTeeVector: RightDownTeeVector,
    RightDownVectorBar: RightDownVectorBar,
    RightDownVector: RightDownVector,
    RightFloor: RightFloor,
    rightharpoondown: rightharpoondown,
    rightharpoonup: rightharpoonup,
    rightleftarrows: rightleftarrows,
    rightleftharpoons: rightleftharpoons,
    rightrightarrows: rightrightarrows,
    rightsquigarrow: rightsquigarrow,
    RightTeeArrow: RightTeeArrow,
    RightTee: RightTee,
    RightTeeVector: RightTeeVector,
    rightthreetimes: rightthreetimes,
    RightTriangleBar: RightTriangleBar,
    RightTriangle: RightTriangle,
    RightTriangleEqual: RightTriangleEqual,
    RightUpDownVector: RightUpDownVector,
    RightUpTeeVector: RightUpTeeVector,
    RightUpVectorBar: RightUpVectorBar,
    RightUpVector: RightUpVector,
    RightVectorBar: RightVectorBar,
    RightVector: RightVector,
    ring: ring,
    risingdotseq: risingdotseq,
    rlarr: rlarr,
    rlhar: rlhar,
    rlm: rlm,
    rmoustache: rmoustache,
    rmoust: rmoust,
    rnmid: rnmid,
    roang: roang,
    roarr: roarr,
    robrk: robrk,
    ropar: ropar,
    ropf: ropf,
    Ropf: Ropf,
    roplus: roplus,
    rotimes: rotimes,
    RoundImplies: RoundImplies,
    rpar: rpar,
    rpargt: rpargt,
    rppolint: rppolint,
    rrarr: rrarr,
    Rrightarrow: Rrightarrow,
    rsaquo: rsaquo,
    rscr: rscr,
    Rscr: Rscr,
    rsh: rsh,
    Rsh: Rsh,
    rsqb: rsqb,
    rsquo: rsquo,
    rsquor: rsquor,
    rthree: rthree,
    rtimes: rtimes,
    rtri: rtri,
    rtrie: rtrie,
    rtrif: rtrif,
    rtriltri: rtriltri,
    RuleDelayed: RuleDelayed,
    ruluhar: ruluhar,
    rx: rx,
    Sacute: Sacute,
    sacute: sacute,
    sbquo: sbquo,
    scap: scap,
    Scaron: Scaron,
    scaron: scaron,
    Sc: Sc,
    sc: sc,
    sccue: sccue,
    sce: sce,
    scE: scE,
    Scedil: Scedil,
    scedil: scedil,
    Scirc: Scirc,
    scirc: scirc,
    scnap: scnap,
    scnE: scnE,
    scnsim: scnsim,
    scpolint: scpolint,
    scsim: scsim,
    Scy: Scy,
    scy: scy,
    sdotb: sdotb,
    sdot: sdot,
    sdote: sdote,
    searhk: searhk,
    searr: searr,
    seArr: seArr,
    searrow: searrow,
    sect: sect$1,
    semi: semi,
    seswar: seswar,
    setminus: setminus,
    setmn: setmn,
    sext: sext,
    Sfr: Sfr,
    sfr: sfr,
    sfrown: sfrown,
    sharp: sharp,
    SHCHcy: SHCHcy,
    shchcy: shchcy,
    SHcy: SHcy,
    shcy: shcy,
    ShortDownArrow: ShortDownArrow,
    ShortLeftArrow: ShortLeftArrow,
    shortmid: shortmid,
    shortparallel: shortparallel,
    ShortRightArrow: ShortRightArrow,
    ShortUpArrow: ShortUpArrow,
    shy: shy$1,
    Sigma: Sigma,
    sigma: sigma,
    sigmaf: sigmaf,
    sigmav: sigmav,
    sim: sim,
    simdot: simdot,
    sime: sime,
    simeq: simeq,
    simg: simg,
    simgE: simgE,
    siml: siml,
    simlE: simlE,
    simne: simne,
    simplus: simplus,
    simrarr: simrarr,
    slarr: slarr,
    SmallCircle: SmallCircle,
    smallsetminus: smallsetminus,
    smashp: smashp,
    smeparsl: smeparsl,
    smid: smid,
    smile: smile,
    smt: smt,
    smte: smte,
    smtes: smtes,
    SOFTcy: SOFTcy,
    softcy: softcy,
    solbar: solbar,
    solb: solb,
    sol: sol,
    Sopf: Sopf,
    sopf: sopf,
    spades: spades,
    spadesuit: spadesuit,
    spar: spar,
    sqcap: sqcap,
    sqcaps: sqcaps,
    sqcup: sqcup,
    sqcups: sqcups,
    Sqrt: Sqrt,
    sqsub: sqsub,
    sqsube: sqsube,
    sqsubset: sqsubset,
    sqsubseteq: sqsubseteq,
    sqsup: sqsup,
    sqsupe: sqsupe,
    sqsupset: sqsupset,
    sqsupseteq: sqsupseteq,
    square: square,
    Square: Square,
    SquareIntersection: SquareIntersection,
    SquareSubset: SquareSubset,
    SquareSubsetEqual: SquareSubsetEqual,
    SquareSuperset: SquareSuperset,
    SquareSupersetEqual: SquareSupersetEqual,
    SquareUnion: SquareUnion,
    squarf: squarf,
    squ: squ,
    squf: squf,
    srarr: srarr,
    Sscr: Sscr,
    sscr: sscr,
    ssetmn: ssetmn,
    ssmile: ssmile,
    sstarf: sstarf,
    Star: Star,
    star: star,
    starf: starf,
    straightepsilon: straightepsilon,
    straightphi: straightphi,
    strns: strns,
    sub: sub,
    Sub: Sub,
    subdot: subdot,
    subE: subE,
    sube: sube,
    subedot: subedot,
    submult: submult,
    subnE: subnE,
    subne: subne,
    subplus: subplus,
    subrarr: subrarr,
    subset: subset,
    Subset: Subset,
    subseteq: subseteq,
    subseteqq: subseteqq,
    SubsetEqual: SubsetEqual,
    subsetneq: subsetneq,
    subsetneqq: subsetneqq,
    subsim: subsim,
    subsub: subsub,
    subsup: subsup,
    succapprox: succapprox,
    succ: succ,
    succcurlyeq: succcurlyeq,
    Succeeds: Succeeds,
    SucceedsEqual: SucceedsEqual,
    SucceedsSlantEqual: SucceedsSlantEqual,
    SucceedsTilde: SucceedsTilde,
    succeq: succeq,
    succnapprox: succnapprox,
    succneqq: succneqq,
    succnsim: succnsim,
    succsim: succsim,
    SuchThat: SuchThat,
    sum: sum,
    Sum: Sum,
    sung: sung,
    sup1: sup1$1,
    sup2: sup2$1,
    sup3: sup3$1,
    sup: sup,
    Sup: Sup,
    supdot: supdot,
    supdsub: supdsub,
    supE: supE,
    supe: supe,
    supedot: supedot,
    Superset: Superset,
    SupersetEqual: SupersetEqual,
    suphsol: suphsol,
    suphsub: suphsub,
    suplarr: suplarr,
    supmult: supmult,
    supnE: supnE,
    supne: supne,
    supplus: supplus,
    supset: supset,
    Supset: Supset,
    supseteq: supseteq,
    supseteqq: supseteqq,
    supsetneq: supsetneq,
    supsetneqq: supsetneqq,
    supsim: supsim,
    supsub: supsub,
    supsup: supsup,
    swarhk: swarhk,
    swarr: swarr,
    swArr: swArr,
    swarrow: swarrow,
    swnwar: swnwar,
    szlig: szlig$1,
    Tab: Tab,
    target: target,
    Tau: Tau,
    tau: tau,
    tbrk: tbrk,
    Tcaron: Tcaron,
    tcaron: tcaron,
    Tcedil: Tcedil,
    tcedil: tcedil,
    Tcy: Tcy,
    tcy: tcy,
    tdot: tdot,
    telrec: telrec,
    Tfr: Tfr,
    tfr: tfr,
    there4: there4,
    therefore: therefore,
    Therefore: Therefore,
    Theta: Theta,
    theta: theta,
    thetasym: thetasym,
    thetav: thetav,
    thickapprox: thickapprox,
    thicksim: thicksim,
    ThickSpace: ThickSpace,
    ThinSpace: ThinSpace,
    thinsp: thinsp,
    thkap: thkap,
    thksim: thksim,
    THORN: THORN$1,
    thorn: thorn$1,
    tilde: tilde,
    Tilde: Tilde,
    TildeEqual: TildeEqual,
    TildeFullEqual: TildeFullEqual,
    TildeTilde: TildeTilde,
    timesbar: timesbar,
    timesb: timesb,
    times: times$1,
    timesd: timesd,
    tint: tint,
    toea: toea,
    topbot: topbot,
    topcir: topcir,
    top: top,
    Topf: Topf,
    topf: topf,
    topfork: topfork,
    tosa: tosa,
    tprime: tprime,
    trade: trade,
    TRADE: TRADE,
    triangle: triangle,
    triangledown: triangledown,
    triangleleft: triangleleft,
    trianglelefteq: trianglelefteq,
    triangleq: triangleq,
    triangleright: triangleright,
    trianglerighteq: trianglerighteq,
    tridot: tridot,
    trie: trie,
    triminus: triminus,
    TripleDot: TripleDot,
    triplus: triplus,
    trisb: trisb,
    tritime: tritime,
    trpezium: trpezium,
    Tscr: Tscr,
    tscr: tscr,
    TScy: TScy,
    tscy: tscy,
    TSHcy: TSHcy,
    tshcy: tshcy,
    Tstrok: Tstrok,
    tstrok: tstrok,
    twixt: twixt,
    twoheadleftarrow: twoheadleftarrow,
    twoheadrightarrow: twoheadrightarrow,
    Uacute: Uacute$1,
    uacute: uacute$1,
    uarr: uarr,
    Uarr: Uarr,
    uArr: uArr,
    Uarrocir: Uarrocir,
    Ubrcy: Ubrcy,
    ubrcy: ubrcy,
    Ubreve: Ubreve,
    ubreve: ubreve,
    Ucirc: Ucirc$1,
    ucirc: ucirc$1,
    Ucy: Ucy,
    ucy: ucy,
    udarr: udarr,
    Udblac: Udblac,
    udblac: udblac,
    udhar: udhar,
    ufisht: ufisht,
    Ufr: Ufr,
    ufr: ufr,
    Ugrave: Ugrave$1,
    ugrave: ugrave$1,
    uHar: uHar,
    uharl: uharl,
    uharr: uharr,
    uhblk: uhblk,
    ulcorn: ulcorn,
    ulcorner: ulcorner,
    ulcrop: ulcrop,
    ultri: ultri,
    Umacr: Umacr,
    umacr: umacr,
    uml: uml$1,
    UnderBar: UnderBar,
    UnderBrace: UnderBrace,
    UnderBracket: UnderBracket,
    UnderParenthesis: UnderParenthesis,
    Union: Union,
    UnionPlus: UnionPlus,
    Uogon: Uogon,
    uogon: uogon,
    Uopf: Uopf,
    uopf: uopf,
    UpArrowBar: UpArrowBar,
    uparrow: uparrow,
    UpArrow: UpArrow,
    Uparrow: Uparrow,
    UpArrowDownArrow: UpArrowDownArrow,
    updownarrow: updownarrow,
    UpDownArrow: UpDownArrow,
    Updownarrow: Updownarrow,
    UpEquilibrium: UpEquilibrium,
    upharpoonleft: upharpoonleft,
    upharpoonright: upharpoonright,
    uplus: uplus,
    UpperLeftArrow: UpperLeftArrow,
    UpperRightArrow: UpperRightArrow,
    upsi: upsi,
    Upsi: Upsi,
    upsih: upsih,
    Upsilon: Upsilon,
    upsilon: upsilon,
    UpTeeArrow: UpTeeArrow,
    UpTee: UpTee,
    upuparrows: upuparrows,
    urcorn: urcorn,
    urcorner: urcorner,
    urcrop: urcrop,
    Uring: Uring,
    uring: uring,
    urtri: urtri,
    Uscr: Uscr,
    uscr: uscr,
    utdot: utdot,
    Utilde: Utilde,
    utilde: utilde,
    utri: utri,
    utrif: utrif,
    uuarr: uuarr,
    Uuml: Uuml$1,
    uuml: uuml$1,
    uwangle: uwangle,
    vangrt: vangrt,
    varepsilon: varepsilon,
    varkappa: varkappa,
    varnothing: varnothing,
    varphi: varphi,
    varpi: varpi,
    varpropto: varpropto,
    varr: varr,
    vArr: vArr,
    varrho: varrho,
    varsigma: varsigma,
    varsubsetneq: varsubsetneq,
    varsubsetneqq: varsubsetneqq,
    varsupsetneq: varsupsetneq,
    varsupsetneqq: varsupsetneqq,
    vartheta: vartheta,
    vartriangleleft: vartriangleleft,
    vartriangleright: vartriangleright,
    vBar: vBar,
    Vbar: Vbar,
    vBarv: vBarv,
    Vcy: Vcy,
    vcy: vcy,
    vdash: vdash,
    vDash: vDash,
    Vdash: Vdash,
    VDash: VDash,
    Vdashl: Vdashl,
    veebar: veebar,
    vee: vee,
    Vee: Vee,
    veeeq: veeeq,
    vellip: vellip,
    verbar: verbar,
    Verbar: Verbar,
    vert: vert,
    Vert: Vert,
    VerticalBar: VerticalBar,
    VerticalLine: VerticalLine,
    VerticalSeparator: VerticalSeparator,
    VerticalTilde: VerticalTilde,
    VeryThinSpace: VeryThinSpace,
    Vfr: Vfr,
    vfr: vfr,
    vltri: vltri,
    vnsub: vnsub,
    vnsup: vnsup,
    Vopf: Vopf,
    vopf: vopf,
    vprop: vprop,
    vrtri: vrtri,
    Vscr: Vscr,
    vscr: vscr,
    vsubnE: vsubnE,
    vsubne: vsubne,
    vsupnE: vsupnE,
    vsupne: vsupne,
    Vvdash: Vvdash,
    vzigzag: vzigzag,
    Wcirc: Wcirc,
    wcirc: wcirc,
    wedbar: wedbar,
    wedge: wedge,
    Wedge: Wedge,
    wedgeq: wedgeq,
    weierp: weierp,
    Wfr: Wfr,
    wfr: wfr,
    Wopf: Wopf,
    wopf: wopf,
    wp: wp,
    wr: wr,
    wreath: wreath,
    Wscr: Wscr,
    wscr: wscr,
    xcap: xcap,
    xcirc: xcirc,
    xcup: xcup,
    xdtri: xdtri,
    Xfr: Xfr,
    xfr: xfr,
    xharr: xharr,
    xhArr: xhArr,
    Xi: Xi,
    xi: xi,
    xlarr: xlarr,
    xlArr: xlArr,
    xmap: xmap,
    xnis: xnis,
    xodot: xodot,
    Xopf: Xopf,
    xopf: xopf,
    xoplus: xoplus,
    xotime: xotime,
    xrarr: xrarr,
    xrArr: xrArr,
    Xscr: Xscr,
    xscr: xscr,
    xsqcup: xsqcup,
    xuplus: xuplus,
    xutri: xutri,
    xvee: xvee,
    xwedge: xwedge,
    Yacute: Yacute$1,
    yacute: yacute$1,
    YAcy: YAcy,
    yacy: yacy,
    Ycirc: Ycirc,
    ycirc: ycirc,
    Ycy: Ycy,
    ycy: ycy,
    yen: yen$1,
    Yfr: Yfr,
    yfr: yfr,
    YIcy: YIcy,
    yicy: yicy,
    Yopf: Yopf,
    yopf: yopf,
    Yscr: Yscr,
    yscr: yscr,
    YUcy: YUcy,
    yucy: yucy,
    yuml: yuml$1,
    Yuml: Yuml,
    Zacute: Zacute,
    zacute: zacute,
    Zcaron: Zcaron,
    zcaron: zcaron,
    Zcy: Zcy,
    zcy: zcy,
    Zdot: Zdot,
    zdot: zdot,
    zeetrf: zeetrf,
    ZeroWidthSpace: ZeroWidthSpace,
    Zeta: Zeta,
    zeta: zeta,
    zfr: zfr,
    Zfr: Zfr,
    ZHcy: ZHcy,
    zhcy: zhcy,
    zigrarr: zigrarr,
    zopf: zopf,
    Zopf: Zopf,
    Zscr: Zscr,
    zscr: zscr,
    zwj: zwj,
    zwnj: zwnj,
    'default': entities$1
  });

  var Aacute = "Á";
  var aacute = "á";
  var Acirc = "Â";
  var acirc = "â";
  var acute = "´";
  var AElig = "Æ";
  var aelig = "æ";
  var Agrave = "À";
  var agrave = "à";
  var amp$1 = "&";
  var AMP = "&";
  var Aring = "Å";
  var aring = "å";
  var Atilde = "Ã";
  var atilde = "ã";
  var Auml = "Ä";
  var auml = "ä";
  var brvbar = "¦";
  var Ccedil = "Ç";
  var ccedil = "ç";
  var cedil = "¸";
  var cent = "¢";
  var copy = "©";
  var COPY = "©";
  var curren = "¤";
  var deg = "°";
  var divide = "÷";
  var Eacute = "É";
  var eacute = "é";
  var Ecirc = "Ê";
  var ecirc = "ê";
  var Egrave = "È";
  var egrave = "è";
  var ETH = "Ð";
  var eth = "ð";
  var Euml = "Ë";
  var euml = "ë";
  var frac12 = "½";
  var frac14 = "¼";
  var frac34 = "¾";
  var gt$1 = ">";
  var GT = ">";
  var Iacute = "Í";
  var iacute = "í";
  var Icirc = "Î";
  var icirc = "î";
  var iexcl = "¡";
  var Igrave = "Ì";
  var igrave = "ì";
  var iquest = "¿";
  var Iuml = "Ï";
  var iuml = "ï";
  var laquo = "«";
  var lt$1 = "<";
  var LT = "<";
  var macr = "¯";
  var micro = "µ";
  var middot = "·";
  var nbsp = " ";
  var not = "¬";
  var Ntilde = "Ñ";
  var ntilde = "ñ";
  var Oacute = "Ó";
  var oacute = "ó";
  var Ocirc = "Ô";
  var ocirc = "ô";
  var Ograve = "Ò";
  var ograve = "ò";
  var ordf = "ª";
  var ordm = "º";
  var Oslash = "Ø";
  var oslash = "ø";
  var Otilde = "Õ";
  var otilde = "õ";
  var Ouml = "Ö";
  var ouml = "ö";
  var para = "¶";
  var plusmn = "±";
  var pound = "£";
  var quot$1 = "\"";
  var QUOT = "\"";
  var raquo = "»";
  var reg = "®";
  var REG = "®";
  var sect = "§";
  var shy = "­";
  var sup1 = "¹";
  var sup2 = "²";
  var sup3 = "³";
  var szlig = "ß";
  var THORN = "Þ";
  var thorn = "þ";
  var times = "×";
  var Uacute = "Ú";
  var uacute = "ú";
  var Ucirc = "Û";
  var ucirc = "û";
  var Ugrave = "Ù";
  var ugrave = "ù";
  var uml = "¨";
  var Uuml = "Ü";
  var uuml = "ü";
  var Yacute = "Ý";
  var yacute = "ý";
  var yen = "¥";
  var yuml = "ÿ";
  var legacy$1 = {
  	Aacute: Aacute,
  	aacute: aacute,
  	Acirc: Acirc,
  	acirc: acirc,
  	acute: acute,
  	AElig: AElig,
  	aelig: aelig,
  	Agrave: Agrave,
  	agrave: agrave,
  	amp: amp$1,
  	AMP: AMP,
  	Aring: Aring,
  	aring: aring,
  	Atilde: Atilde,
  	atilde: atilde,
  	Auml: Auml,
  	auml: auml,
  	brvbar: brvbar,
  	Ccedil: Ccedil,
  	ccedil: ccedil,
  	cedil: cedil,
  	cent: cent,
  	copy: copy,
  	COPY: COPY,
  	curren: curren,
  	deg: deg,
  	divide: divide,
  	Eacute: Eacute,
  	eacute: eacute,
  	Ecirc: Ecirc,
  	ecirc: ecirc,
  	Egrave: Egrave,
  	egrave: egrave,
  	ETH: ETH,
  	eth: eth,
  	Euml: Euml,
  	euml: euml,
  	frac12: frac12,
  	frac14: frac14,
  	frac34: frac34,
  	gt: gt$1,
  	GT: GT,
  	Iacute: Iacute,
  	iacute: iacute,
  	Icirc: Icirc,
  	icirc: icirc,
  	iexcl: iexcl,
  	Igrave: Igrave,
  	igrave: igrave,
  	iquest: iquest,
  	Iuml: Iuml,
  	iuml: iuml,
  	laquo: laquo,
  	lt: lt$1,
  	LT: LT,
  	macr: macr,
  	micro: micro,
  	middot: middot,
  	nbsp: nbsp,
  	not: not,
  	Ntilde: Ntilde,
  	ntilde: ntilde,
  	Oacute: Oacute,
  	oacute: oacute,
  	Ocirc: Ocirc,
  	ocirc: ocirc,
  	Ograve: Ograve,
  	ograve: ograve,
  	ordf: ordf,
  	ordm: ordm,
  	Oslash: Oslash,
  	oslash: oslash,
  	Otilde: Otilde,
  	otilde: otilde,
  	Ouml: Ouml,
  	ouml: ouml,
  	para: para,
  	plusmn: plusmn,
  	pound: pound,
  	quot: quot$1,
  	QUOT: QUOT,
  	raquo: raquo,
  	reg: reg,
  	REG: REG,
  	sect: sect,
  	shy: shy,
  	sup1: sup1,
  	sup2: sup2,
  	sup3: sup3,
  	szlig: szlig,
  	THORN: THORN,
  	thorn: thorn,
  	times: times,
  	Uacute: Uacute,
  	uacute: uacute,
  	Ucirc: Ucirc,
  	ucirc: ucirc,
  	Ugrave: Ugrave,
  	ugrave: ugrave,
  	uml: uml,
  	Uuml: Uuml,
  	uuml: uuml,
  	Yacute: Yacute,
  	yacute: yacute,
  	yen: yen,
  	yuml: yuml
  };

  var legacy$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Aacute: Aacute,
    aacute: aacute,
    Acirc: Acirc,
    acirc: acirc,
    acute: acute,
    AElig: AElig,
    aelig: aelig,
    Agrave: Agrave,
    agrave: agrave,
    amp: amp$1,
    AMP: AMP,
    Aring: Aring,
    aring: aring,
    Atilde: Atilde,
    atilde: atilde,
    Auml: Auml,
    auml: auml,
    brvbar: brvbar,
    Ccedil: Ccedil,
    ccedil: ccedil,
    cedil: cedil,
    cent: cent,
    copy: copy,
    COPY: COPY,
    curren: curren,
    deg: deg,
    divide: divide,
    Eacute: Eacute,
    eacute: eacute,
    Ecirc: Ecirc,
    ecirc: ecirc,
    Egrave: Egrave,
    egrave: egrave,
    ETH: ETH,
    eth: eth,
    Euml: Euml,
    euml: euml,
    frac12: frac12,
    frac14: frac14,
    frac34: frac34,
    gt: gt$1,
    GT: GT,
    Iacute: Iacute,
    iacute: iacute,
    Icirc: Icirc,
    icirc: icirc,
    iexcl: iexcl,
    Igrave: Igrave,
    igrave: igrave,
    iquest: iquest,
    Iuml: Iuml,
    iuml: iuml,
    laquo: laquo,
    lt: lt$1,
    LT: LT,
    macr: macr,
    micro: micro,
    middot: middot,
    nbsp: nbsp,
    not: not,
    Ntilde: Ntilde,
    ntilde: ntilde,
    Oacute: Oacute,
    oacute: oacute,
    Ocirc: Ocirc,
    ocirc: ocirc,
    Ograve: Ograve,
    ograve: ograve,
    ordf: ordf,
    ordm: ordm,
    Oslash: Oslash,
    oslash: oslash,
    Otilde: Otilde,
    otilde: otilde,
    Ouml: Ouml,
    ouml: ouml,
    para: para,
    plusmn: plusmn,
    pound: pound,
    quot: quot$1,
    QUOT: QUOT,
    raquo: raquo,
    reg: reg,
    REG: REG,
    sect: sect,
    shy: shy,
    sup1: sup1,
    sup2: sup2,
    sup3: sup3,
    szlig: szlig,
    THORN: THORN,
    thorn: thorn,
    times: times,
    Uacute: Uacute,
    uacute: uacute,
    Ucirc: Ucirc,
    ucirc: ucirc,
    Ugrave: Ugrave,
    ugrave: ugrave,
    uml: uml,
    Uuml: Uuml,
    uuml: uuml,
    Yacute: Yacute,
    yacute: yacute,
    yen: yen,
    yuml: yuml,
    'default': legacy$1
  });

  var amp = "&";
  var apos = "'";
  var gt = ">";
  var lt = "<";
  var quot = "\"";
  var xml = {
  	amp: amp,
  	apos: apos,
  	gt: gt,
  	lt: lt,
  	quot: quot
  };

  var xml$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    amp: amp,
    apos: apos,
    gt: gt,
    lt: lt,
    quot: quot,
    'default': xml
  });

  var decode$1 = {
  	"0": 65533,
  	"128": 8364,
  	"130": 8218,
  	"131": 402,
  	"132": 8222,
  	"133": 8230,
  	"134": 8224,
  	"135": 8225,
  	"136": 710,
  	"137": 8240,
  	"138": 352,
  	"139": 8249,
  	"140": 338,
  	"142": 381,
  	"145": 8216,
  	"146": 8217,
  	"147": 8220,
  	"148": 8221,
  	"149": 8226,
  	"150": 8211,
  	"151": 8212,
  	"152": 732,
  	"153": 8482,
  	"154": 353,
  	"155": 8250,
  	"156": 339,
  	"158": 382,
  	"159": 376
  };

  var decode$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': decode$1
  });

  var require$$0$1 = getCjsExportFromNamespace(decode$2);

  var decode_codepoint = createCommonjsModule(function (module, exports) {

    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var decode_json_1 = __importDefault(require$$0$1); // Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119


    var fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function (codePoint) {
      var output = "";

      if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
        codePoint = 0xdc00 | codePoint & 0x3ff;
      }

      output += String.fromCharCode(codePoint);
      return output;
    };

    function decodeCodePoint(codePoint) {
      if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
        return "\uFFFD";
      }

      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }

      return fromCodePoint(codePoint);
    }

    exports.default = decodeCodePoint;
  });
  unwrapExports(decode_codepoint);

  var require$$1$1 = getCjsExportFromNamespace(entities$2);

  var require$$1 = getCjsExportFromNamespace(legacy$2);

  var require$$0 = getCjsExportFromNamespace(xml$1);

  var require$$3 = decode_codepoint;

  var decode = createCommonjsModule(function (module, exports) {

    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;

    var entities_json_1 = __importDefault(require$$1$1);

    var legacy_json_1 = __importDefault(require$$1);

    var xml_json_1 = __importDefault(require$$0);

    var decode_codepoint_1 = __importDefault(require$$3);

    var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);

    function getStrictDecoder(map) {
      var replace = getReplacer(map);
      return function (str) {
        return String(str).replace(strictEntityRe, replace);
      };
    }

    var sorter = function (a, b) {
      return a < b ? 1 : -1;
    };

    exports.decodeHTML = function () {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys = Object.keys(entities_json_1.default).sort(sorter);

      for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
          keys[i] += ";?";
          j++;
        } else {
          keys[i] += ";";
        }
      }

      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);

      function replacer(str) {
        if (str.substr(-1) !== ";") str += ";";
        return replace(str);
      } // TODO consider creating a merged map


      return function (str) {
        return String(str).replace(re, replacer);
      };
    }();

    function getReplacer(map) {
      return function replace(str) {
        if (str.charAt(1) === "#") {
          var secondChar = str.charAt(2);

          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str.substr(3), 16));
          }

          return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing


        return map[str.slice(1, -1)] || str;
      };
    }
  });
  unwrapExports(decode);
  decode.decodeHTML;
  decode.decodeHTMLStrict;
  decode.decodeXML;

  var encode = createCommonjsModule(function (module, exports) {

    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;

    var xml_json_1 = __importDefault(require$$0);

    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using XML entities.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */

    exports.encodeXML = getASCIIEncoder(inverseXML);

    var entities_json_1 = __importDefault(require$$1$1);

    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    /**
     * Encodes all entities and non-ASCII characters in the input.
     *
     * This includes characters that are valid ASCII characters in HTML documents.
     * For example `#` will be encoded as `&num;`. To get a more compact output,
     * consider using the `encodeNonAsciiHTML` function.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */

    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in HTML
     * documents using HTML entities.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */

    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);

    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }

    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];

      for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];

        if (k.length === 1) {
          // Add value to single array
          single.push("\\" + k);
        } else {
          // Add value to multiple array
          multiple.push(k);
        }
      } // Add ranges to single characters.


      single.sort();

      for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;

        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }

        var count = 1 + end - start; // We want to replace at least three characters

        if (count < 3) continue;
        single.splice(start, count, single[start] + "-" + single[end]);
      }

      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    } // /[^\0-\x7F]/gu


    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    var getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    function (str) {
      return str.codePointAt(0);
    } : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function (c) {
      return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;
    };

    function singleCharReplacer(c) {
      return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }

    function getInverse(inverse, re) {
      return function (data) {
        return data.replace(re, function (name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }

    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using numeric hexadecimal reference (eg. `&#xfc;`).
     *
     * Have a look at `escapeUTF8` if you want a more concise output at the expense
     * of reduced transportability.
     *
     * @param data String to escape.
     */

    function escape(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }

    exports.escape = escape;
    /**
     * Encodes all characters not valid in XML documents using numeric hexadecimal
     * reference (eg. `&#xfc;`).
     *
     * Note that the output will be character-set dependent.
     *
     * @param data String to escape.
     */

    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }

    exports.escapeUTF8 = escapeUTF8;

    function getASCIIEncoder(obj) {
      return function (data) {
        return data.replace(reEscapeChars, function (c) {
          return obj[c] || singleCharReplacer(c);
        });
      };
    }
  });
  unwrapExports(encode);
  encode.escapeUTF8;
  encode.escape;
  encode.encodeNonAsciiHTML;
  encode.encodeHTML;
  encode.encodeXML;

  var decode_1 = decode;

  var encode_1 = encode;

  var lib$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    /**
     * Decodes a string with entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeXML` or `decodeHTML` directly.
     */

    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }

    exports.decode = decode;
    /**
     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
     */

    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }

    exports.decodeStrict = decodeStrict;
    /**
     * Encodes a string with entities.
     *
     * @param data String to encode.
     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
     */

    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }

    exports.encode = encode;
    var encode_2 = encode_1;
    Object.defineProperty(exports, "encodeXML", {
      enumerable: true,
      get: function () {
        return encode_2.encodeXML;
      }
    });
    Object.defineProperty(exports, "encodeHTML", {
      enumerable: true,
      get: function () {
        return encode_2.encodeHTML;
      }
    });
    Object.defineProperty(exports, "encodeNonAsciiHTML", {
      enumerable: true,
      get: function () {
        return encode_2.encodeNonAsciiHTML;
      }
    });
    Object.defineProperty(exports, "escape", {
      enumerable: true,
      get: function () {
        return encode_2.escape;
      }
    });
    Object.defineProperty(exports, "escapeUTF8", {
      enumerable: true,
      get: function () {
        return encode_2.escapeUTF8;
      }
    }); // Legacy aliases (deprecated)

    Object.defineProperty(exports, "encodeHTML4", {
      enumerable: true,
      get: function () {
        return encode_2.encodeHTML;
      }
    });
    Object.defineProperty(exports, "encodeHTML5", {
      enumerable: true,
      get: function () {
        return encode_2.encodeHTML;
      }
    });
    var decode_2 = decode_1;
    Object.defineProperty(exports, "decodeXML", {
      enumerable: true,
      get: function () {
        return decode_2.decodeXML;
      }
    });
    Object.defineProperty(exports, "decodeHTML", {
      enumerable: true,
      get: function () {
        return decode_2.decodeHTML;
      }
    });
    Object.defineProperty(exports, "decodeHTMLStrict", {
      enumerable: true,
      get: function () {
        return decode_2.decodeHTMLStrict;
      }
    }); // Legacy aliases (deprecated)

    Object.defineProperty(exports, "decodeHTML4", {
      enumerable: true,
      get: function () {
        return decode_2.decodeHTML;
      }
    });
    Object.defineProperty(exports, "decodeHTML5", {
      enumerable: true,
      get: function () {
        return decode_2.decodeHTML;
      }
    });
    Object.defineProperty(exports, "decodeHTML4Strict", {
      enumerable: true,
      get: function () {
        return decode_2.decodeHTMLStrict;
      }
    });
    Object.defineProperty(exports, "decodeHTML5Strict", {
      enumerable: true,
      get: function () {
        return decode_2.decodeHTMLStrict;
      }
    });
    Object.defineProperty(exports, "decodeXMLStrict", {
      enumerable: true,
      get: function () {
        return decode_2.decodeXML;
      }
    });
  });
  unwrapExports(lib$2);
  lib$2.decodeXMLStrict;
  lib$2.decodeHTML5Strict;
  lib$2.decodeHTML4Strict;
  lib$2.decodeHTML5;
  lib$2.decodeHTML4;
  lib$2.decodeHTMLStrict;
  lib$2.decodeHTML;
  lib$2.decodeXML;
  lib$2.encodeHTML5;
  lib$2.encodeHTML4;
  lib$2.escapeUTF8;
  lib$2.escape;
  lib$2.encodeNonAsciiHTML;
  lib$2.encodeHTML;
  lib$2.encodeXML;
  lib$2.encode;
  lib$2.decodeStrict;
  lib$2.decode;

  var elementNames = {
  	altglyph: "altGlyph",
  	altglyphdef: "altGlyphDef",
  	altglyphitem: "altGlyphItem",
  	animatecolor: "animateColor",
  	animatemotion: "animateMotion",
  	animatetransform: "animateTransform",
  	clippath: "clipPath",
  	feblend: "feBlend",
  	fecolormatrix: "feColorMatrix",
  	fecomponenttransfer: "feComponentTransfer",
  	fecomposite: "feComposite",
  	feconvolvematrix: "feConvolveMatrix",
  	fediffuselighting: "feDiffuseLighting",
  	fedisplacementmap: "feDisplacementMap",
  	fedistantlight: "feDistantLight",
  	fedropshadow: "feDropShadow",
  	feflood: "feFlood",
  	fefunca: "feFuncA",
  	fefuncb: "feFuncB",
  	fefuncg: "feFuncG",
  	fefuncr: "feFuncR",
  	fegaussianblur: "feGaussianBlur",
  	feimage: "feImage",
  	femerge: "feMerge",
  	femergenode: "feMergeNode",
  	femorphology: "feMorphology",
  	feoffset: "feOffset",
  	fepointlight: "fePointLight",
  	fespecularlighting: "feSpecularLighting",
  	fespotlight: "feSpotLight",
  	fetile: "feTile",
  	feturbulence: "feTurbulence",
  	foreignobject: "foreignObject",
  	glyphref: "glyphRef",
  	lineargradient: "linearGradient",
  	radialgradient: "radialGradient",
  	textpath: "textPath"
  };
  var attributeNames = {
  	definitionurl: "definitionURL",
  	attributename: "attributeName",
  	attributetype: "attributeType",
  	basefrequency: "baseFrequency",
  	baseprofile: "baseProfile",
  	calcmode: "calcMode",
  	clippathunits: "clipPathUnits",
  	diffuseconstant: "diffuseConstant",
  	edgemode: "edgeMode",
  	filterunits: "filterUnits",
  	glyphref: "glyphRef",
  	gradienttransform: "gradientTransform",
  	gradientunits: "gradientUnits",
  	kernelmatrix: "kernelMatrix",
  	kernelunitlength: "kernelUnitLength",
  	keypoints: "keyPoints",
  	keysplines: "keySplines",
  	keytimes: "keyTimes",
  	lengthadjust: "lengthAdjust",
  	limitingconeangle: "limitingConeAngle",
  	markerheight: "markerHeight",
  	markerunits: "markerUnits",
  	markerwidth: "markerWidth",
  	maskcontentunits: "maskContentUnits",
  	maskunits: "maskUnits",
  	numoctaves: "numOctaves",
  	pathlength: "pathLength",
  	patterncontentunits: "patternContentUnits",
  	patterntransform: "patternTransform",
  	patternunits: "patternUnits",
  	pointsatx: "pointsAtX",
  	pointsaty: "pointsAtY",
  	pointsatz: "pointsAtZ",
  	preservealpha: "preserveAlpha",
  	preserveaspectratio: "preserveAspectRatio",
  	primitiveunits: "primitiveUnits",
  	refx: "refX",
  	refy: "refY",
  	repeatcount: "repeatCount",
  	repeatdur: "repeatDur",
  	requiredextensions: "requiredExtensions",
  	requiredfeatures: "requiredFeatures",
  	specularconstant: "specularConstant",
  	specularexponent: "specularExponent",
  	spreadmethod: "spreadMethod",
  	startoffset: "startOffset",
  	stddeviation: "stdDeviation",
  	stitchtiles: "stitchTiles",
  	surfacescale: "surfaceScale",
  	systemlanguage: "systemLanguage",
  	tablevalues: "tableValues",
  	targetx: "targetX",
  	targety: "targetY",
  	textlength: "textLength",
  	viewbox: "viewBox",
  	viewtarget: "viewTarget",
  	xchannelselector: "xChannelSelector",
  	ychannelselector: "yChannelSelector",
  	zoomandpan: "zoomAndPan"
  };
  var foreignNames$1 = {
  	elementNames: elementNames,
  	attributeNames: attributeNames
  };

  var foreignNames$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    elementNames: elementNames,
    attributeNames: attributeNames,
    'default': foreignNames$1
  });

  var entities = lib$2;

  var foreignNames = getCjsExportFromNamespace(foreignNames$2);

  var domSerializer = createCommonjsModule(function (module) {
    /*
      Module dependencies
    */

    /* mixed-case SVG and MathML tags & attributes
       recognized by the HTML parser, see
       https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
    */
    foreignNames.elementNames.__proto__ = null;
    /* use as a simple dictionary */

    foreignNames.attributeNames.__proto__ = null;
    var unencodedElements = {
      __proto__: null,
      style: true,
      script: true,
      xmp: true,
      iframe: true,
      noembed: true,
      noframes: true,
      plaintext: true,
      noscript: true
    };
    /*
      Format attributes
    */

    function formatAttrs(attributes, opts) {
      if (!attributes) return;
      var output = '';
      var value; // Loop through the attributes

      for (var key in attributes) {
        value = attributes[key];

        if (output) {
          output += ' ';
        }

        if (opts.xmlMode === 'foreign') {
          /* fix up mixed-case attribute names */
          key = foreignNames.attributeNames[key] || key;
        }

        output += key;

        if (value !== null && value !== '' || opts.xmlMode) {
          output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value.replace(/\"/g, '&quot;')) + '"';
        }
      }

      return output;
    }
    /*
      Self-enclosing tags (stolen from node-htmlparser)
    */


    var singleTag = {
      __proto__: null,
      area: true,
      base: true,
      basefont: true,
      br: true,
      col: true,
      command: true,
      embed: true,
      frame: true,
      hr: true,
      img: true,
      input: true,
      isindex: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };

    var render = module.exports = function (dom, opts) {
      if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
      opts = opts || {};
      var output = '';

      for (var i = 0; i < dom.length; i++) {
        var elem = dom[i];
        if (elem.type === 'root') output += render(elem.children, opts);else if (esm.isTag(elem)) output += renderTag(elem, opts);else if (elem.type === esm.Directive) output += renderDirective(elem);else if (elem.type === esm.Comment) output += renderComment(elem);else if (elem.type === esm.CDATA) output += renderCdata(elem);else output += renderText(elem, opts);
      }

      return output;
    };

    var foreignModeIntegrationPoints = ['mi', 'mo', 'mn', 'ms', 'mtext', 'annotation-xml', 'foreignObject', 'desc', 'title'];

    function renderTag(elem, opts) {
      // Handle SVG / MathML in HTML
      if (opts.xmlMode === 'foreign') {
        /* fix up mixed-case element names */
        elem.name = foreignNames.elementNames[elem.name] || elem.name;
        /* exit foreign mode at integration points */

        if (elem.parent && foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0) opts = Object.assign({}, opts, {
          xmlMode: false
        });
      }

      if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
        opts = Object.assign({}, opts, {
          xmlMode: 'foreign'
        });
      }

      var tag = '<' + elem.name;
      var attribs = formatAttrs(elem.attribs, opts);

      if (attribs) {
        tag += ' ' + attribs;
      }

      if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
        tag += '/>';
      } else {
        tag += '>';

        if (elem.children) {
          tag += render(elem.children, opts);
        }

        if (!singleTag[elem.name] || opts.xmlMode) {
          tag += '</' + elem.name + '>';
        }
      }

      return tag;
    }

    function renderDirective(elem) {
      return '<' + elem.data + '>';
    }

    function renderText(elem, opts) {
      var data = elem.data || ''; // if entities weren't decoded, no need to encode them back

      if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
        data = entities.encodeXML(data);
      }

      return data;
    }

    function renderCdata(elem) {
      return '<![CDATA[' + elem.children[0].data + ']]>';
    }

    function renderComment(elem) {
      return '<!--' + elem.data + '-->';
    }
  });

  var isTag$1 = domelementtype.isTag;
  var stringify = {
    getInnerHTML: getInnerHTML,
    getOuterHTML: domSerializer,
    getText: getText
  };

  function getInnerHTML(elem, opts) {
    return elem.children ? elem.children.map(function (elem) {
      return domSerializer(elem, opts);
    }).join("") : "";
  }

  function getText(elem) {
    if (Array.isArray(elem)) return elem.map(getText).join("");
    if (isTag$1(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
    if (elem.type === domelementtype.CDATA) return getText(elem.children);
    if (elem.type === domelementtype.Text) return elem.data;
    return "";
  }
  stringify.getInnerHTML;
  stringify.getOuterHTML;
  stringify.getText;

  var traversal = createCommonjsModule(function (module, exports) {
    var getChildren = exports.getChildren = function (elem) {
      return elem.children;
    };

    var getParent = exports.getParent = function (elem) {
      return elem.parent;
    };

    exports.getSiblings = function (elem) {
      var parent = getParent(elem);
      return parent ? getChildren(parent) : [elem];
    };

    exports.getAttributeValue = function (elem, name) {
      return elem.attribs && elem.attribs[name];
    };

    exports.hasAttrib = function (elem, name) {
      return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
    };

    exports.getName = function (elem) {
      return elem.name;
    };
  });
  traversal.getChildren;
  traversal.getParent;
  traversal.getSiblings;
  traversal.getAttributeValue;
  traversal.hasAttrib;
  traversal.getName;

  var removeElement = function (elem) {
    if (elem.prev) elem.prev.next = elem.next;
    if (elem.next) elem.next.prev = elem.prev;

    if (elem.parent) {
      var childs = elem.parent.children;
      childs.splice(childs.lastIndexOf(elem), 1);
    }
  };

  var replaceElement = function (elem, replacement) {
    var prev = replacement.prev = elem.prev;

    if (prev) {
      prev.next = replacement;
    }

    var next = replacement.next = elem.next;

    if (next) {
      next.prev = replacement;
    }

    var parent = replacement.parent = elem.parent;

    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
    }
  };

  var appendChild = function (elem, child) {
    child.parent = elem;

    if (elem.children.push(child) !== 1) {
      var sibling = elem.children[elem.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
      child.next = null;
    }
  };

  var append = function (elem, next) {
    var parent = elem.parent,
        currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;

    if (currNext) {
      currNext.prev = next;

      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };

  var prepend = function (elem, prev) {
    var parent = elem.parent;

    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(elem), 0, prev);
    }

    if (elem.prev) {
      elem.prev.next = prev;
    }

    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };

  var manipulation = {
    removeElement: removeElement,
    replaceElement: replaceElement,
    appendChild: appendChild,
    append: append,
    prepend: prepend
  };

  var isTag = domelementtype.isTag;
  var querying = {
    filter: filter,
    find: find,
    findOneChild: findOneChild,
    findOne: findOne,
    existsOne: existsOne,
    findAll: findAll
  };

  function filter(test, element, recurse, limit) {
    if (!Array.isArray(element)) element = [element];

    if (typeof limit !== "number" || !isFinite(limit)) {
      limit = Infinity;
    }

    return find(test, element, recurse !== false, limit);
  }

  function find(test, elems, recurse, limit) {
    var result = [],
        childs;

    for (var i = 0, j = elems.length; i < j; i++) {
      if (test(elems[i])) {
        result.push(elems[i]);
        if (--limit <= 0) break;
      }

      childs = elems[i].children;

      if (recurse && childs && childs.length > 0) {
        childs = find(test, childs, recurse, limit);
        result = result.concat(childs);
        limit -= childs.length;
        if (limit <= 0) break;
      }
    }

    return result;
  }

  function findOneChild(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
      if (test(elems[i])) return elems[i];
    }

    return null;
  }

  function findOne(test, elems) {
    var elem = null;

    for (var i = 0, l = elems.length; i < l && !elem; i++) {
      if (!isTag(elems[i])) {
        continue;
      } else if (test(elems[i])) {
        elem = elems[i];
      } else if (elems[i].children.length > 0) {
        elem = findOne(test, elems[i].children);
      }
    }

    return elem;
  }

  function existsOne(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
      if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
        return true;
      }
    }

    return false;
  }

  function findAll(test, rootElems) {
    var result = [];
    var stack = rootElems.slice();

    while (stack.length) {
      var elem = stack.shift();
      if (!isTag(elem)) continue;

      if (elem.children && elem.children.length > 0) {
        stack.unshift.apply(stack, elem.children);
      }

      if (test(elem)) result.push(elem);
    }

    return result;
  }
  querying.filter;
  querying.find;
  querying.findOneChild;
  querying.findOne;
  querying.existsOne;
  querying.findAll;

  var legacy = createCommonjsModule(function (module, exports) {
    var isTag = exports.isTag = domelementtype.isTag;

    exports.testElement = function (options, element) {
      for (var key in options) {
        if (!options.hasOwnProperty(key)) ;else if (key === "tag_name") {
          if (!isTag(element) || !options.tag_name(element.name)) {
            return false;
          }
        } else if (key === "tag_type") {
          if (!options.tag_type(element.type)) return false;
        } else if (key === "tag_contains") {
          if (isTag(element) || !options.tag_contains(element.data)) {
            return false;
          }
        } else if (!element.attribs || !options[key](element.attribs[key])) {
          return false;
        }
      }

      return true;
    };

    var Checks = {
      tag_name: function (name) {
        if (typeof name === "function") {
          return function (elem) {
            return isTag(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return isTag;
        } else {
          return function (elem) {
            return isTag(elem) && elem.name === name;
          };
        }
      },
      tag_type: function (type) {
        if (typeof type === "function") {
          return function (elem) {
            return type(elem.type);
          };
        } else {
          return function (elem) {
            return elem.type === type;
          };
        }
      },
      tag_contains: function (data) {
        if (typeof data === "function") {
          return function (elem) {
            return !isTag(elem) && data(elem.data);
          };
        } else {
          return function (elem) {
            return !isTag(elem) && elem.data === data;
          };
        }
      }
    };

    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function (elem) {
          return elem.attribs && value(elem.attribs[attrib]);
        };
      } else {
        return function (elem) {
          return elem.attribs && elem.attribs[attrib] === value;
        };
      }
    }

    function combineFuncs(a, b) {
      return function (elem) {
        return a(elem) || b(elem);
      };
    }

    exports.getElements = function (options, element, recurse, limit) {
      var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
    };

    exports.getElementById = function (id, element, recurse) {
      if (!Array.isArray(element)) element = [element];
      return this.findOne(getAttribCheck("id", id), element, recurse !== false);
    };

    exports.getElementsByTagName = function (name, element, recurse, limit) {
      return this.filter(Checks.tag_name(name), element, recurse, limit);
    };

    exports.getElementsByTagType = function (type, element, recurse, limit) {
      return this.filter(Checks.tag_type(type), element, recurse, limit);
    };
  });
  legacy.isTag;
  legacy.testElement;
  legacy.getElements;
  legacy.getElementById;
  legacy.getElementsByTagName;
  legacy.getElementsByTagType;

  var helpers = createCommonjsModule(function (module, exports) {
    // removeSubsets
    // Given an array of nodes, remove any member that is contained by another.
    exports.removeSubsets = function (nodes) {
      var idx = nodes.length,
          node,
          ancestor,
          replace; // Check if each node (or one of its ancestors) is already contained in the
      // array.

      while (--idx > -1) {
        node = ancestor = nodes[idx]; // Temporarily remove the node under consideration

        nodes[idx] = null;
        replace = true;

        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }

          ancestor = ancestor.parent;
        } // If the node has been found to be unique, re-insert it.


        if (replace) {
          nodes[idx] = node;
        }
      }

      return nodes;
    }; // Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition


    var POSITION = {
      DISCONNECTED: 1,
      PRECEDING: 2,
      FOLLOWING: 4,
      CONTAINS: 8,
      CONTAINED_BY: 16
    }; // Compare the position of one node against another node in any other document.
    // The return value is a bitmask with the following values:
    //
    // document order:
    // > There is an ordering, document order, defined on all the nodes in the
    // > document corresponding to the order in which the first character of the
    // > XML representation of each node occurs in the XML representation of the
    // > document after expansion of general entities. Thus, the document element
    // > node will be the first node. Element nodes occur before their children.
    // > Thus, document order orders element nodes in order of the occurrence of
    // > their start-tag in the XML (after expansion of entities). The attribute
    // > nodes of an element occur after the element and before its children. The
    // > relative order of attribute nodes is implementation-dependent./
    // Source:
    // http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
    //
    // @argument {Node} nodaA The first node to use in the comparison
    // @argument {Node} nodeB The second node to use in the comparison
    //
    // @return {Number} A bitmask describing the input nodes' relative position.
    //         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
    //         a description of these values.

    var comparePos = exports.compareDocumentPosition = function (nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      var current, sharedParent, siblings, aSibling, bSibling, idx;

      if (nodeA === nodeB) {
        return 0;
      }

      current = nodeA;

      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }

      current = nodeB;

      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }

      idx = 0;

      while (aParents[idx] === bParents[idx]) {
        idx++;
      }

      if (idx === 0) {
        return POSITION.DISCONNECTED;
      }

      sharedParent = aParents[idx - 1];
      siblings = sharedParent.children;
      aSibling = aParents[idx];
      bSibling = bParents[idx];

      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
        }

        return POSITION.FOLLOWING;
      } else {
        if (sharedParent === nodeA) {
          return POSITION.PRECEDING | POSITION.CONTAINS;
        }

        return POSITION.PRECEDING;
      }
    }; // Sort an array of nodes based on their relative position in the document and
    // remove any duplicate nodes. If the array contains nodes that do not belong
    // to the same document, sort order is unspecified.
    //
    // @argument {Array} nodes Array of DOM nodes
    //
    // @returns {Array} collection of unique nodes, sorted in document order


    exports.uniqueSort = function (nodes) {
      var idx = nodes.length,
          node,
          position;
      nodes = nodes.slice();

      while (--idx > -1) {
        node = nodes[idx];
        position = nodes.indexOf(node);

        if (position > -1 && position < idx) {
          nodes.splice(idx, 1);
        }
      }

      nodes.sort(function (a, b) {
        var relative = comparePos(a, b);

        if (relative & POSITION.PRECEDING) {
          return -1;
        } else if (relative & POSITION.FOLLOWING) {
          return 1;
        }

        return 0;
      });
      return nodes;
    };
  });
  helpers.removeSubsets;
  helpers.compareDocumentPosition;
  helpers.uniqueSort;

  var domutils = createCommonjsModule(function (module) {
    var DomUtils = module.exports;
    [stringify, traversal, manipulation, querying, legacy, helpers].forEach(function (ext) {
      Object.keys(ext).forEach(function (key) {
        DomUtils[key] = ext[key].bind(DomUtils);
      });
    });
  });

  var boolbase = {
    trueFunc: function trueFunc() {
      return true;
    },
    falseFunc: function falseFunc() {
      return false;
    }
  };

  var parse_1$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parse;
    var reName = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi; // Modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87

    var reAttr = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])((?:[^\\]|\\[^])*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/;
    var actionTypes = {
      undefined: "exists",
      "": "equals",
      "~": "element",
      "^": "start",
      $: "end",
      "*": "any",
      "!": "not",
      "|": "hyphen"
    };
    var Traversals = {
      ">": "child",
      "<": "parent",
      "~": "sibling",
      "+": "adjacent"
    };
    var attribSelectors = {
      "#": ["id", "equals"],
      ".": ["class", "element"]
    }; // Pseudos, whose data property is parsed as well.

    var unpackPseudos = new Set(["has", "not", "matches", "is", "host", "host-context"]);
    var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
    var quotes = new Set(['"', "'"]); // Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152

    function funescape(_, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 0x10000; // NaN means non-codepoint

      return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
      String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
    }

    function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
    }

    function isWhitespace(c) {
      return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
    }

    function parse(selector, options) {
      var subselects = [];
      selector = parseSelector(subselects, "" + selector, options);

      if (selector !== "") {
        throw new Error("Unmatched selector: " + selector);
      }

      return subselects;
    }

    function parseSelector(subselects, selector, options) {
      var _a, _b;

      if (options === void 0) {
        options = {};
      }

      var tokens = [];
      var sawWS = false;

      function getName() {
        var match = selector.match(reName);

        if (!match) {
          throw new Error("Expected name, found " + selector);
        }

        var sub = match[0];
        selector = selector.substr(sub.length);
        return unescapeCSS(sub);
      }

      function stripWhitespace(start) {
        while (isWhitespace(selector.charAt(start))) start++;

        selector = selector.substr(start);
      }

      function isEscaped(pos) {
        var slashCount = 0;

        while (selector.charAt(--pos) === "\\") slashCount++;

        return (slashCount & 1) === 1;
      }

      stripWhitespace(0);

      while (selector !== "") {
        var firstChar = selector.charAt(0);

        if (isWhitespace(firstChar)) {
          sawWS = true;
          stripWhitespace(1);
        } else if (firstChar in Traversals) {
          tokens.push({
            type: Traversals[firstChar]
          });
          sawWS = false;
          stripWhitespace(1);
        } else if (firstChar === ",") {
          if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
          }

          subselects.push(tokens);
          tokens = [];
          sawWS = false;
          stripWhitespace(1);
        } else {
          if (sawWS) {
            if (tokens.length > 0) {
              tokens.push({
                type: "descendant"
              });
            }

            sawWS = false;
          }

          if (firstChar === "*") {
            selector = selector.substr(1);
            tokens.push({
              type: "universal"
            });
          } else if (firstChar in attribSelectors) {
            var _c = attribSelectors[firstChar],
                name_1 = _c[0],
                action = _c[1];
            selector = selector.substr(1);
            tokens.push({
              type: "attribute",
              name: name_1,
              action: action,
              value: getName(),
              ignoreCase: false
            });
          } else if (firstChar === "[") {
            selector = selector.substr(1);
            var attributeMatch = selector.match(reAttr);

            if (!attributeMatch) {
              throw new Error("Malformed attribute selector: " + selector);
            }

            var completeSelector = attributeMatch[0],
                baseName = attributeMatch[1],
                actionType = attributeMatch[2],
                _d = attributeMatch[4],
                quotedValue = _d === void 0 ? "" : _d,
                _e = attributeMatch[5],
                value = _e === void 0 ? quotedValue : _e,
                ignoreCase = attributeMatch[6];
            selector = selector.substr(completeSelector.length);
            var name_2 = unescapeCSS(baseName);

            if ((_a = options.lowerCaseAttributeNames) !== null && _a !== void 0 ? _a : !options.xmlMode) {
              name_2 = name_2.toLowerCase();
            }

            tokens.push({
              type: "attribute",
              name: name_2,
              action: actionTypes[actionType],
              value: unescapeCSS(value),
              ignoreCase: !!ignoreCase
            });
          } else if (firstChar === ":") {
            if (selector.charAt(1) === ":") {
              selector = selector.substr(2);
              tokens.push({
                type: "pseudo-element",
                name: getName().toLowerCase()
              });
              continue;
            }

            selector = selector.substr(1);
            var name_3 = getName().toLowerCase();
            var data = null;

            if (selector.startsWith("(")) {
              if (unpackPseudos.has(name_3)) {
                var quot = selector.charAt(1);
                var quoted = quotes.has(quot);
                selector = selector.substr(quoted ? 2 : 1);
                data = [];
                selector = parseSelector(data, selector, options);

                if (quoted) {
                  if (!selector.startsWith(quot)) {
                    throw new Error("Unmatched quotes in :" + name_3);
                  } else {
                    selector = selector.substr(1);
                  }
                }

                if (!selector.startsWith(")")) {
                  throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
                }

                selector = selector.substr(1);
              } else {
                var pos = 1;
                var counter = 1;

                for (; counter > 0 && pos < selector.length; pos++) {
                  if (selector.charAt(pos) === "(" && !isEscaped(pos)) {
                    counter++;
                  } else if (selector.charAt(pos) === ")" && !isEscaped(pos)) {
                    counter--;
                  }
                }

                if (counter) {
                  throw new Error("Parenthesis not matched");
                }

                data = selector.substr(1, pos - 2);
                selector = selector.substr(pos);

                if (stripQuotesFromPseudos.has(name_3)) {
                  var quot = data.charAt(0);

                  if (quot === data.slice(-1) && quotes.has(quot)) {
                    data = data.slice(1, -1);
                  }

                  data = unescapeCSS(data);
                }
              }
            }

            tokens.push({
              type: "pseudo",
              name: name_3,
              data: data
            });
          } else if (reName.test(selector)) {
            var name_4 = getName();

            if ((_b = options.lowerCaseTags) !== null && _b !== void 0 ? _b : !options.xmlMode) {
              name_4 = name_4.toLowerCase();
            }

            tokens.push({
              type: "tag",
              name: name_4
            });
          } else {
            if (tokens.length && tokens[tokens.length - 1].type === "descendant") {
              tokens.pop();
            }

            addToken(subselects, tokens);
            return selector;
          }
        }
      }

      addToken(subselects, tokens);
      return selector;
    }

    function addToken(subselects, tokens) {
      if (subselects.length > 0 && tokens.length === 0) {
        throw new Error("Empty sub-selector");
      }

      subselects.push(tokens);
    }
  });
  unwrapExports(parse_1$2);

  var stringify_1 = createCommonjsModule(function (module, exports) {

    var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function () {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

      return r;
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var actionTypes = {
      equals: "",
      element: "~",
      start: "^",
      end: "$",
      any: "*",
      not: "!",
      hyphen: "|"
    };
    var charsToEscape = new Set(__spreadArrays(Object.keys(actionTypes).map(function (typeKey) {
      return actionTypes[typeKey];
    }).filter(Boolean), [":", "[", "]", " ", "\\"]));

    function stringify(token) {
      return token.map(stringifySubselector).join(", ");
    }

    exports.default = stringify;

    function stringifySubselector(token) {
      return token.map(stringifyToken).join("");
    }

    function stringifyToken(token) {
      switch (token.type) {
        // Simple types
        case "child":
          return " > ";

        case "parent":
          return " < ";

        case "sibling":
          return " ~ ";

        case "adjacent":
          return " + ";

        case "descendant":
          return " ";

        case "universal":
          return "*";

        case "tag":
          return escapeName(token.name);

        case "pseudo-element":
          return "::" + escapeName(token.name);

        case "pseudo":
          if (token.data === null) return ":" + escapeName(token.name);

          if (typeof token.data === "string") {
            return ":" + escapeName(token.name) + "(" + token.data + ")";
          }

          return ":" + escapeName(token.name) + "(" + stringify(token.data) + ")";

        case "attribute":
          if (token.action === "exists") {
            return "[" + escapeName(token.name) + "]";
          }

          if (token.name === "id" && token.action === "equals" && !token.ignoreCase) {
            return "#" + escapeName(token.value);
          }

          if (token.name === "class" && token.action === "element" && !token.ignoreCase) {
            return "." + escapeName(token.value);
          }

          return "[" + escapeName(token.name) + actionTypes[token.action] + "='" + escapeName(token.value) + "'" + (token.ignoreCase ? "i" : "") + "]";
      }
    }

    function escapeName(str) {
      return str.split("").map(function (c) {
        return charsToEscape.has(c) ? "\\" + c : c;
      }).join("");
    }
  });
  unwrapExports(stringify_1);

  var lib$1 = createCommonjsModule(function (module, exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function () {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };

    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stringify = exports.parse = void 0;

    __exportStar(parse_1$2, exports);

    var parse_1 = parse_1$2;
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function () {
        return __importDefault(parse_1).default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function () {
        return __importDefault(stringify_1).default;
      }
    });
  });
  unwrapExports(lib$1);
  lib$1.stringify;
  lib$1.parse;

  var universal = 50;
  var tag = 30;
  var attribute = 1;
  var pseudo = 0;
  var descendant = -1;
  var child = -1;
  var parent = -1;
  var sibling = -1;
  var adjacent = -1;
  var procedure$1 = {
  	universal: universal,
  	tag: tag,
  	attribute: attribute,
  	pseudo: pseudo,
  	descendant: descendant,
  	child: child,
  	parent: parent,
  	sibling: sibling,
  	adjacent: adjacent
  };

  var procedure$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    universal: universal,
    tag: tag,
    attribute: attribute,
    pseudo: pseudo,
    descendant: descendant,
    child: child,
    parent: parent,
    sibling: sibling,
    adjacent: adjacent,
    'default': procedure$1
  });

  var procedure = getCjsExportFromNamespace(procedure$2);

  var sort = sortByProcedure;
  /*
  	sort the parts of the passed selector,
  	as there is potential for optimization
  	(some types of selectors are faster than others)
  */

  var attributes$1 = {
    __proto__: null,
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4
  };

  function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);

    for (var i = 1; i < arr.length; i++) {
      var procNew = procs[i];
      if (procNew < 0) continue;

      for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
        var token = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = token;
        procs[j + 1] = procs[j];
        procs[j] = procNew;
      }
    }
  }

  function getProcedure(token) {
    var proc = procedure[token.type];

    if (proc === procedure.attribute) {
      proc = attributes$1[token.action];

      if (proc === attributes$1.equals && token.name === "id") {
        //prefer ID selectors (eg. #ID)
        proc = 9;
      }

      if (token.ignoreCase) {
        //ignoreCase adds some overhead, prefer "normal" token
        //this is a binary operation, to ensure it's still an int
        proc >>= 1;
      }
    } else if (proc === procedure.pseudo) {
      if (!token.data) {
        proc = 3;
      } else if (token.name === "has" || token.name === "contains") {
        proc = 0; //expensive in any case
      } else if (token.name === "matches" || token.name === "not") {
        proc = 0;

        for (var i = 0; i < token.data.length; i++) {
          //TODO better handling of complex selectors
          if (token.data[i].length !== 1) continue;
          var cur = getProcedure(token.data[i][0]); //avoid executing :has or :contains

          if (cur === 0) {
            proc = 0;
            break;
          }

          if (cur > proc) proc = cur;
        }

        if (token.data.length > 1 && proc > 0) proc -= 1;
      } else {
        proc = 1;
      }
    }

    return proc;
  }

  var falseFunc$4 = boolbase.falseFunc; //https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469

  var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
  /*
  	attribute selectors
  */

  var attributeRules = {
    __proto__: null,
    equals: function (next, data, options) {
      var name = data.name;
      var value = data.value;
      var adapter = options.adapter;

      if (data.ignoreCase) {
        value = value.toLowerCase();
        return function equalsIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.toLowerCase() === value && next(elem);
        };
      }

      return function equals(elem) {
        return adapter.getAttributeValue(elem, name) === value && next(elem);
      };
    },
    hyphen: function (next, data, options) {
      var name = data.name;
      var value = data.value;
      var len = value.length;
      var adapter = options.adapter;

      if (data.ignoreCase) {
        value = value.toLowerCase();
        return function hyphenIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
        };
      }

      return function hyphen(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.substr(0, len) === value && (attr.length === len || attr.charAt(len) === "-") && next(elem);
      };
    },
    element: function (next, data, options) {
      var name = data.name;
      var value = data.value;
      var adapter = options.adapter;

      if (/\s/.test(value)) {
        return falseFunc$4;
      }

      value = value.replace(reChars, "\\$&");
      var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
          flags = data.ignoreCase ? "i" : "",
          regex = new RegExp(pattern, flags);
      return function element(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && regex.test(attr) && next(elem);
      };
    },
    exists: function (next, data, options) {
      var name = data.name;
      var adapter = options.adapter;
      return function exists(elem) {
        return adapter.hasAttrib(elem, name) && next(elem);
      };
    },
    start: function (next, data, options) {
      var name = data.name;
      var value = data.value;
      var len = value.length;
      var adapter = options.adapter;

      if (len === 0) {
        return falseFunc$4;
      }

      if (data.ignoreCase) {
        value = value.toLowerCase();
        return function startIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
        };
      }

      return function start(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.substr(0, len) === value && next(elem);
      };
    },
    end: function (next, data, options) {
      var name = data.name;
      var value = data.value;
      var len = -value.length;
      var adapter = options.adapter;

      if (len === 0) {
        return falseFunc$4;
      }

      if (data.ignoreCase) {
        value = value.toLowerCase();
        return function endIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
        };
      }

      return function end(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.substr(len) === value && next(elem);
      };
    },
    any: function (next, data, options) {
      var name = data.name;
      var value = data.value;
      var adapter = options.adapter;

      if (value === "") {
        return falseFunc$4;
      }

      if (data.ignoreCase) {
        var regex = new RegExp(value.replace(reChars, "\\$&"), "i");
        return function anyIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && regex.test(attr) && next(elem);
        };
      }

      return function any(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.indexOf(value) >= 0 && next(elem);
      };
    },
    not: function (next, data, options) {
      var name = data.name;
      var value = data.value;
      var adapter = options.adapter;

      if (value === "") {
        return function notEmpty(elem) {
          return !!adapter.getAttributeValue(elem, name) && next(elem);
        };
      } else if (data.ignoreCase) {
        value = value.toLowerCase();
        return function notIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.toLowerCase() !== value && next(elem);
        };
      }

      return function not(elem) {
        return adapter.getAttributeValue(elem, name) !== value && next(elem);
      };
    }
  };
  var attributes = {
    compile: function (next, data, options) {
      if (options && options.strict && (data.ignoreCase || data.action === "not")) {
        throw new Error("Unsupported attribute selector");
      }

      return attributeRules[data.action](next, data, options);
    },
    rules: attributeRules
  };

  var parse_1$1 = parse$1; //following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
  //[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?

  var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
  /*
  	parses a nth-check formula, returns an array of two numbers
  */

  function parse$1(formula) {
    formula = formula.trim().toLowerCase();

    if (formula === "even") {
      return [2, 0];
    } else if (formula === "odd") {
      return [2, 1];
    } else {
      var parsed = formula.match(re_nthElement);

      if (!parsed) {
        throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
      }

      var a;

      if (parsed[1]) {
        a = parseInt(parsed[1], 10);

        if (isNaN(a)) {
          if (parsed[1].charAt(0) === "-") a = -1;else a = 1;
        }
      } else a = 0;

      return [a, parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0];
    }
  }

  var compile_1$2 = compile$2;
  var trueFunc$2 = boolbase.trueFunc,
      falseFunc$3 = boolbase.falseFunc;
  /*
  	returns a function that checks if an elements index matches the given rule
  	highly optimized to return the fastest solution
  */

  function compile$2(parsed) {
    var a = parsed[0],
        b = parsed[1] - 1; //when b <= 0, a*n won't be possible for any matches when a < 0
    //besides, the specification says that no element is matched when a and b are 0

    if (b < 0 && a <= 0) return falseFunc$3; //when a is in the range -1..1, it matches any element (so only b is checked)

    if (a === -1) return function (pos) {
      return pos <= b;
    };
    if (a === 0) return function (pos) {
      return pos === b;
    }; //when b <= 0 and a === 1, they match any element

    if (a === 1) return b < 0 ? trueFunc$2 : function (pos) {
      return pos >= b;
    }; //when a > 0, modulo can be used to check if there is a match

    var bMod = b % a;
    if (bMod < 0) bMod += a;

    if (a > 1) {
      return function (pos) {
        return pos >= b && pos % a === bMod;
      };
    }

    a *= -1; //make `a` positive

    return function (pos) {
      return pos <= b && pos % a === bMod;
    };
  }

  var nthCheck = function nthCheck(formula) {
    return compile_1$2(parse_1$1(formula));
  };

  var parse_1 = parse_1$1;
  var compile_1$1 = compile_1$2;
  nthCheck.parse = parse_1;
  nthCheck.compile = compile_1$1;

  /*
  	pseudo selectors

  	---

  	they are available in two forms:
  	* filters called when the selector
  	  is compiled and return a function
  	  that needs to return next()
  	* pseudos get called on execution
  	  they need to return a boolean
  */

  var trueFunc$1 = boolbase.trueFunc;
  var falseFunc$2 = boolbase.falseFunc;
  var checkAttrib = attributes.rules.equals;

  function getAttribFunc(name, value) {
    var data = {
      name: name,
      value: value
    };
    return function attribFunc(next, rule, options) {
      return checkAttrib(next, data, options);
    };
  }

  function getChildFunc(next, adapter) {
    return function (elem) {
      return !!adapter.getParent(elem) && next(elem);
    };
  }

  var filters$1 = {
    contains: function (next, text, options) {
      var adapter = options.adapter;
      return function contains(elem) {
        return next(elem) && adapter.getText(elem).indexOf(text) >= 0;
      };
    },
    icontains: function (next, text, options) {
      var itext = text.toLowerCase();
      var adapter = options.adapter;
      return function icontains(elem) {
        return next(elem) && adapter.getText(elem).toLowerCase().indexOf(itext) >= 0;
      };
    },
    //location specific methods
    "nth-child": function (next, rule, options) {
      var func = nthCheck(rule);
      var adapter = options.adapter;
      if (func === falseFunc$2) return func;
      if (func === trueFunc$1) return getChildFunc(next, adapter);
      return function nthChild(elem) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0, pos = 0; i < siblings.length; i++) {
          if (adapter.isTag(siblings[i])) {
            if (siblings[i] === elem) break;else pos++;
          }
        }

        return func(pos) && next(elem);
      };
    },
    "nth-last-child": function (next, rule, options) {
      var func = nthCheck(rule);
      var adapter = options.adapter;
      if (func === falseFunc$2) return func;
      if (func === trueFunc$1) return getChildFunc(next, adapter);
      return function nthLastChild(elem) {
        var siblings = adapter.getSiblings(elem);

        for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
          if (adapter.isTag(siblings[i])) {
            if (siblings[i] === elem) break;else pos++;
          }
        }

        return func(pos) && next(elem);
      };
    },
    "nth-of-type": function (next, rule, options) {
      var func = nthCheck(rule);
      var adapter = options.adapter;
      if (func === falseFunc$2) return func;
      if (func === trueFunc$1) return getChildFunc(next, adapter);
      return function nthOfType(elem) {
        var siblings = adapter.getSiblings(elem);

        for (var pos = 0, i = 0; i < siblings.length; i++) {
          if (adapter.isTag(siblings[i])) {
            if (siblings[i] === elem) break;
            if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
          }
        }

        return func(pos) && next(elem);
      };
    },
    "nth-last-of-type": function (next, rule, options) {
      var func = nthCheck(rule);
      var adapter = options.adapter;
      if (func === falseFunc$2) return func;
      if (func === trueFunc$1) return getChildFunc(next, adapter);
      return function nthLastOfType(elem) {
        var siblings = adapter.getSiblings(elem);

        for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
          if (adapter.isTag(siblings[i])) {
            if (siblings[i] === elem) break;
            if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
          }
        }

        return func(pos) && next(elem);
      };
    },
    //TODO determine the actual root element
    root: function (next, rule, options) {
      var adapter = options.adapter;
      return function (elem) {
        return !adapter.getParent(elem) && next(elem);
      };
    },
    scope: function (next, rule, options, context) {
      var adapter = options.adapter;

      if (!context || context.length === 0) {
        //equivalent to :root
        return filters$1.root(next, rule, options);
      }

      function equals(a, b) {
        if (typeof adapter.equals === "function") return adapter.equals(a, b);
        return a === b;
      }

      if (context.length === 1) {
        //NOTE: can't be unpacked, as :has uses this for side-effects
        return function (elem) {
          return equals(context[0], elem) && next(elem);
        };
      }

      return function (elem) {
        return context.indexOf(elem) >= 0 && next(elem);
      };
    },
    //jQuery extensions (others follow as pseudos)
    checkbox: getAttribFunc("type", "checkbox"),
    file: getAttribFunc("type", "file"),
    password: getAttribFunc("type", "password"),
    radio: getAttribFunc("type", "radio"),
    reset: getAttribFunc("type", "reset"),
    image: getAttribFunc("type", "image"),
    submit: getAttribFunc("type", "submit"),
    //dynamic state pseudos. These depend on optional Adapter methods.
    hover: function (next, rule, options) {
      var adapter = options.adapter;

      if (typeof adapter.isHovered === 'function') {
        return function hover(elem) {
          return next(elem) && adapter.isHovered(elem);
        };
      }

      return falseFunc$2;
    },
    visited: function (next, rule, options) {
      var adapter = options.adapter;

      if (typeof adapter.isVisited === 'function') {
        return function visited(elem) {
          return next(elem) && adapter.isVisited(elem);
        };
      }

      return falseFunc$2;
    },
    active: function (next, rule, options) {
      var adapter = options.adapter;

      if (typeof adapter.isActive === 'function') {
        return function active(elem) {
          return next(elem) && adapter.isActive(elem);
        };
      }

      return falseFunc$2;
    }
  }; //helper methods

  function getFirstElement(elems, adapter) {
    for (var i = 0; elems && i < elems.length; i++) {
      if (adapter.isTag(elems[i])) return elems[i];
    }
  } //while filters are precompiled, pseudos get called when they are needed


  var pseudos = {
    empty: function (elem, adapter) {
      return !adapter.getChildren(elem).some(function (elem) {
        return adapter.isTag(elem) || elem.type === "text";
      });
    },
    "first-child": function (elem, adapter) {
      return getFirstElement(adapter.getSiblings(elem), adapter) === elem;
    },
    "last-child": function (elem, adapter) {
      var siblings = adapter.getSiblings(elem);

      for (var i = siblings.length - 1; i >= 0; i--) {
        if (siblings[i] === elem) return true;
        if (adapter.isTag(siblings[i])) break;
      }

      return false;
    },
    "first-of-type": function (elem, adapter) {
      var siblings = adapter.getSiblings(elem);

      for (var i = 0; i < siblings.length; i++) {
        if (adapter.isTag(siblings[i])) {
          if (siblings[i] === elem) return true;
          if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
        }
      }

      return false;
    },
    "last-of-type": function (elem, adapter) {
      var siblings = adapter.getSiblings(elem);

      for (var i = siblings.length - 1; i >= 0; i--) {
        if (adapter.isTag(siblings[i])) {
          if (siblings[i] === elem) return true;
          if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
        }
      }

      return false;
    },
    "only-of-type": function (elem, adapter) {
      var siblings = adapter.getSiblings(elem);

      for (var i = 0, j = siblings.length; i < j; i++) {
        if (adapter.isTag(siblings[i])) {
          if (siblings[i] === elem) continue;

          if (adapter.getName(siblings[i]) === adapter.getName(elem)) {
            return false;
          }
        }
      }

      return true;
    },
    "only-child": function (elem, adapter) {
      var siblings = adapter.getSiblings(elem);

      for (var i = 0; i < siblings.length; i++) {
        if (adapter.isTag(siblings[i]) && siblings[i] !== elem) return false;
      }

      return true;
    },
    //:matches(a, area, link)[href]
    link: function (elem, adapter) {
      return adapter.hasAttrib(elem, "href");
    },
    //TODO: :any-link once the name is finalized (as an alias of :link)
    //forms
    //to consider: :target
    //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
    selected: function (elem, adapter) {
      if (adapter.hasAttrib(elem, "selected")) return true;else if (adapter.getName(elem) !== "option") return false; //the first <option> in a <select> is also selected

      var parent = adapter.getParent(elem);

      if (!parent || adapter.getName(parent) !== "select" || adapter.hasAttrib(parent, "multiple")) {
        return false;
      }

      var siblings = adapter.getChildren(parent);
      var sawElem = false;

      for (var i = 0; i < siblings.length; i++) {
        if (adapter.isTag(siblings[i])) {
          if (siblings[i] === elem) {
            sawElem = true;
          } else if (!sawElem) {
            return false;
          } else if (adapter.hasAttrib(siblings[i], "selected")) {
            return false;
          }
        }
      }

      return sawElem;
    },
    //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    //:matches(
    //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
    //  optgroup[disabled] > option),
    // fieldset[disabled] * //TODO not child of first <legend>
    //)
    disabled: function (elem, adapter) {
      return adapter.hasAttrib(elem, "disabled");
    },
    enabled: function (elem, adapter) {
      return !adapter.hasAttrib(elem, "disabled");
    },
    //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
    checked: function (elem, adapter) {
      return adapter.hasAttrib(elem, "checked") || pseudos.selected(elem, adapter);
    },
    //:matches(input, select, textarea)[required]
    required: function (elem, adapter) {
      return adapter.hasAttrib(elem, "required");
    },
    //:matches(input, select, textarea):not([required])
    optional: function (elem, adapter) {
      return !adapter.hasAttrib(elem, "required");
    },
    //jQuery extensions
    //:not(:empty)
    parent: function (elem, adapter) {
      return !pseudos.empty(elem, adapter);
    },
    //:matches(h1, h2, h3, h4, h5, h6)
    header: namePseudo(["h1", "h2", "h3", "h4", "h5", "h6"]),
    //:matches(button, input[type=button])
    button: function (elem, adapter) {
      var name = adapter.getName(elem);
      return name === "button" || name === "input" && adapter.getAttributeValue(elem, "type") === "button";
    },
    //:matches(input, textarea, select, button)
    input: namePseudo(["input", "textarea", "select", "button"]),
    //input:matches(:not([type!='']), [type='text' i])
    text: function (elem, adapter) {
      var attr;
      return adapter.getName(elem) === "input" && (!(attr = adapter.getAttributeValue(elem, "type")) || attr.toLowerCase() === "text");
    }
  };

  function namePseudo(names) {
    if (typeof Set !== "undefined") {
      // eslint-disable-next-line no-undef
      var nameSet = new Set(names);
      return function (elem, adapter) {
        return nameSet.has(adapter.getName(elem));
      };
    }

    return function (elem, adapter) {
      return names.indexOf(adapter.getName(elem)) >= 0;
    };
  }

  function verifyArgs(func, name, subselect) {
    if (subselect === null) {
      if (func.length > 2 && name !== "scope") {
        throw new Error("pseudo-selector :" + name + " requires an argument");
      }
    } else {
      if (func.length === 2) {
        throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
      }
    }
  } //FIXME this feels hacky


  var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
  var pseudos_1 = {
    compile: function (next, data, options, context) {
      var name = data.name;
      var subselect = data.data;
      var adapter = options.adapter;

      if (options && options.strict && !re_CSS3.test(name)) {
        throw new Error(":" + name + " isn't part of CSS3");
      }

      if (typeof filters$1[name] === "function") {
        return filters$1[name](next, subselect, options, context);
      } else if (typeof pseudos[name] === "function") {
        var func = pseudos[name];
        verifyArgs(func, name, subselect);

        if (func === falseFunc$2) {
          return func;
        }

        if (next === trueFunc$1) {
          return function pseudoRoot(elem) {
            return func(elem, adapter, subselect);
          };
        }

        return function pseudoArgs(elem) {
          return func(elem, adapter, subselect) && next(elem);
        };
      } else {
        throw new Error("unmatched pseudo-class :" + name);
      }
    },
    filters: filters$1,
    pseudos: pseudos
  };
  pseudos_1.compile;
  pseudos_1.filters;
  pseudos_1.pseudos;

  /*
  	all available rules
  */

  var general = {
    __proto__: null,
    attribute: attributes.compile,
    pseudo: pseudos_1.compile,
    //tags
    tag: function (next, data, options) {
      var name = data.name;
      var adapter = options.adapter;
      return function tag(elem) {
        return adapter.getName(elem) === name && next(elem);
      };
    },
    //traversal
    descendant: function (next, data, options) {
      // eslint-disable-next-line no-undef
      var isFalseCache = typeof WeakSet !== "undefined" ? new WeakSet() : null;
      var adapter = options.adapter;
      return function descendant(elem) {
        var found = false;

        while (!found && (elem = adapter.getParent(elem))) {
          if (!isFalseCache || !isFalseCache.has(elem)) {
            found = next(elem);

            if (!found && isFalseCache) {
              isFalseCache.add(elem);
            }
          }
        }

        return found;
      };
    },
    _flexibleDescendant: function (next, data, options) {
      var adapter = options.adapter; // Include element itself, only used while querying an array

      return function descendant(elem) {
        var found = next(elem);

        while (!found && (elem = adapter.getParent(elem))) {
          found = next(elem);
        }

        return found;
      };
    },
    parent: function (next, data, options) {
      if (options && options.strict) {
        throw new Error("Parent selector isn't part of CSS3");
      }

      var adapter = options.adapter;
      return function parent(elem) {
        return adapter.getChildren(elem).some(test);
      };

      function test(elem) {
        return adapter.isTag(elem) && next(elem);
      }
    },
    child: function (next, data, options) {
      var adapter = options.adapter;
      return function child(elem) {
        var parent = adapter.getParent(elem);
        return !!parent && next(parent);
      };
    },
    sibling: function (next, data, options) {
      var adapter = options.adapter;
      return function sibling(elem) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0; i < siblings.length; i++) {
          if (adapter.isTag(siblings[i])) {
            if (siblings[i] === elem) break;
            if (next(siblings[i])) return true;
          }
        }

        return false;
      };
    },
    adjacent: function (next, data, options) {
      var adapter = options.adapter;
      return function adjacent(elem) {
        var siblings = adapter.getSiblings(elem),
            lastElement;

        for (var i = 0; i < siblings.length; i++) {
          if (adapter.isTag(siblings[i])) {
            if (siblings[i] === elem) break;
            lastElement = siblings[i];
          }
        }

        return !!lastElement && next(lastElement);
      };
    },
    universal: function (next) {
      return next;
    }
  };
  general.attribute;
  general.pseudo;
  general.tag;
  general.descendant;
  general._flexibleDescendant;
  general.parent;
  general.child;
  general.sibling;
  general.adjacent;
  general.universal;

  /*
  	compiles a selector to an executable function
  */

  var compile_1 = compile$1;
  var parse = lib$1.parse;
  var trueFunc = boolbase.trueFunc;
  var falseFunc$1 = boolbase.falseFunc;
  var filters = pseudos_1.filters;

  function compile$1(selector, options, context) {
    var next = compileUnsafe$1(selector, options, context);
    return wrap(next, options);
  }

  function wrap(next, options) {
    var adapter = options.adapter;
    return function base(elem) {
      return adapter.isTag(elem) && next(elem);
    };
  }

  function compileUnsafe$1(selector, options, context) {
    var token = parse(selector, options);
    return compileToken(token, options, context);
  }

  function includesScopePseudo(t) {
    return t.type === "pseudo" && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function (data) {
      return data.some(includesScopePseudo);
    }));
  }

  var DESCENDANT_TOKEN = {
    type: "descendant"
  };
  var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant"
  };
  var SCOPE_TOKEN = {
    type: "pseudo",
    name: "scope"
  };
  var PLACEHOLDER_ELEMENT = {}; //CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
  //http://www.w3.org/TR/selectors4/#absolutizing

  function absolutize(token, options, context) {
    var adapter = options.adapter; //TODO better check if context is document

    var hasContext = !!context && !!context.length && context.every(function (e) {
      return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);
    });
    token.forEach(function (t) {
      if (t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant") ; else if (hasContext && !(Array.isArray(t) ? t.some(includesScopePseudo) : includesScopePseudo(t))) {
        t.unshift(DESCENDANT_TOKEN);
      } else {
        return;
      }

      t.unshift(SCOPE_TOKEN);
    });
  }

  function compileToken(token, options, context) {
    token = token.filter(function (t) {
      return t.length > 0;
    });
    token.forEach(sort);
    var isArrayContext = Array.isArray(context);
    context = options && options.context || context;
    if (context && !isArrayContext) context = [context];
    absolutize(token, options, context);
    var shouldTestNextSiblings = false;
    var query = token.map(function (rules) {
      if (rules[0] && rules[1] && rules[0].name === "scope") {
        var ruleType = rules[1].type;

        if (isArrayContext && ruleType === "descendant") {
          rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
        } else if (ruleType === "adjacent" || ruleType === "sibling") {
          shouldTestNextSiblings = true;
        }
      }

      return compileRules(rules, options, context);
    }).reduce(reduceRules, falseFunc$1);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
  }

  function isTraversal(t) {
    return procedure[t.type] < 0;
  }

  function compileRules(rules, options, context) {
    return rules.reduce(function (func, rule) {
      if (func === falseFunc$1) return func;

      if (!(rule.type in general)) {
        throw new Error("Rule type " + rule.type + " is not supported by css-select");
      }

      return general[rule.type](func, rule, options, context);
    }, options && options.rootFunc || trueFunc);
  }

  function reduceRules(a, b) {
    if (b === falseFunc$1 || a === trueFunc) {
      return a;
    }

    if (a === falseFunc$1 || b === trueFunc) {
      return b;
    }

    return function combine(elem) {
      return a(elem) || b(elem);
    };
  }

  function containsTraversal(t) {
    return t.some(isTraversal);
  } //:not, :has and :matches have to compile selectors
  //doing this in lib/pseudos.js would lead to circular dependencies,
  //so we add them here


  filters.not = function (next, token, options, context) {
    var opts = {
      xmlMode: !!(options && options.xmlMode),
      strict: !!(options && options.strict),
      adapter: options.adapter
    };

    if (opts.strict) {
      if (token.length > 1 || token.some(containsTraversal)) {
        throw new Error("complex selectors in :not aren't allowed in strict mode");
      }
    }

    var func = compileToken(token, opts, context);
    if (func === falseFunc$1) return next;
    if (func === trueFunc) return falseFunc$1;
    return function not(elem) {
      return !func(elem) && next(elem);
    };
  };

  filters.has = function (next, token, options) {
    var adapter = options.adapter;
    var opts = {
      xmlMode: !!(options && options.xmlMode),
      strict: !!(options && options.strict),
      adapter: adapter
    }; //FIXME: Uses an array as a pointer to the current element (side effects)

    var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;
    var func = compileToken(token, opts, context);
    if (func === falseFunc$1) return falseFunc$1;

    if (func === trueFunc) {
      return function hasChild(elem) {
        return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
      };
    }

    func = wrap(func, options);

    if (context) {
      return function has(elem) {
        return next(elem) && (context[0] = elem, adapter.existsOne(func, adapter.getChildren(elem)));
      };
    }

    return function has(elem) {
      return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));
    };
  };

  filters.matches = function (next, token, options, context) {
    var opts = {
      xmlMode: !!(options && options.xmlMode),
      strict: !!(options && options.strict),
      rootFunc: next,
      adapter: options.adapter
    };
    return compileToken(token, opts, context);
  };

  compile$1.compileToken = compileToken;
  compile$1.compileUnsafe = compileUnsafe$1;
  compile$1.Pseudos = pseudos_1;

  var cssSelect = CSSselect;
  var falseFunc = boolbase.falseFunc;

  function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
      options = options || {};
      options.adapter = options.adapter || domutils;
      return func(selector, options, context);
    };
  }

  var compile = wrapCompile(compile_1);
  var compileUnsafe = wrapCompile(compile_1.compileUnsafe);

  function getSelectorFunc(searchFunc) {
    return function select(query, elems, options) {
      options = options || {};
      options.adapter = options.adapter || domutils;

      if (typeof query !== "function") {
        query = compileUnsafe(query, options, elems);
      }

      if (query.shouldTestNextSiblings) {
        elems = appendNextSiblings(options && options.context || elems, options.adapter);
      }

      if (!Array.isArray(elems)) elems = options.adapter.getChildren(elems);else elems = options.adapter.removeSubsets(elems);
      return searchFunc(query, elems, options);
    };
  }

  function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (!Array.isArray(siblings)) return [];
    siblings = siblings.slice(0);

    while (siblings.shift() !== elem);

    return siblings;
  }

  function appendNextSiblings(elems, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    if (!Array.isArray(elems)) elems = [elems];
    var newElems = elems.slice(0);

    for (var i = 0, len = elems.length; i < len; i++) {
      var nextSiblings = getNextSiblings(newElems[i], adapter);
      newElems.push.apply(newElems, nextSiblings);
    }

    return newElems;
  }

  var selectAll = getSelectorFunc(function selectAll(query, elems, options) {
    return query === falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
  });
  var selectOne = getSelectorFunc(function selectOne(query, elems, options) {
    return query === falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
  });

  function is(elem, query, options) {
    options = options || {};
    options.adapter = options.adapter || domutils;
    return (typeof query === "function" ? query : compile(query, options))(elem);
  }
  /*
  	the exported interface
  */


  function CSSselect(query, elems, options) {
    return selectAll(query, elems, options);
  }

  CSSselect.compile = compile;
  CSSselect.filters = compile_1.Pseudos.filters;
  CSSselect.pseudos = compile_1.Pseudos.pseudos;
  CSSselect.selectAll = selectAll;
  CSSselect.selectOne = selectOne;
  CSSselect.is = is; //legacy methods (might be removed)

  CSSselect.parse = compile;
  CSSselect.iterate = selectAll; //hooks

  CSSselect._compileUnsafe = compileUnsafe;
  CSSselect._compileToken = compile_1.compileToken;

  var selector = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.querySelectorAll = querySelectorAll;
    exports.querySelector = querySelector;
    exports.isMatched = isMatched;
    exports.compile = compile;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function isTag(elem) {
      return elem.nodeType === 1 || _document.default.isSpriteNode(elem.nodeName);
    }

    function getChildren(elem) {
      return Array.from(elem.childNodes || []);
    }

    function getParent(elem) {
      if (_document.default.isSpriteNode(elem.nodeName)) {
        return elem.parent || elem.canvas || elem.container;
      }

      return elem.parentElement;
    }

    function removeSubsets(nodes) {
      var idx = nodes.length,
          node,
          ancestor,
          replace; // Check if each node (or one of its ancestors) is already contained in the
      // array.

      while (--idx > -1) {
        node = ancestor = nodes[idx]; // Temporarily remove the node under consideration

        nodes[idx] = null;
        replace = true;

        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }

          ancestor = getParent(ancestor);
        } // If the node has been found to be unique, re-insert it.


        if (replace) {
          nodes[idx] = node;
        }
      }

      return nodes;
    }

    var adapter = {
      isTag: isTag,
      existsOne: function existsOne(test, elems) {
        return elems.some(function (elem) {
          return isTag(elem) ? test(elem) || adapter.existsOne(test, getChildren(elem)) : false;
        });
      },
      getSiblings: function getSiblings(elem) {
        var parent = getParent(elem);
        return parent && getChildren(parent);
      },
      getChildren: getChildren,
      getParent: getParent,
      getAttributeValue: function getAttributeValue(elem, name) {
        if (elem.nodeType === 1 && name === 'class' || name === 'id') {
          return elem[name];
        }

        if (this.hasAttrib(elem, name)) {
          var val = elem.attributes[name];

          if (Array.isArray(val)) {
            val = "[".concat(val.join(), "]");
          }

          return String(val);
        }
      },
      hasAttrib: function hasAttrib(elem, name) {
        return elem.attributes[name] != null;
      },
      removeSubsets: removeSubsets,
      getName: function getName(elem) {
        return elem.tagName ? elem.tagName.toLowerCase() : null;
      },
      findOne: function findOne(test, arr) {
        var elem = null;

        for (var i = 0, l = arr.length; i < l && !elem; i++) {
          if (test(arr[i])) {
            elem = arr[i];
          } else {
            var childs = getChildren(arr[i]);

            if (childs && childs.length > 0) {
              elem = findOne(test, childs);
            }
          }
        }

        return elem;
      },
      findAll: function findAll(test, elems) {
        var result = [];

        for (var i = 0, j = elems.length; i < j; i++) {
          if (!isTag(elems[i])) continue; // eslint-disable-line

          if (test(elems[i])) result.push(elems[i]);
          var childs = getChildren(elems[i]);
          if (childs) result = result.concat(findAll(test, childs));
        }

        return result;
      },
      getText: function getText(elem) {
        if (Array.isArray(elem)) return elem.map(getText).join('');
        if (isTag(elem)) return getText(getChildren(elem));
        if (elem.nodeType === 3) return elem.nodeValue;
        if (_document.default.isSpriteNode(elem.nodeName)) return elem.text;
        return '';
      }
    };

    function resolveQuery(query) {
      if (typeof query !== 'string') return query;
      var matches = query.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);

      if (matches) {
        matches = matches.map(function (matched) {
          var kv = matched.slice(1, -1).split('=');
          var color$1 = (0, color.parseColor)(kv[1].replace(/['"]/g, ''));
          return [matched, "[".concat(kv[0], "=\"").concat(color$1, "\"]")];
        });
        matches.forEach(function (_ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
              r = _ref2[0],
              p = _ref2[1];

          query = query.replace(r, p);
        });
      }

      matches = query.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g);

      if (matches) {
        matches = matches.map(function (matched) {
          var kv = matched.slice(1, -1).split('=');
          var arr = kv[1].slice(2, -2).split(/,/g).map(function (k) {
            return k.trim();
          });
          return [matched, "[".concat(kv[0], "=\"[").concat(arr, "]\"]")];
        });
        matches.forEach(function (_ref3) {
          var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
              r = _ref4[0],
              p = _ref4[1];

          query = query.replace(r, p);
        });
      }

      return query;
    }

    function querySelectorAll(query, elems) {
      return cssSelect.selectAll(resolveQuery(query), elems, {
        adapter: adapter
      });
    }

    function querySelector(query, elems) {
      return cssSelect.selectOne(resolveQuery(query), elems, {
        adapter: adapter
      });
    }

    function isMatched(elem, query) {
      return cssSelect.is(elem, resolveQuery(query), {
        adapter: adapter
      });
    }

    function compile(query) {
      return cssSelect.compile(resolveQuery(query), {
        adapter: adapter
      });
    }
  });
  unwrapExports(selector);
  selector.querySelectorAll;
  selector.querySelector;
  selector.isMatched;
  selector.compile;

  var group = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _block = interopRequireDefault(block$1);

    var _group = interopRequireDefault(group$1);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _zOrder = Symbol('zOrder');

    var _ordered = Symbol('ordered');

    var _children = Symbol('children');

    var _sealed = Symbol('sealed');

    var Group = /*#__PURE__*/function (_Block) {
      (0, _inherits2.default)(Group, _Block);

      var _super = _createSuper(Group);

      function Group() {
        var _this;

        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Group);
        _this = _super.call(this, attrs);
        _this[_children] = [];
        _this[_ordered] = null;
        _this[_zOrder] = 0;
        return _this;
      }

      (0, _createClass2.default)(Group, [{
        key: "append",
        value: function append() {
          var _this2 = this;

          for (var _len = arguments.length, els = new Array(_len), _key = 0; _key < _len; _key++) {
            els[_key] = arguments[_key];
          }

          return els.map(function (el) {
            return _this2.appendChild(el);
          });
        }
      }, {
        key: "appendChild",
        value: function appendChild(el) {
          el.remove();

          this[_children].push(el);

          el.connect(this, this[_zOrder]++);

          if (this[_ordered]) {
            if (this[_ordered].length && el.zIndex < this[_ordered][this[_ordered].length - 1].zIndex) {
              this.reorder();
            } else {
              this[_ordered].push(el);
            }
          }

          return el;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }

        /* override */

      }, {
        key: "cloneNode",
        value: function cloneNode() {
          var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var node = (0, _get2.default)((0, _getPrototypeOf2.default)(Group.prototype), "cloneNode", this).call(this);

          if (deep) {
            this[_children].forEach(function (child) {
              var childNode = child.cloneNode(deep);
              node.appendChild(childNode);
            });
          }

          return node;
        }
        /* override */

      }, {
        key: "dispatchPointerEvent",
        value: function dispatchPointerEvent(event) {
          var children = this.orderedChildren;

          for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];
            if (child.dispatchPointerEvent(event)) return true;
          }

          return (0, _get2.default)((0, _getPrototypeOf2.default)(Group.prototype), "dispatchPointerEvent", this).call(this, event);
        }
        /* override */

      }, {
        key: "draw",
        value: function draw() {
          var meshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          this.__cacheRenderMatrix = this.renderMatrix;
          (0, _get2.default)((0, _getPrototypeOf2.default)(Group.prototype), "draw", this).call(this, meshes);

          if (!this[_sealed] && this.attributes.display !== 'none') {
            var children = this.orderedChildren;

            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              child.draw(meshes);
            }
          }

          this.__cacheRenderMatrix = null;
          return meshes;
        }
      }, {
        key: "getElementById",
        value: function getElementById(id) {
          return (0, selector.querySelector)("#".concat(id), this);
        }
      }, {
        key: "getElementsByClassName",
        value: function getElementsByClassName(className) {
          return (0, selector.querySelectorAll)(".".concat(className), this);
        }
      }, {
        key: "getElementsByName",
        value: function getElementsByName(name) {
          return (0, selector.querySelectorAll)("[name=\"".concat(name, "\"]"), this);
        }
      }, {
        key: "getElementsByTagName",
        value: function getElementsByTagName(tagName) {
          return (0, selector.querySelectorAll)(tagName, this);
        }
      }, {
        key: "insertBefore",
        value: function insertBefore(el, ref) {
          if (ref == null) return this.appendChild(el);
          el.remove();

          var refIdx = this[_children].indexOf(ref);

          if (refIdx < 0) {
            throw new Error('Invalid reference node.');
          }

          var zOrder = ref.zOrder;

          for (var i = refIdx; i < this[_children].length; i++) {
            var order = this[_children][i].zOrder;
            var child = this[_children][i];
            delete child.zOrder;
            Object.defineProperty(child, 'zOrder', {
              value: order + 1,
              writable: false,
              configurable: true
            });
          }

          this[_children].splice(refIdx, 0, el);

          el.connect(this, zOrder);

          if (this[_ordered]) {
            if (el.zIndex !== ref.zIndex) {
              this.reorder();
            } else {
              var idx = this[_ordered].indexOf(ref);

              this[_ordered].splice(idx, 0, el);
            }
          }

          return el;
        }
      }, {
        key: "querySelector",
        value: function querySelector(selector$1) {
          return (0, selector.querySelector)(selector$1, this);
        }
      }, {
        key: "querySelectorAll",
        value: function querySelectorAll(selector$1) {
          return (0, selector.querySelectorAll)(selector$1, this);
        }
      }, {
        key: "replaceChild",
        value: function replaceChild(el, ref) {
          el.remove();

          var refIdx = this[_children].indexOf(ref);

          if (refIdx < 0) {
            throw new Error('Invalid reference node.');
          }

          this[_children][refIdx] = el;
          el.connect(this, ref.zOrder);

          if (this[_ordered]) {
            if (el.zIndex !== ref.zIndex) {
              this.reorder();
            } else {
              var idx = this[_ordered].indexOf(ref);

              this[_ordered][idx] = el;
            }
          }

          ref.disconnect(this);
          return el;
        }
      }, {
        key: "removeAllChildren",
        value: function removeAllChildren() {
          var children = this[_children];

          for (var i = children.length - 1; i >= 0; i--) {
            children[i].remove();
          }
        }
      }, {
        key: "removeChild",
        value: function removeChild(el) {
          var idx = this[_children].indexOf(el);

          if (idx >= 0) {
            this[_children].splice(idx, 1);

            if (this[_ordered]) {
              var _idx = this[_ordered].indexOf(el);

              this[_ordered].splice(_idx, 1);
            }

            el.disconnect(this);
            return el;
          }

          return null;
        }
      }, {
        key: "reorder",
        value: function reorder() {
          this[_ordered] = null;
        }
      }, {
        key: "seal",
        value: function seal() {
          function transform(path, m) {
            var ret = [];

            for (var i = 0; i < path.length; i++) {
              var cmd = (0, _toConsumableArray2.default)(path[i]);

              for (var j = 1; j < cmd.length; j += 2) {
                var x = cmd[j];
                var y = cmd[j + 1];
                cmd[j] = x * m[0] + y * m[2] + m[4];
                cmd[j + 1] = x * m[1] + y * m[3] + m[5];
              }

              ret.push(cmd);
            }

            return ret;
          }

          var children = this.orderedChildren;
          var clientBox = new mesh.Figure2D();
          var localMatrix = this.localMatrix;

          for (var i = 0; i < children.length; i++) {
            var child = children[i];

            if (child instanceof Group) {
              child = child.seal();
            }

            if (child.clientBox) {
              var path = child.clientBox.contours.path;
              path = transform(path, child.localMatrix);
              clientBox.addPath(path);
            }

            if (child.path) {
              var _path = child.path.contours.path;
              _path = transform(_path, child.localMatrix);
              clientBox.addPath(_path);
            }
          }

          this[_sealed] = true;
          this.clientBox = clientBox;
          return {
            clientBox: clientBox,
            localMatrix: localMatrix
          };
        }
        /* override */

      }, {
        key: "setResolution",
        value: function setResolution(_ref) {
          var width = _ref.width,
              height = _ref.height;
          (0, _get2.default)((0, _getPrototypeOf2.default)(Group.prototype), "setResolution", this).call(this, {
            width: width,
            height: height
          });

          this[_children].forEach(function (child) {
            child.setResolution({
              width: width,
              height: height
            });
          });
        }
        /* override */

      }, {
        key: "updateContours",
        value: function updateContours() {
          if (!this[_sealed]) (0, _get2.default)((0, _getPrototypeOf2.default)(Group.prototype), "updateContours", this).call(this);
        }
      }, {
        key: "childNodes",
        get: function get() {
          return this[_children];
        }
      }, {
        key: "children",
        get: function get() {
          return this[_children];
        }
      }, {
        key: "orderedChildren",
        get: function get() {
          if (!this[_ordered]) {
            this[_ordered] = (0, _toConsumableArray2.default)(this[_children]);

            this[_ordered].sort(function (a, b) {
              return a.zIndex - b.zIndex || a.zOrder - b.zOrder;
            });
          }

          return this[_ordered];
        }
      }]);
      return Group;
    }(_block.default);

    exports.default = Group;
    (0, _defineProperty2.default)(Group, "Attr", _group.default);

    _document.default.registerNode(Group, 'group');
  });
  unwrapExports(group);

  var objectWithoutPropertiesLoose = createCommonjsModule(function (module) {
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(objectWithoutPropertiesLoose);

  var objectWithoutProperties = createCommonjsModule(function (module) {
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  unwrapExports(objectWithoutProperties);

  var layer = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _objectWithoutProperties2 = interopRequireDefault(objectWithoutProperties);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _group = interopRequireDefault(group);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var defaultOptions = {
      antialias: true,
      autoRender: true,
      alpha: true // for wx-miniprogram

    };

    var _autoRender = Symbol('autoRender');

    var _renderer = Symbol('renderer');

    var _timeline = Symbol('timeline');

    var _prepareRender = Symbol('prepareRender');

    var _tickRender = Symbol('tickRender');

    var _pass = Symbol('pass');

    var _fbo = Symbol('fbo');

    var _tickers = Symbol('tickers');

    var _layerTransformInvert = Symbol('layerTransformInvert');

    var Layer = /*#__PURE__*/function (_Group) {
      (0, _inherits2.default)(Layer, _Group);

      var _super = _createSuper(Layer);

      function Layer() {
        var _this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Layer);
        _this = _super.call(this);

        if (!options.canvas) {
          var _this$getResolution = _this.getResolution(),
              width = _this$getResolution.width,
              height = _this$getResolution.height;

          var _canvas = mesh.ENV.createCanvas(width, height, {
            offscreen: !!options.offscreen,
            id: options.id,
            extra: options.extra
          });

          if (_canvas.style) _canvas.style.position = 'absolute';
          if (_canvas.dataset) _canvas.dataset.layerId = options.id;
          if (_canvas.contextType) options.contextType = _canvas.contextType;
          options.canvas = _canvas;
        }

        var canvas = options.canvas;
        var opts = Object.assign({}, defaultOptions, options);
        _this[_autoRender] = opts.autoRender;
        delete options.autoRender;

        var _Renderer = opts.Renderer || mesh.Renderer;

        _this[_renderer] = new _Renderer(canvas, opts); // if(canvas.__gl__) {
        //   // fix blendFunc for node-canvas-webgl
        //   const gl = canvas.__gl__;
        //   gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        // }

        _this.options = options;
        _this.id = options.id;
        _this[_pass] = [];

        _this.setResolution(canvas);

        _this.canvas = canvas;
        _this[_timeline] = new lib$3.Timeline();
        _this.__mouseCapturedTarget = null;
        _this[_layerTransformInvert] = null;
        return _this;
      }

      (0, _createClass2.default)(Layer, [{
        key: "forceContextLoss",
        value: function forceContextLoss() {
          var gl = this.renderer.glRenderer;

          if (gl) {
            var ext = gl.getExtension('WEBGL_lose_context');

            if (ext) {
              ext.loseContext();
              return true;
            }
          }

          return false;
        } // isPointCollision(x, y) {
        //   return true;
        // }

      }, {
        key: "addPass",
        value: function addPass() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              vertex = _ref.vertex,
              fragment = _ref.fragment,
              options = _ref.options,
              uniforms = _ref.uniforms;

          if (this.renderer.glRenderer) {
            var _this$getResolution2 = this.getResolution(),
                width = _this$getResolution2.width,
                height = _this$getResolution2.height;

            var program = this.renderer.createPassProgram({
              vertex: vertex,
              fragment: fragment,
              options: options
            });
            var figure = new mesh.Figure2D();
            figure.rect(0, 0, width / this.displayRatio, height / this.displayRatio);
            var mesh$1 = new mesh.Mesh2D(figure);
            mesh$1.setUniforms(uniforms);
            mesh$1.setProgram(program);

            this[_pass].push(mesh$1);

            this.forceUpdate();
            return mesh$1;
          }

          return null;
        } // delete unused texture to release memory.

      }, {
        key: "deleteTexture",
        value: function deleteTexture(image) {
          return (0, texture.deleteTexture)(image, this.renderer);
        }
        /* override */

      }, {
        key: "dispatchPointerEvent",
        value: function dispatchPointerEvent(event) {
          var type = event.type;

          if (type === 'mousedown' || type === 'mouseup' || type === 'mousemove') {
            var capturedTarget = this.__mouseCapturedTarget;

            if (capturedTarget) {
              if (capturedTarget.layer === this) {
                capturedTarget.dispatchEvent(event);
                return true;
              }

              this.__mouseCapturedTarget = null;
            }
          }

          var x, y;
          var layerTransformInvert = this.layerTransformInvert;

          if (layerTransformInvert) {
            x = event.x;
            y = event.y;
            var m = layerTransformInvert;
            var layerX = m[0] * x + m[2] * y + m[4];
            var layerY = m[1] * x + m[3] * y + m[5];
            delete event.x;
            delete event.y;
            delete event.layerX;
            delete event.layerY;
            Object.defineProperties(event, {
              layerX: {
                value: layerX,
                configurable: true
              },
              layerY: {
                value: layerY,
                configurable: true
              },
              x: {
                value: layerX,
                configurable: true
              },
              y: {
                value: layerY,
                configurable: true
              }
            });
          }

          var ret = (0, _get2.default)((0, _getPrototypeOf2.default)(Layer.prototype), "dispatchPointerEvent", this).call(this, event);

          if (layerTransformInvert) {
            Object.defineProperties(event, {
              layerX: {
                value: x,
                configurable: true
              },
              layerY: {
                value: y,
                configurable: true
              },
              x: {
                value: x,
                configurable: true
              },
              y: {
                value: y,
                configurable: true
              }
            });
          }

          return ret;
        }
        /* override */

      }, {
        key: "forceUpdate",
        value: function forceUpdate() {
          var _this2 = this;

          if (!this[_prepareRender]) {
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              var _resolve = null;
              var prepareRender = new Promise(function (resolve) {
                _resolve = resolve;
              });
              prepareRender._resolve = _resolve;
              this[_prepareRender] = prepareRender;
            } else {
              var _resolve2 = null;
              var _requestID = null;

              var _prepareRender2 = new Promise(function (resolve) {
                _resolve2 = resolve;

                if (_this2[_autoRender]) {
                  _requestID = (0, animationFrame.requestAnimationFrame)(function () {
                    delete _prepareRender2._requestID;

                    _this2.render();
                  });
                }
              });

              _prepareRender2._resolve = _resolve2;
              _prepareRender2._requestID = _requestID;
              this[_prepareRender] = _prepareRender2;
            }
          }
        }
      }, {
        key: "getFBO",
        value: function getFBO() {
          var renderer = this.renderer.glRenderer;

          var _this$getResolution3 = this.getResolution(),
              width = _this$getResolution3.width,
              height = _this$getResolution3.height;

          if (renderer && (!this[_fbo] || this[_fbo].width !== width || this[_fbo].height !== height)) {
            this[_fbo] = {
              width: width,
              height: height,
              target: renderer.createFBO(),
              buffer: renderer.createFBO(),
              swap: function swap() {
                var _ref2 = [this.buffer, this.target];
                this.target = _ref2[0];
                this.buffer = _ref2[1];
              }
            };
            return this[_fbo];
          }

          return this[_fbo] ? this[_fbo] : null;
        }
      }, {
        key: "updateGlobalTransform",
        value: function updateGlobalTransform() {
          if (this.layerTransformInvert) {
            var renderer = this.renderer;
            var globalMatrix = renderer.__globalTransformMatrix || renderer.globalTransformMatrix;
            renderer.__globalTransformMatrix = globalMatrix;

            var mOut = esm$1.mat2d.fromValues(1, 0, 0, 1, 0, 0);

            renderer.setGlobalTransform.apply(renderer, (0, _toConsumableArray2.default)(esm$1.mat2d.multiply(mOut, globalMatrix, this.transformMatrix)));
          }
        }
        /* override */

      }, {
        key: "onPropertyChange",
        value: function onPropertyChange(key, newValue, oldValue) {
          (0, _get2.default)((0, _getPrototypeOf2.default)(Layer.prototype), "onPropertyChange", this).call(this, key, newValue, oldValue);

          if (key === 'zIndex') {
            this.canvas.style.zIndex = newValue;
          }

          if (key === 'transform' || key === 'translate' || key === 'rotate' || key === 'scale' || key === 'skew') {
            var m = this[_layerTransformInvert];
            this[_layerTransformInvert] = null;
            this.updateGlobalTransform();

            if (m && !this.layerTransformInvert) {
              // unit matrix, recover globalMatrix
              var renderer = this.renderer;
              var globalMatrix = renderer.__globalTransformMatrix || renderer.globalTransformMatrix;
              renderer.setGlobalTransform.apply(renderer, (0, _toConsumableArray2.default)(globalMatrix));
            }
          }
        }
      }, {
        key: "_prepareRenderFinished",
        value: function _prepareRenderFinished() {
          if (this[_prepareRender]) {
            if (this[_prepareRender]._requestID) {
              (0, animationFrame.cancelAnimationFrame)(this[_prepareRender]._requestID);
            }

            this[_prepareRender]._resolve();

            delete this[_prepareRender];
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this3 = this;

          var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref3$clear = _ref3.clear,
              clear = _ref3$clear === void 0 ? true : _ref3$clear;

          var fbo = this[_pass].length ? this.getFBO() : null;

          if (fbo) {
            this.renderer.glRenderer.bindFBO(fbo.target);
          }

          if (clear) this[_renderer].clear();
          var meshes = this.draw();

          if (meshes && meshes.length) {
            this.renderer.drawMeshes(meshes);
            if (this.canvas.draw) this.canvas.draw();
          }

          if (fbo) {
            var renderer = this.renderer.glRenderer;
            var len = this[_pass].length;

            var _this$getResolution4 = this.getResolution(),
                width = _this$getResolution4.width,
                height = _this$getResolution4.height;

            var rect = [0, 0, width / this.displayRatio, height / this.displayRatio];

            this[_pass].forEach(function (pass, idx) {
              pass.blend = true;
              pass.setTexture(fbo.target.texture, {
                rect: rect
              });
              if (idx === len - 1) renderer.bindFBO(null);else {
                fbo.swap();
                renderer.bindFBO(fbo.target);
              }

              _this3[_renderer].clear();

              _this3.renderer.drawMeshes([pass]);
            });
          }

          this._prepareRenderFinished();
        }
        /* override */

      }, {
        key: "setResolution",
        value: function setResolution(_ref4) {
          var _this4 = this;

          var width = _ref4.width,
              height = _ref4.height;
          var renderer = this.renderer;
          var m = renderer.__globalTransformMatrix || renderer.globalTransformMatrix;
          var offsetLeft = m[4];
          var offsetTop = m[5];
          var previousDisplayRatio = m[0];

          var _this$getResolution5 = this.getResolution(),
              w = _this$getResolution5.width,
              h = _this$getResolution5.height;

          if (w !== width || h !== height) {
            (0, _get2.default)((0, _getPrototypeOf2.default)(Layer.prototype), "setResolution", this).call(this, {
              width: width,
              height: height
            });

            if (this.canvas) {
              this.canvas.width = width;
              this.canvas.height = height;
              if (renderer.updateResolution) renderer.updateResolution();
            }

            this.attributes.size = [width, height];

            if (this[_pass].length) {
              this[_pass].forEach(function (pass) {
                var figure = new mesh.Figure2D();
                figure.rect(0, 0, width / _this4.displayRatio, height / _this4.displayRatio);
                pass.contours = figure.contours;
              });
            } // this.dispatchEvent({type: 'resolutionchange', width, height});

          }

          var _this$renderOffset = (0, _slicedToArray2.default)(this.renderOffset, 2),
              left = _this$renderOffset[0],
              top = _this$renderOffset[1];

          var displayRatio = this.displayRatio;

          if (offsetLeft !== left || offsetTop !== top || previousDisplayRatio !== displayRatio) {
            // console.log(displayRatio, this.parent);
            renderer.setGlobalTransform(displayRatio, 0, 0, displayRatio, left, top);
            renderer.__globalTransformMatrix = null;
            this[_layerTransformInvert] = null;
            this.updateGlobalTransform();
            this.forceUpdate();
          }
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */

      }, {
        key: "tick",
        value: function tick() {
          var _this5 = this;

          var handler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref5$duration = _ref5.duration,
              duration = _ref5$duration === void 0 ? Infinity : _ref5$duration,
              timelineOptions = (0, _objectWithoutProperties2.default)(_ref5, ["duration"]); // this._prepareRenderFinished();


          var t = this.timeline.fork(timelineOptions);
          var layer = this;
          this[_tickers] = this[_tickers] || [];

          this[_tickers].push({
            handler: handler,
            duration: duration
          });

          var update = function update() {
            var _resolve = null;
            var _requestID = null;

            var _update = function _update() {
              // const ret = handler ? handler(t.currentTime, p) : null;
              var ret = _this5[_tickers].map(function (_ref6) {
                var handler = _ref6.handler,
                    duration = _ref6.duration;
                var p = Math.min(1.0, t.currentTime / duration);
                var value = handler ? handler(t.currentTime, p) : null;
                return {
                  value: value,
                  p: p
                };
              });

              if (layer[_autoRender] && !layer[_tickRender]) {
                layer[_tickRender] = Promise.resolve().then(function () {
                  layer.render();
                  delete layer[_tickRender];

                  for (var i = ret.length - 1; i >= 0; i--) {
                    var _ret$i = ret[i],
                        value = _ret$i.value,
                        p = _ret$i.p;

                    if (value === false || p >= 1.0) {
                      _this5[_tickers].splice(i, 1);
                    }
                  }

                  if (_this5[_tickers].length > 0) {
                    update();
                  }
                });
              }
            };

            if (_this5[_prepareRender] && _this5[_prepareRender]._type !== 'ticker') {
              (0, animationFrame.cancelAnimationFrame)(_this5[_prepareRender]._requestID);
              delete _this5[_prepareRender];
            }

            if (!_this5[_prepareRender]) {
              var prepareRender = new Promise(function (resolve) {
                _resolve = resolve;
                _requestID = (0, animationFrame.requestAnimationFrame)(_update);
              });
              prepareRender._resolve = _resolve;
              prepareRender._requestID = _requestID;
              prepareRender._type = 'ticker';
              _this5[_prepareRender] = prepareRender;
            }
          };

          update();
        }
      }, {
        key: "toGlobalPos",
        value: function toGlobalPos(x, y) {
          if (this.layerTransformInvert) {
            var m = this.transformMatrix;
            x = m[0] * x + m[2] * y + m[4];
            y = m[1] * x + m[3] * y + m[5];
          }

          var _this$getResolution6 = this.getResolution(),
              width = _this$getResolution6.width,
              height = _this$getResolution6.height;

          var offset = this.renderOffset;
          var viewport = [this.canvas.clientWidth, this.canvas.clientHeight];
          x = x * viewport[0] / width + offset[0];
          y = y * viewport[1] / height + offset[1];
          var displayRatio = this.displayRatio;
          x *= displayRatio;
          y *= displayRatio;
          return [x, y];
        }
      }, {
        key: "toLocalPos",
        value: function toLocalPos(x, y) {
          var _this$getResolution7 = this.getResolution(),
              width = _this$getResolution7.width,
              height = _this$getResolution7.height;

          var offset = this.renderOffset;
          var viewport = [this.canvas.clientWidth, this.canvas.clientHeight];
          x = x * width / viewport[0] - offset[0];
          y = y * height / viewport[1] - offset[1];
          var displayRatio = this.displayRatio;
          x /= displayRatio;
          y /= displayRatio;
          var m = this.layerTransformInvert;

          if (m) {
            x = m[0] * x + m[2] * y + m[4];
            y = m[1] * x + m[3] * y + m[5];
          }

          return [x, y];
        }
      }, {
        key: "autoRender",
        get: function get() {
          return this[_autoRender];
        }
      }, {
        key: "displayRatio",
        get: function get() {
          if (this.parent && this.parent.options) {
            return this.parent.options.displayRatio;
          }

          return 1.0;
        }
      }, {
        key: "height",
        get: function get() {
          var _this$getResolution8 = this.getResolution(),
              height = _this$getResolution8.height;

          return height / this.displayRatio;
        }
      }, {
        key: "gl",
        get: function get() {
          if (this.renderer.glRenderer) {
            return this.renderer.glRenderer.gl;
          }

          return null;
        }
        /* override */

      }, {
        key: "layer",
        get: function get() {
          return this;
        }
      }, {
        key: "offscreen",
        get: function get() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
      }, {
        key: "pass",
        get: function get() {
          return this[_pass];
        }
      }, {
        key: "prepareRender",
        get: function get() {
          return this[_prepareRender] ? this[_prepareRender] : Promise.resolve();
        }
        /* override */

      }, {
        key: "renderer",
        get: function get() {
          return this[_renderer];
        }
      }, {
        key: "renderOffset",
        get: function get() {
          if (this.parent && this.parent.options) {
            var _this$parent$options = this.parent.options,
                left = _this$parent$options.left,
                top = _this$parent$options.top;
            return [left, top];
          }

          return [this.options.left | 0, this.options.top | 0];
        }
      }, {
        key: "timeline",
        get: function get() {
          return this[_timeline];
        }
      }, {
        key: "width",
        get: function get() {
          var _this$getResolution9 = this.getResolution(),
              width = _this$getResolution9.width;

          return width / this.displayRatio;
        }
      }, {
        key: "localMatrix",
        get: function get() {
          var _this$attributes = this.attributes,
              x = _this$attributes.x,
              y = _this$attributes.y;
          return [1, 0, 0, 1, x, y];
        }
      }, {
        key: "layerTransformInvert",
        get: function get() {
          if (this[_layerTransformInvert]) return this[_layerTransformInvert];
          var m = this.transformMatrix;

          if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {
            return null;
          }

          this[_layerTransformInvert] = esm$1.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), m);
          return this[_layerTransformInvert];
        }
      }]);
      return Layer;
    }(_group.default);

    exports.default = Layer;

    _document.default.registerNode(Layer, 'layer');
  });
  unwrapExports(layer);

  var spritesvg$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _sprite = interopRequireDefault(sprite$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var getAttribute = Symbol.for('spritejs_getAttribute');
    var setAttribute = Symbol.for('spritejs_setAttribute');
    var setDefault = Symbol.for('spritejs_setAttributeDefault');

    var SpriteSvg = /*#__PURE__*/function (_Sprite) {
      (0, _inherits2.default)(SpriteSvg, _Sprite);

      var _super = _createSuper(SpriteSvg);

      function SpriteSvg(subject) {
        var _this;

        (0, _classCallCheck2.default)(this, SpriteSvg);
        _this = _super.call(this, subject);

        _this[setDefault]({
          passEvents: false,
          flexible: false
        });

        return _this;
      } // readonly


      (0, _createClass2.default)(SpriteSvg, [{
        key: "texture",
        get: function get() {
          return this[getAttribute]('texture');
        },
        set: function set(value) {} // eslint-disable-line no-empty-function

      }, {
        key: "passEvents",
        get: function get() {
          return this[getAttribute]('passEvents');
        },
        set: function set(value) {
          return this[setAttribute]('passEvents', value);
        }
      }, {
        key: "flexible",
        get: function get() {
          return this[getAttribute]('flexible');
        },
        set: function set(value) {
          return this[setAttribute]('flexible', value);
        }
      }]);
      return SpriteSvg;
    }(_sprite.default);

    exports.default = SpriteSvg;
  });
  unwrapExports(spritesvg$1);

  var spritesvg = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _objectWithoutProperties2 = interopRequireDefault(objectWithoutProperties);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _sprite = interopRequireDefault(sprite);

    var _spritesvg = interopRequireDefault(spritesvg$1);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    } // This class only avaliable for browser


    var namespace = 'http://www.w3.org/2000/svg';
    var setAttribute = Symbol.for('spritejs_setAttribute');

    var _root = Symbol('root');

    var _updateTextureTask = Symbol('task');

    function updateTexture(svgNode) {
      var flexible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var root = svgNode[_root];

      if (root && root.children[0]) {
        var svg = svgNode.svg;
        var displayRatio = svgNode.layer ? svgNode.layer.displayRatio : 1;

        if (!svg.hasAttribute('data-original-width')) {
          var w = svg.getAttribute('width');
          w = w ? (0, attribute_value.sizeToPixel)(w) : 300;
          var h = svg.getAttribute('height');
          h = h ? (0, attribute_value.sizeToPixel)(h) : 150;

          if (!svg.hasAttribute('viewBox')) {
            svg.setAttribute('viewBox', "0 0 ".concat(Math.round(w), " ").concat(Math.round(h)));
          }

          svg.setAttribute('data-original-width', w);
          svg.setAttribute('data-original-height', h);
        }

        var width = svgNode.attributes.width || Number(svg.getAttribute('data-original-width'));
        var height = svgNode.attributes.height || Number(svg.getAttribute('data-original-height'));
        width *= displayRatio;
        height *= displayRatio;

        if (flexible && svgNode.attributes.flexible) {
          var scale = svgNode.attributes.scale[0];
          width *= scale;
          height *= scale;
          svg.setAttribute('width', width);
          svg.setAttribute('height', height);

          if (width && height && svgNode.textureImage) {
            var imgWidth = svgNode.textureImage.width;
            var imgHeight = svgNode.textureImage.height;
            var boxSize = svgNode.clientSize;
            svgNode.attributes.textureRect = [0, 0, Math.round(boxSize[0] * imgWidth / width), Math.round(boxSize[1] * imgHeight / height)];
          }
        } else if (!svgNode[_updateTextureTask]) {
          svg.setAttribute('width', width);
          svg.setAttribute('height', height);
          svgNode[_updateTextureTask] = Promise.resolve().then(function () {
            delete svgNode[_updateTextureTask];
            var svgText = root.innerHTML;
            var blob = new Blob([svgText], {
              type: 'image/svg+xml'
            });
            var textureURL = URL.createObjectURL(blob);
            var img = new Image();

            img.onload = function () {
              if (img.width && img.height) {
                svgNode.attributes[setAttribute]('texture', img);

                if (svgNode.attributes.flexible) {
                  svgNode.attributes.textureRect = null;
                }
              } else {
                svgNode.attributes[setAttribute]('texture', null);
              }
            };

            img.src = textureURL;
          });
        }
      }
    }

    var SpriteSvg = /*#__PURE__*/function (_Sprite) {
      (0, _inherits2.default)(SpriteSvg, _Sprite);

      var _super = _createSuper(SpriteSvg);

      function SpriteSvg() {
        var _this;

        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, SpriteSvg);
        if (typeof attrs === 'string') attrs = {
          svgText: attrs
        };

        var _attrs2 = attrs,
            svgText = _attrs2.svgText,
            _attrs = (0, _objectWithoutProperties2.default)(_attrs2, ["svgText"]);

        _this = _super.call(this, _attrs);
        _this[_root] = document.createElement('div');

        if (svgText) {
          _this[_root].innerHTML = svgText;
          var svg = _this[_root].children[0];
          if (svg) svg.setAttribute('xmlns', namespace);else {
            // not svg text
            fetch(svgText).then(function (res) {
              return res.text();
            }).then(function (text) {
              _this[_root].innerHTML = text;
              if (!_this.observer || _this.attributes.flexible) updateTexture((0, _assertThisInitialized2.default)(_this));
            });
            svgText = null;
          }
        }

        if (!svgText) {
          var _svg = document.createElementNS(namespace, 'svg');

          _svg.setAttribute('xmlns', namespace);

          _this[_root].appendChild(_svg);
        } // updateTexture(this);


        if (typeof MutationObserver === 'function') {
          var observer = new MutationObserver(function (mutationsList) {
            updateTexture((0, _assertThisInitialized2.default)(_this), false);
          });
          observer.observe(_this[_root], {
            attributes: true,
            subtree: true,
            characterData: true,
            childList: true
          });
          _this.observer = observer;
        }

        return _this;
      }

      (0, _createClass2.default)(SpriteSvg, [{
        key: "setResolution",

        /* override */
        value: function setResolution(_ref) {
          var width = _ref.width,
              height = _ref.height;
          (0, _get2.default)((0, _getPrototypeOf2.default)(SpriteSvg.prototype), "setResolution", this).call(this, {
            width: width,
            height: height
          });
          updateTexture(this);
        }
        /* override */

      }, {
        key: "dispatchPointerEvent",
        value: function dispatchPointerEvent(event) {
          // 派发事件给 svg 元素，但是目前只支持派发给 svg 根元素，不支持派发给子元素
          var ret = (0, _get2.default)((0, _getPrototypeOf2.default)(SpriteSvg.prototype), "dispatchPointerEvent", this).call(this, event);

          if (ret && this.attributes.passEvents && typeof MouseEvent === 'function') {
            var x = event.x,
                y = event.y;

            var _this$getOffsetPositi = this.getOffsetPosition(x, y),
                _this$getOffsetPositi2 = (0, _slicedToArray2.default)(_this$getOffsetPositi, 2),
                offsetX = _this$getOffsetPositi2[0],
                offsetY = _this$getOffsetPositi2[1];

            var originalEvent = event.originalEvent;
            var anchor = this.attributes.anchor;
            var cz = this.clientSize;
            offsetX = (offsetX + anchor[0] * cz[0]) / 2;
            offsetY = (offsetY + anchor[1] * cz[1]) / 2;
            var type = event.type;

            if (type === originalEvent.type) {
              var newEvent = null;

              if (originalEvent instanceof MouseEvent) {
                newEvent = new MouseEvent(type, {
                  screenX: offsetX,
                  screenY: offsetY,
                  clientX: offsetX,
                  clientY: offsetY,
                  bubbles: originalEvent.bubbles,
                  button: originalEvent.button,
                  buttons: originalEvent.buttons,
                  cancelBubble: originalEvent.cancelBubble,
                  cancelable: originalEvent.cancelable,
                  currentTarget: originalEvent.currentTarget,
                  fromElement: originalEvent.fromElement,
                  relatedTarget: originalEvent.relatedTarget,
                  returnValue: originalEvent.returnValue,
                  srcElement: originalEvent.srcElement,
                  target: originalEvent.target,
                  toElement: originalEvent.toElement,
                  // view: originalEvent.view,
                  which: originalEvent.witch
                });
              } else if (originalEvent instanceof TouchEvent) {
                var originalTouch = null;
                var pointers = originalEvent.changedTouches || [originalEvent];

                for (var i = 0; i < pointers.length; i++) {
                  var pointer = pointers[i];

                  if (event.identifier === pointer.identifier) {
                    originalTouch = pointer;
                    break;
                  }
                }

                if (originalTouch) {
                  var newTouch = new Touch({
                    identifier: originalTouch.identifier,
                    target: originalTouch.target,
                    clientX: offsetX,
                    clientY: offsetY,
                    screenX: offsetX,
                    screenY: offsetY,
                    pageX: offsetX,
                    pageY: offsetY,
                    radiusX: originalTouch.radiusX,
                    radiusY: originalTouch.radiusY,
                    rotationAngle: originalTouch.rotationAngle,
                    force: originalTouch.force
                  });
                  newEvent = new TouchEvent(type, {
                    cancelable: originalEvent.cancelable,
                    bubbles: originalEvent.bubbles,
                    composed: originalEvent.composed,
                    touches: [newTouch],
                    targetTouches: [newTouch],
                    changedTouches: [newTouch]
                  });
                }
              } else {
                newEvent = originalEvent;
              }

              if (newEvent) this.svg.dispatchEvent(newEvent);
            }
          }

          return ret;
        }
      }, {
        key: "getElementById",
        value: function getElementById(id) {
          return (0, selector.querySelector)("#".concat(id), this);
        }
      }, {
        key: "getElementsByClassName",
        value: function getElementsByClassName(className) {
          return (0, selector.querySelectorAll)(".".concat(className), this);
        }
      }, {
        key: "getElementsByName",
        value: function getElementsByName(name) {
          return (0, selector.querySelectorAll)("[name=\"".concat(name, "\"]"), this);
        }
      }, {
        key: "getElementsByTagName",
        value: function getElementsByTagName(tagName) {
          return (0, selector.querySelectorAll)(tagName, this);
        }
      }, {
        key: "querySelector",
        value: function querySelector(selector$1) {
          return (0, selector.querySelector)(selector$1, this);
        }
      }, {
        key: "querySelectorAll",
        value: function querySelectorAll(selector$1) {
          return (0, selector.querySelectorAll)(selector$1, this);
        }
        /* override */

      }, {
        key: "onPropertyChange",
        value: function onPropertyChange(key, newValue, oldValue) {
          (0, _get2.default)((0, _getPrototypeOf2.default)(SpriteSvg.prototype), "onPropertyChange", this).call(this, key, newValue, oldValue);

          if (key === 'flexible') {
            updateTexture(this);
          }

          if (this.attributes.flexible && (key === 'width' || key === 'height' || key === 'scale' || key === 'transform')) {
            updateTexture(this);
          }
        }
      }, {
        key: "children",
        get: function get() {
          return [this.svg];
        }
      }, {
        key: "childNodes",
        get: function get() {
          return [this.svg];
        }
      }, {
        key: "svg",
        get: function get() {
          if (this[_root]) {
            return this[_root].children[0];
          }

          return null;
        }
      }]);
      return SpriteSvg;
    }(_sprite.default);

    exports.default = SpriteSvg;
    (0, _defineProperty2.default)(SpriteSvg, "Attr", _spritesvg.default);

    _document.default.registerNode(SpriteSvg, 'spritesvg');
  });
  unwrapExports(spritesvg);

  var layerWorker = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _defineProperty2 = interopRequireDefault(defineProperty$3);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _wrapNativeSuper2 = interopRequireDefault(wrapNativeSuper);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            (0, _defineProperty2.default)(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _inited = Symbol('inited');

    var LayerWorker = null; // eslint-disable-line import/no-mutable-exports

    if (typeof Worker === 'function') {
      LayerWorker = /*#__PURE__*/function (_Worker) {
        (0, _inherits2.default)(LayerWorker, _Worker);

        var _super = _createSuper(LayerWorker);

        function LayerWorker(options) {
          var _this;

          (0, _classCallCheck2.default)(this, LayerWorker);

          if (options.worker === true) {
            options.worker = "./".concat(options.id, ".worker.js");
          }

          _this = _super.call(this, options.worker);
          _this.options = options;

          if (!options.canvas) {
            var _this$getResolution = _this.getResolution(),
                width = _this$getResolution.width,
                height = _this$getResolution.height;

            var canvas = mesh.ENV.createCanvas(width, height, {
              offscreen: false
            });

            if (canvas.style) canvas.style.position = 'absolute';
            if (canvas.dataset) canvas.dataset.layerId = options.id;
            options.canvas = canvas;
          }

          _this.canvas = options.canvas;
          return _this;
        }

        (0, _createClass2.default)(LayerWorker, [{
          key: "setResolution",
          value: function setResolution(_ref) {
            var width = _ref.width,
                height = _ref.height;

            if (!this[_inited]) {
              this.canvas.width = width;
              this.canvas.height = height;
              var options = this.options;
              var offscreenCanvas = options.canvas.transferControlToOffscreen();

              var opts = _objectSpread({}, options);

              delete opts.container;
              opts.canvas = offscreenCanvas;
              this.postMessage({
                type: 'create',
                options: opts
              }, [offscreenCanvas]);
              this[_inited] = true;
            } else {
              this.postMessage({
                type: 'resolution_change',
                width: width,
                height: height
              }); // throw new Error('Cannot change resolution of layer-worker.');
            }
          }
        }, {
          key: "getResolution",
          value: function getResolution() {
            if (this.canvas) {
              var _this$canvas = this.canvas,
                  width = _this$canvas.width,
                  height = _this$canvas.height;
              return {
                width: width,
                height: height
              };
            }

            return {
              width: 300,
              height: 150
            };
          }
        }, {
          key: "remove",
          value: function remove() {
            if (this.parent && this.parent.removeChild) {
              this.parent.removeChild(this);
              return true;
            }

            return false;
          }
        }, {
          key: "connect",
          value: function connect(parent, zOrder) {
            Object.defineProperty(this, 'parent', {
              value: parent,
              writable: false,
              configurable: true
            });
            Object.defineProperty(this, 'zOrder', {
              value: zOrder,
              writable: false,
              configurable: true
            });
          }
        }, {
          key: "disconnect",
          value: function disconnect() {
            delete this.parent;
            delete this.zOrder;
          }
        }, {
          key: "dispatchPointerEvent",
          value: function dispatchPointerEvent(event) {
            this.postMessage({
              type: 'event',
              event: {
                cancelBubble: event.cancelBubble,
                bubbles: event.bubbles,
                detail: event.detail,
                identifier: event.identifier,
                layerX: event.layerX,
                layerY: event.layerY,
                originalX: event.originalX,
                originalY: event.originalY,
                type: event.type,
                x: event.x,
                y: event.y
              }
            });
          }
        }, {
          key: "id",
          get: function get() {
            return this.options.id;
          }
        }]);
        return LayerWorker;
      }( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Worker));
    }

    var _default = LayerWorker;
    exports.default = _default;
  });
  unwrapExports(layerWorker);

  var pointerEvents = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createPointerEvents;

    var _event = interopRequireDefault(event);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function createPointerEvents(originalEvent) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$offsetTop = _ref.offsetTop,
          offsetTop = _ref$offsetTop === void 0 ? 0 : _ref$offsetTop,
          _ref$offsetLeft = _ref.offsetLeft,
          offsetLeft = _ref$offsetLeft === void 0 ? 0 : _ref$offsetLeft,
          _ref$displayRatio = _ref.displayRatio,
          displayRatio = _ref$displayRatio === void 0 ? 1 : _ref$displayRatio;

      var x, y;
      var originalCoordinates = [];

      var _originalEvent$target = originalEvent.target.getBoundingClientRect(),
          left = _originalEvent$target.left,
          top = _originalEvent$target.top,
          viewportWidth = _originalEvent$target.width,
          viewportHeight = _originalEvent$target.height;

      var resolutionWidth = originalEvent.target.width;
      var resolutionHeight = originalEvent.target.height;
      var pointers = originalEvent.changedTouches || [originalEvent];

      for (var i = 0; i < pointers.length; i++) {
        var pointer = pointers[i];
        var identifier = pointer.identifier;
        var clientX = pointer.clientX,
            clientY = pointer.clientY;

        if (clientX != null && clientY != null) {
          originalCoordinates.push({
            x: Math.round((clientX | 0) - left),
            y: Math.round((clientY | 0) - top),
            identifier: identifier
          });
        }
      }

      if (originalCoordinates.length <= 0) originalCoordinates.push({
        x: x,
        y: y
      });
      var ret = [];
      originalCoordinates.forEach(function (originalCoordinate) {
        if (originalCoordinate.x != null && originalCoordinate.y != null) {
          x = (originalCoordinate.x * resolutionWidth / viewportWidth - offsetLeft) / displayRatio;
          y = (originalCoordinate.y * resolutionHeight / viewportHeight - offsetTop) / displayRatio;
        }

        var event = new _event.default(originalEvent);
        Object.defineProperties(event, {
          layerX: {
            value: x,
            configurable: true
          },
          layerY: {
            value: y,
            configurable: true
          },
          originalX: {
            value: originalCoordinate.x
          },
          originalY: {
            value: originalCoordinate.y
          },
          x: {
            value: x,
            configurable: true
          },
          y: {
            value: y,
            configurable: true
          },
          identifier: {
            value: originalCoordinate.identifier
          }
        });
        ret.push(event);
      });
      return ret;
    }
  });
  unwrapExports(pointerEvents);

  var scene$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _regenerator = interopRequireDefault(regenerator);

    var _asyncToGenerator2 = interopRequireDefault(asyncToGenerator);

    var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

    var _createClass2 = interopRequireDefault(createClass$1);

    var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized);

    var _get2 = interopRequireDefault(get);

    var _inherits2 = interopRequireDefault(inherits);

    var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn);

    var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf);

    var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

    var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

    var _node = interopRequireDefault(node);

    var _layer2 = interopRequireDefault(layer);

    var _layerWorker = interopRequireDefault(layerWorker);

    var _group = interopRequireDefault(group);

    var _pointerEvents = interopRequireDefault(pointerEvents);

    var _event = interopRequireDefault(event);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var _enteredTargets = Symbol('enteredTargets');

    function wrapLayer(layer) {
      // append dom element
      layer.id = layer.id || "_layer".concat(Math.random().toString(36).slice(2, 12));

      if (!layer.dataset) {
        layer.dataset = {};
      }

      layer.dataset.layerId = layer.id; // fixed layer replacer

      layer.connect = function (parent, zOrder) {
        layer.parent = parent;
        Object.defineProperty(layer, 'zOrder', {
          value: zOrder,
          writable: false,
          configurable: true
        });
      };

      layer.disconnect = function (parent) {
        delete layer.zOrder;
      };

      layer.canvas = layer;

      layer.getResolution = function () {
        return {
          width: 0,
          height: 0
        };
      };

      layer.setResolution = function () {
        return false;
      };

      layer.options = {
        handleEvent: false
      };
      return layer;
    }

    function getRefCanvas(scene, layer) {
      var children = scene.children;
      var ref = null;

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (layer === child || ref != null) {
          ref = child;
        }

        if (ref && ref !== layer && !ref.offscreen) {
          return ref.canvas;
        }
      }

      return null;
    }

    function drawImage(layer, offscreenLayer) {
      var _layer$renderOffset = (0, _slicedToArray2.default)(layer.renderOffset, 2),
          left = _layer$renderOffset[0],
          top = _layer$renderOffset[1];

      var _layer$getResolution = layer.getResolution(),
          width = _layer$getResolution.width,
          height = _layer$getResolution.height;

      var displayRatio = layer.displayRatio;
      layer.renderer.drawImage(offscreenLayer.canvas, -left / displayRatio, -top / displayRatio, width / displayRatio, height / displayRatio);
    }

    var touchEventCapturedTargets = {};

    function delegateEvents(scene) {
      var events = ['mousedown', 'mouseup', 'mousemove', 'mousewheel', 'wheel', 'touchstart', 'touchend', 'touchmove', 'touchcancel', 'click', 'dblclick', 'longpress', 'tap', 'contextmenu'];
      var container = scene.container;
      container.addEventListener('mouseleave', function (event) {
        var enteredTargets = scene[_enteredTargets];

        if (enteredTargets.size) {
          var leaveEvent = new _event.default('mouseleave');
          leaveEvent.setOriginalEvent(event);
          (0, _toConsumableArray2.default)(enteredTargets).forEach(function (target) {
            target.dispatchEvent(leaveEvent);
          });

          scene[_enteredTargets].clear();
        }
      }, {
        passive: true
      });
      events.forEach(function (eventType) {
        container.addEventListener(eventType, function (event) {
          var _scene$options = scene.options,
              left = _scene$options.left,
              top = _scene$options.top,
              displayRatio = _scene$options.displayRatio;
          var layers = scene.orderedChildren;
          var pointerEvents = (0, _pointerEvents.default)(event, {
            offsetLeft: left,
            offsetTop: top,
            displayRatio: displayRatio
          });
          pointerEvents.forEach(function (evt) {
            // evt.scene = scene;
            var id = evt.identifier;

            if (evt.type === 'touchmove' || evt.type === 'touchend') {
              var capturedTarget = touchEventCapturedTargets[id];
              if (capturedTarget) capturedTarget.dispatchEvent(evt);
              if (evt.type === 'touchend') delete touchEventCapturedTargets[id];
            } else {
              for (var i = layers.length - 1; i >= 0; i--) {
                var layer = layers[i];

                if (layer.options.handleEvent !== false) {
                  var ret = layer.dispatchPointerEvent(evt);
                  if (ret && evt.target !== layer) break;else evt.cancelBubble = false; // prepare passing to next layer
                }
              }

              if (evt.target === layers[0]) {
                // trigger event on top layer
                for (var _i = layers.length - 1; _i >= 0; _i--) {
                  var _layer = layers[_i];

                  if (_layer.options.handleEvent !== false) {
                    evt.target = _layer;
                    break;
                  }
                }
              }
            }

            var target = evt.target;

            if (evt.type === 'touchstart') {
              touchEventCapturedTargets[id] = evt.target; // set captured event target
            }

            if (evt.type === 'mousemove') {
              var enteredTargets = scene[_enteredTargets];
              var enterSet;

              if (target) {
                var ancestors = target.ancestors || [];
                enterSet = new Set([target].concat((0, _toConsumableArray2.default)(ancestors)));
              } else {
                enterSet = new Set();
              }

              var entries = Object.entries(event);

              if (!enteredTargets.has(target)) {
                if (target) {
                  var enterEvent = new _event.default('mouseenter');
                  enterEvent.setOriginalEvent(event);
                  entries.forEach(function (_ref) {
                    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                        key = _ref2[0],
                        value = _ref2[1];

                    enterEvent[key] = value;
                  });
                  enteredTargets.add(target);
                  target.dispatchEvent(enterEvent);
                  var _ancestors = target.ancestors;

                  if (_ancestors) {
                    _ancestors.forEach(function (ancestor) {
                      if (ancestor instanceof _node.default && !enteredTargets.has(ancestor)) {
                        enteredTargets.add(ancestor);
                        ancestor.dispatchEvent(enterEvent);
                      }
                    });
                  }
                }
              }

              var leaveEvent = new _event.default('mouseleave');
              leaveEvent.setOriginalEvent(event);
              entries.forEach(function (_ref3) {
                var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
                    key = _ref4[0],
                    value = _ref4[1];

                leaveEvent[key] = value;
              });
              (0, _toConsumableArray2.default)(enteredTargets).forEach(function (target) {
                if (!enterSet.has(target)) {
                  enteredTargets.delete(target);
                  target.dispatchEvent(leaveEvent);
                }
              });
            }
          });
        }, {
          passive: eventType !== 'contextmenu'
        });
      });
    }

    function setViewport(options, canvas) {
      if (canvas && canvas.style) {
        var width = options.width,
            height = options.height,
            mode = options.mode,
            container = options.container;
        var clientWidth = container.clientWidth,
            clientHeight = container.clientHeight;
        width = width || clientWidth;
        height = height || clientHeight;

        if (mode === 'static') {
          canvas.style.width = "".concat(width, "px");
          canvas.style.height = "".concat(height, "px"); // canvas.style.top = '50%';
          // canvas.style.left = '50%';
          // canvas.style.transform = 'translate(-50%, -50%)';
          // canvas.style.webkitTransform = 'translate(-50%, -50%)';
        } else {
          canvas.style.top = '0';
          canvas.style.left = '0';
          canvas.style.width = "".concat(clientWidth, "px");
          canvas.style.height = "".concat(clientHeight, "px");
          canvas.style.transform = '';
          canvas.style.webkitTransform = '';
        }
      }
    }

    var _offscreenLayerCount = Symbol('offscreenLayerCount');

    var Scene = /*#__PURE__*/function (_Group) {
      (0, _inherits2.default)(Scene, _Group);

      var _super = _createSuper(Scene);
      /**
        width
        height
        mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
       */


      function Scene() {
        var _this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck2.default)(this, Scene);
        _this = _super.call(this);

        if (!options.container) {
          if (typeof mesh.ENV.Container === 'function') {
            options.container = new mesh.ENV.Container(options.width || 300, options.height || 150);
          } else {
            throw new Error('No container specified.');
          }
        }

        _this.container = options.container;

        if (_this.container.style) {
          if (!_this.container.style.overflow) {
            _this.container.style.overflow = 'hidden';
          }

          if (!_this.container.style.position) {
            _this.container.style.position = 'relative';
          }
        }

        _this.options = options;
        options.displayRatio = options.displayRatio || 1.0;
        options.mode = options.mode || 'scale';
        options.left = 0;
        options.top = 0;
        options.autoResize = options.autoResize !== false;

        if (options.autoResize) {
          var self; // cross platform

          if (typeof globalThis !== 'undefined') {
            self = globalThis;
          } else {
            self = typeof window !== 'undefined' ? window : commonjsGlobal;
          }

          if (self.addEventListener) {
            var that = (0, _assertThisInitialized2.default)(_this);
            self.addEventListener('resize', function listener() {
              if (typeof document !== 'undefined' && document.contains(that.container)) {
                that.resize();
              } else {
                self.removeEventListener('resize', listener);
              }
            });
          }
        }

        _this[_enteredTargets] = new Set();

        _this.setResolution(options);

        delegateEvents((0, _assertThisInitialized2.default)(_this));
        _this[_offscreenLayerCount] = 0;
        return _this;
      }

      (0, _createClass2.default)(Scene, [{
        key: "appendChild",

        /* override */
        value: function appendChild(layer) {
          if (!(layer instanceof _layer2.default) && !(layer instanceof _layerWorker.default)) {
            wrapLayer(layer);
          }

          var ret = (0, _get2.default)((0, _getPrototypeOf2.default)(Scene.prototype), "appendChild", this).call(this, layer);
          var canvas = layer.canvas;

          if (!layer.offscreen) {
            this.container.appendChild(canvas);
          } else {
            this[_offscreenLayerCount]++;
          }

          setViewport(this.options, canvas);
          layer.setResolution(this.getResolution());
          return ret;
        }
        /* override */

      }, {
        key: "forceUpdate",
        value: function forceUpdate() {
          var _this2 = this;

          if (this.hasOffscreenCanvas && !this._requestID) {
            this._requestID = (0, animationFrame.requestAnimationFrame)(function () {
              delete _this2._requestID;

              _this2.render();
            });
          }
        }
        /* override */

      }, {
        key: "insertBefore",
        value: function insertBefore(layer, ref) {
          if (!(layer instanceof _layer2.default) && !(layer instanceof _layerWorker.default)) {
            wrapLayer(layer);
          }

          var ret = (0, _get2.default)((0, _getPrototypeOf2.default)(Scene.prototype), "insertBefore", this).call(this, layer, ref);
          var canvas = layer.canvas;

          if (!layer.offscreen) {
            var refChild = getRefCanvas(this, layer);
            this.container.insertBefore(canvas, refChild);
          }

          setViewport(this.options, canvas);
          layer.setResolution(this.getResolution());
          return ret;
        }
      }, {
        key: "layer",
        value: function layer() {
          var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          options = Object.assign({}, this.options, options);
          options.id = id;
          var layers = this.orderedChildren;

          for (var i = 0; i < layers.length; i++) {
            if (layers[i].id === id) return layers[i];
          }

          var worker = options.worker;
          var layer;

          if (worker) {
            layer = new _layerWorker.default(options);
          } else {
            layer = new _layer2.default(options); // layer.id = id;
          }

          this.appendChild(layer);
          return layer;
        }
      }, {
        key: "preload",
        value: function () {
          var _preload = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
            var _this3 = this;

            var _len,
                resources,
                _key,
                loaded,
                tasks,
                ret,
                _loop,
                i,
                _args = arguments;

            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    for (_len = _args.length, resources = new Array(_len), _key = 0; _key < _len; _key++) {
                      resources[_key] = _args[_key];
                    }

                    loaded = [], tasks = [], ret = [];

                    _loop = function _loop(i) {
                      var res = resources[i];
                      var task = void 0;

                      if (typeof res === 'string') {
                        task = (0, texture.loadTexture)(res);
                      } else if (Array.isArray(res)) {
                        task = texture.loadFrames.apply(void 0, (0, _toConsumableArray2.default)(res));
                      } else {
                        var id = res.id,
                            src = res.src;
                        task = (0, texture.loadTexture)(src, id);
                      }
                      /* istanbul ignore if  */


                      if (!(task instanceof Promise)) {
                        task = Promise.resolve(task);
                      }

                      tasks.push(task.then(function (r) {
                        loaded.push(r);
                        ret[i] = r;
                        var preloadEvent = new _event.default({
                          type: 'preload',
                          detail: {
                            current: r,
                            loaded: loaded,
                            resources: resources
                          }
                        });

                        _this3.dispatchEvent(preloadEvent);
                      }));
                    };

                    for (i = 0; i < resources.length; i++) {
                      _loop(i);
                    }

                    _context.next = 6;
                    return Promise.all(tasks);

                  case 6:
                    return _context.abrupt("return", ret);

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function preload() {
            return _preload.apply(this, arguments);
          }

          return preload;
        }()
        /* override */

      }, {
        key: "removeChild",
        value: function removeChild(layer) {
          var ret = (0, _get2.default)((0, _getPrototypeOf2.default)(Scene.prototype), "removeChild", this).call(this, layer);

          if (ret) {
            if (layer._prepareRenderFinished) layer._prepareRenderFinished();
            var canvas = layer.canvas;
            if (canvas && canvas.remove) canvas.remove();
            if (layer.offscreen) this[_offscreenLayerCount]--;
          }

          return ret;
        } // for offscreen mode rendering

      }, {
        key: "render",
        value: function render() {
          var layers = this.orderedChildren;
          var hostLayer = null;
          var offscreens = [];

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            var hasOffscreens = offscreens.length > 0;

            if (layer instanceof _layer2.default && !layer.offscreen) {
              if (!layer.autoRender) {
                if (hasOffscreens) {
                  console.warn('Some offscreen canvas will not be rendered.');
                  offscreens.length = 0;
                }
              } else {
                hostLayer = layer;

                if (hasOffscreens) {
                  layer.renderer.clear();

                  for (var j = 0; j < offscreens.length; j++) {
                    var ol = offscreens[j];
                    ol.render();
                    drawImage(layer, ol);
                  }

                  offscreens.length = 0;
                  layer.render({
                    clear: false
                  });
                } else if (layer.prepareRender) {
                  layer.render();
                }
              }
            } else if (layer.offscreen) {
              if (hostLayer) {
                if (layer.prepareRender) layer.render();
                drawImage(hostLayer, layer);
              } else {
                offscreens.push(layer);
              }
            } else if (layer instanceof _layerWorker.default && hasOffscreens) {
              console.warn('Some offscreen canvas will not be rendered.');
              offscreens.length = 0;
            }
          }
        }
        /* override */

      }, {
        key: "replaceChild",
        value: function replaceChild(layer, ref) {
          var ret = (0, _get2.default)((0, _getPrototypeOf2.default)(Scene.prototype), "replaceChild", this).call(this, layer, ref);
          if (ref.canvas.remove) ref.canvas.remove();
          if (ref.offscreen) this[_offscreenLayerCount]--;
          var canvas = layer.canvas;

          if (!layer.offscreen) {
            var refChild = getRefCanvas(this, layer);
            this.container.insertBefore(canvas, refChild);
          }

          setViewport(this.options, canvas);
          layer.setResolution(this.getResolution());
          return ret;
        }
      }, {
        key: "resize",
        value: function resize() {
          var options = this.options;
          this.children.forEach(function (layer) {
            setViewport(options, layer.canvas);
          });
          this.setResolution(options);
          this.dispatchEvent({
            type: 'resize'
          });
        }
        /* override */

      }, {
        key: "setResolution",
        value: function setResolution() {
          var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              width = _ref5.width,
              height = _ref5.height;

          var container = this.container;
          var clientWidth = container.clientWidth,
              clientHeight = container.clientHeight;

          if (width == null || height == null) {
            width = width == null ? clientWidth : width;
            height = height == null ? clientHeight : height;
          }

          var _this$options = this.options,
              mode = _this$options.mode,
              displayRatio = _this$options.displayRatio;
          width *= displayRatio;
          height *= displayRatio;
          this.options.left = 0;
          this.options.top = 0;

          if (mode === 'stickyHeight' || mode === 'stickyLeft' || mode === 'stickyRight') {
            var w = width;
            width = clientWidth * height / clientHeight;
            if (mode === 'stickyHeight') this.options.left = 0.5 * (width - w);
            if (mode === 'stickyRight') this.options.left = width - w;
          } else if (mode === 'stickyWidth' || mode === 'stickyTop' || mode === 'stickyBottom') {
            var h = height;
            height = clientHeight * width / clientWidth;
            if (mode === 'stickyWidth') this.options.top = 0.5 * (height - h);
            if (mode === 'stickyBottom') this.options.top = height - h;
          }

          (0, _get2.default)((0, _getPrototypeOf2.default)(Scene.prototype), "setResolution", this).call(this, {
            width: width,
            height: height
          });
        }
      }, {
        key: "snapshot",
        value: function snapshot() {
          var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref6$offscreen = _ref6.offscreen,
              offscreen = _ref6$offscreen === void 0 ? false : _ref6$offscreen,
              layers = _ref6.layers;

          var _canvas = offscreen ? 'snapshotOffScreenCanvas' : 'snapshotCanvas';

          var _this$getResolution = this.getResolution(),
              width = _this$getResolution.width,
              height = _this$getResolution.height;

          this[_canvas] = this[_canvas] || mesh.ENV.createCanvas(width, height, {
            offscreen: offscreen
          });

          var context = this[_canvas].getContext('2d');

          layers = layers || this.orderedChildren; // context.clearRect(0, 0, width, height);

          this[_canvas].width = width;
          this[_canvas].height = height;

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];

            if (!layer.options.ignoreSnapshot) {
              if (layer.render) layer.render();
              var canvas = layer.canvas;

              if (canvas && canvas !== layer) {
                context.drawImage(canvas, 0, 0, width, height);
              }
            }
          }

          return this[_canvas];
        }
      }, {
        key: "hasOffscreenCanvas",
        get: function get() {
          return this[_offscreenLayerCount] > 0;
        }
      }, {
        key: "displayRatio",
        set: function set(value) {
          var oldValue = this.options.displayRatio;

          if (oldValue !== value) {
            this.options.displayRatio = value;
            this.resize();
          }
        },
        get: function get() {
          return this.options.displayRatio;
        }
      }, {
        key: "height",
        set: function set(value) {
          var oldValue = this.options.height;

          if (oldValue !== value) {
            this.options.height = value;
            this.resize();
          }
        },
        get: function get() {
          return this.options.height;
        }
      }, {
        key: "mode",
        set: function set(value) {
          var oldValue = this.options.mode;

          if (oldValue !== value) {
            this.options.mode = value;
            this.resize();
          }
        },
        get: function get() {
          return this.options.mode;
        }
      }, {
        key: "width",
        set: function set(value) {
          var oldValue = this.options.width;

          if (oldValue !== value) {
            this.options.width = value;
            this.resize();
          }
        },
        get: function get() {
          return this.options.width;
        }
      }]);
      return Scene;
    }(_group.default);

    exports.default = Scene;

    if (typeof document !== 'undefined') {
      Scene.prototype.layer3d = function (id) {
        var _this4 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var url = options.url || 'https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js';
        return new Promise(function (resolve, reject) {
          var el = document.createElement('script');
          el.async = false;
          el.src = url;

          el.onload = function () {
            try {
              resolve(_this4.layer3d(id, options));
            } catch (ex) {
              reject(ex);
            }
          };

          document.documentElement.appendChild(el);
        });
      };
    }

    _document.default.registerNode(Scene, 'scene');
  });
  unwrapExports(scene$1);

  var name = "spritejs";
  var version = "3.8.0";
  var description = "A cross platform high-performance graphics system.";
  var main = "dist/spritejs.js";
  var typings = "typings/spritejs.d.ts";
  var module = "lib/index.js";
  var scripts = {
  	test: "jest --coverage",
  	"test:build": "jest --updateSnapshot --coverage",
  	"test:coveralls": "jest --coverage --coverageReporters=text-lcov | coveralls",
  	start: "webpack-dev-server --env.server=examples --watch-poll",
  	compile: "rm -rf lib/* && babel src -d lib",
  	doc: "docsify serve ./docs",
  	build: "rm -rf dist/* && webpack --env.mode=none & webpack --env.mode=none --env.esnext & webpack --env.mode=none --env.esnext --env.module & webpack --env.mode=production & webpack --env.mode=production --env.esnext",
  	"demo:dev": "demosify --serve",
  	"demo:prod": "demosify --prod",
  	benchmark: "webpack-dev-server --watch-poll --env.server=benchmark",
  	prepublishOnly: "npm run compile && npm run build && npm run demo:prod"
  };
  var homepage = "https://spritejs.com";
  var repository = {
  	type: "git",
  	url: "https://github.com/spritejs/spritejs"
  };
  var keywords = [
  	"webgl",
  	"webgl2",
  	"3d",
  	"2d",
  	"rendering",
  	"canvas"
  ];
  var author = "akira-cn";
  var license = "MIT";
  var devDependencies = {
  	"@babel/cli": "^7.14.8",
  	"@babel/core": "^7.4.5",
  	"@babel/plugin-proposal-class-properties": "^7.4.4",
  	"@babel/plugin-transform-runtime": "^7.4.4",
  	"@babel/preset-env": "^7.4.5",
  	"@babel/register": "^7.8.6",
  	"@demosify/core": "^0.6.0",
  	"@purtuga/esm-webpack-plugin": "^1.2.1",
  	"babel-eslint": "^10.0.1",
  	"babel-loader": "^8.0.6",
  	"babel-plugin-transform-gl-matrix": "^0.6.0",
  	colors: "^1.4.0",
  	coveralls: "^3.0.9",
  	docsify: "^4.12.1",
  	eslint: "^5.16.0",
  	"eslint-config-sprite": "^1.0.6",
  	"eslint-plugin-html": "^5.0.5",
  	gl: "^4.4.0",
  	jest: "^25.1.0",
  	"node-canvas-webgl": "^0.2.6",
  	"raw-loader": "^3.1.0",
  	request: "^2.88.0",
  	webpack: "^4.33.0",
  	"webpack-cli": "^3.3.4",
  	"webpack-dev-server": "^3.11.0"
  };
  var dependencies = {
  	"@babel/runtime": "^7.4.5",
  	"@mesh.js/core": "^1.1.23",
  	"color-rgba": "^2.1.1",
  	"css-select": "^2.0.2",
  	"gl-matrix": "^3.1.0",
  	pasition: "^1.0.2",
  	"sprite-animator": "^1.11.5"
  };
  var jest = {
  	testRegex: "/test/.*.test.js$",
  	testEnvironmentOptions: {
  		pretendToBeVisual: true
  	},
  	moduleNameMapper: {
  	},
  	setupFiles: [
  		"./src/platform/jest-jsdom"
  	]
  };
  var _package = {
  	name: name,
  	version: version,
  	description: description,
  	main: main,
  	typings: typings,
  	module: module,
  	scripts: scripts,
  	homepage: homepage,
  	repository: repository,
  	keywords: keywords,
  	author: author,
  	license: license,
  	devDependencies: devDependencies,
  	dependencies: dependencies,
  	jest: jest
  };

  var _package$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name,
    version: version,
    description: description,
    main: main,
    typings: typings,
    module: module,
    scripts: scripts,
    homepage: homepage,
    repository: repository,
    keywords: keywords,
    author: author,
    license: license,
    devDependencies: devDependencies,
    dependencies: dependencies,
    jest: jest,
    'default': _package
  });

  var require$$22 = getCjsExportFromNamespace(_package$1);

  var lib = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ENV", {
      enumerable: true,
      get: function get() {
        return mesh.ENV;
      }
    });
    Object.defineProperty(exports, "requestAnimationFrame", {
      enumerable: true,
      get: function get() {
        return animationFrame.requestAnimationFrame;
      }
    });
    Object.defineProperty(exports, "cancelAnimationFrame", {
      enumerable: true,
      get: function get() {
        return animationFrame.cancelAnimationFrame;
      }
    });
    Object.defineProperty(exports, "Node", {
      enumerable: true,
      get: function get() {
        return _node.default;
      }
    });
    Object.defineProperty(exports, "Cloud", {
      enumerable: true,
      get: function get() {
        return _cloud.default;
      }
    });
    Object.defineProperty(exports, "Block", {
      enumerable: true,
      get: function get() {
        return _block.default;
      }
    });
    Object.defineProperty(exports, "Sprite", {
      enumerable: true,
      get: function get() {
        return _sprite.default;
      }
    });
    Object.defineProperty(exports, "Path", {
      enumerable: true,
      get: function get() {
        return _path.default;
      }
    });
    Object.defineProperty(exports, "Rect", {
      enumerable: true,
      get: function get() {
        return _rect.default;
      }
    });
    Object.defineProperty(exports, "Triangle", {
      enumerable: true,
      get: function get() {
        return _triangle.default;
      }
    });
    Object.defineProperty(exports, "Parallel", {
      enumerable: true,
      get: function get() {
        return _parallel.default;
      }
    });
    Object.defineProperty(exports, "Regular", {
      enumerable: true,
      get: function get() {
        return _regular.default;
      }
    });
    Object.defineProperty(exports, "Star", {
      enumerable: true,
      get: function get() {
        return _star.default;
      }
    });
    Object.defineProperty(exports, "Ellipse", {
      enumerable: true,
      get: function get() {
        return _ellipse.default;
      }
    });
    Object.defineProperty(exports, "Arc", {
      enumerable: true,
      get: function get() {
        return _arc.default;
      }
    });
    Object.defineProperty(exports, "Ring", {
      enumerable: true,
      get: function get() {
        return _ring.default;
      }
    });
    Object.defineProperty(exports, "Polyline", {
      enumerable: true,
      get: function get() {
        return _polyline.default;
      }
    });
    Object.defineProperty(exports, "Label", {
      enumerable: true,
      get: function get() {
        return _label.default;
      }
    });
    Object.defineProperty(exports, "Group", {
      enumerable: true,
      get: function get() {
        return _group.default;
      }
    });
    Object.defineProperty(exports, "Layer", {
      enumerable: true,
      get: function get() {
        return _layer.default;
      }
    });
    Object.defineProperty(exports, "SpriteSvg", {
      enumerable: true,
      get: function get() {
        return _spritesvg.default;
      }
    });
    Object.defineProperty(exports, "LayerWorker", {
      enumerable: true,
      get: function get() {
        return _layerWorker.default;
      }
    });
    Object.defineProperty(exports, "Scene", {
      enumerable: true,
      get: function get() {
        return _scene.default;
      }
    });
    Object.defineProperty(exports, "Gradient", {
      enumerable: true,
      get: function get() {
        return color.Gradient;
      }
    });
    Object.defineProperty(exports, "Color", {
      enumerable: true,
      get: function get() {
        return color.Color;
      }
    });
    exports.registerNode = exports.isSpriteNode = exports.createElement = exports.helpers = exports.version = void 0;

    var _node = interopRequireDefault(node);

    var _cloud = interopRequireDefault(cloud);

    var _block = interopRequireDefault(block$1);

    var _sprite = interopRequireDefault(sprite);

    var _path = interopRequireDefault(path);

    var _rect = interopRequireDefault(rect$1);

    var _triangle = interopRequireDefault(triangle$1);

    var _parallel = interopRequireDefault(parallel$1);

    var _regular = interopRequireDefault(regular);

    var _star = interopRequireDefault(star$1);

    var _ellipse = interopRequireDefault(ellipse);

    var _arc = interopRequireDefault(arc);

    var _ring = interopRequireDefault(ring$1);

    var _polyline = interopRequireDefault(polyline);

    var _label = interopRequireDefault(label);

    var _group = interopRequireDefault(group);

    var _layer = interopRequireDefault(layer);

    var _spritesvg = interopRequireDefault(spritesvg);

    var _layerWorker = interopRequireDefault(layerWorker);

    var _scene = interopRequireDefault(scene$1);

    var _document = interopRequireDefault(document$1);

    esm$1.glMatrix.setMatrixArrayType(Array);
    var createElement = _document.default.createElement;
    exports.createElement = createElement;
    var isSpriteNode = _document.default.isSpriteNode;
    exports.isSpriteNode = isSpriteNode;
    var registerNode = _document.default.registerNode;
    exports.registerNode = registerNode;
    var helpers = {
      parseColor: color.parseColor,
      sizeToPixel: attribute_value.sizeToPixel,
      toArray: attribute_value.toArray,
      toString: attribute_value.toString,
      toNumber: attribute_value.toNumber
    };
    exports.helpers = helpers;
    var spriteVer;

    if (typeof __SPRITEVER__ === 'string') {
      spriteVer = __SPRITEVER__; // eslint-disable-line no-undef
    } else {
      spriteVer = require$$22.version;
    }

    var version = spriteVer;
    exports.version = version;
  });
  var index = unwrapExports(lib);
  var lib_1 = lib.registerNode;
  var lib_2 = lib.isSpriteNode;
  var lib_3 = lib.createElement;
  var lib_4 = lib.helpers;
  var lib_5 = lib.version;

  var spritejs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': index,
    __moduleExports: lib,
    registerNode: lib_1,
    isSpriteNode: lib_2,
    createElement: lib_3,
    helpers: lib_4,
    version: lib_5
  });

  /**
   * 基础样式
   *
   * @class jmChartStyle
   * @module jmChart
   * @static
   */
  var defaultStyle = {
    layout: 'normal',
    // inside 二边不对齐Y轴，内缩一个刻度 | normal
    margin: {
      left: 40,
      top: 20,
      right: 20,
      bottom: 40
    },
    itemLabel: {
      textAlign: 'left',
      textBaseline: 'middle',
      font: '12px Arial',
      fill: '#000'
    },
    // 跟随标线
    markLine: {
      x: true,
      // 显示X标线
      y: true,
      // 显示Y标线
      stroke: '#EB792A',
      fill: '#CCC',
      lineWidth: 1,
      radius: 5,
      // 中间小圆圈大小
      zIndex: 20
    },
    legend: {
      stroke: 'transparent',
      lineWidth: 0,
      margin: {
        left: 10,
        top: 10,
        right: 20,
        bottom: 10
      },
      width: 200,
      height: 0,
      item: {
        shape: {
          width: 20,
          height: 15
        },
        label: {
          textAlign: 'left',
          textBaseline: 'middle',
          font: '12px Arial',
          fill: '#000'
        },
        normal: {
          fill: 'transparent',
          cursor: 'default'
        },
        hover: {
          fill: '#ccc',
          cursor: 'pointer'
        }
      }
    },
    chartArea: {
      stroke: 'rgb(229,229,229)',
      zIndex: 5
    },
    axis: {
      stroke: '#05468E',
      lineWidth: 1,
      zIndex: 1,
      // 显示网格
      grid: {
        x: true,
        // 是否显示网格
        y: false,
        stroke: 'rgb(229,229,229)',
        lineType: 'dotted',
        // 虚线，不填为实线
        dashLength: 6,
        //虚线条间隔，默认5
        lineWidth: 1,
        zIndex: 0
      },
      // 如果标签居中 center，则把二头的标签左边的左对齐，右边的右对齐
      align: 'normal',
      xLabel: {
        count: 5,
        length: 5,
        fill: '#000',
        stroke: '#000',
        margin: {
          left: 0,
          top: 10,
          right: 6,
          bottom: 0
        },
        textAlign: 'center',
        textBaseline: 'top',
        font: '12px Arial',
        zIndex: 20,
        // 旋转角度
        rotation: {
          angle: 0,
          point: {
            x: 0,
            y: 0
          }
        }
      },
      yLabel: {
        count: 5,
        length: 1,
        fill: '#000',
        margin: {
          left: 2,
          top: 6,
          right: 8,
          bottom: 0
        },
        textAlign: 'right',
        textBaseline: 'middle',
        font: '12px Arial',
        zIndex: 20,
        // 旋转角度
        rotation: {
          angle: 0,
          point: {
            x: 0,
            y: 0
          }
        }
      }
    },
    // 图形样式集
    chartColors: ['#249FDA', '#EA3B7C', '#8EBC00', '#309B46', '#4B507E', '#D8E404', '#EB792A', '#A00DA0'],

    /*tooltip: {
    	'background-color': 'rgb(255,255,255)',
    	'padding':'4px',
    	'opacity':'0.8',
    	'border':'1px solid #000',
    	'box-shadow': '0 0 3px #000',
    	'border-radius': '6px'
    },*/
    line: {
      normal: {
        lineWidth: 1,
        zIndex: 18,
        cursor: 'default'
      },
      hover: {
        lineWidth: 4,
        //zIndex: 100,
        cursor: 'pointer'
      },
      lineWidth: 1,
      zIndex: 18,
      cursor: 'default',
      radius: 3,
      fill: null,
      showItem: false,
      // 是否展示圆点
      item: {
        fill: '#fff',
        zIndex: 19
      },
      // 默认不填充，需要填满请配置{fill:'',stroke:''}
      area: false
    },
    stackLine: {
      normal: {
        lineWidth: 1,
        zIndex: 18,
        cursor: 'default'
      },
      hover: {
        lineWidth: 4,
        //zIndex: 100,
        cursor: 'pointer'
      },
      lineWidth: 1,
      zIndex: 18,
      cursor: 'default',
      radius: 3,
      fill: null,
      showItem: true,
      // 是否展示圆点
      item: {
        fill: '#fff',
        zIndex: 19
      },
      // 默认不填充，需要填满请配置{fill:'',stroke:''}
      area: false
    },
    bar: {
      normal: {
        lineWidth: 1,
        zIndex: 17,
        cursor: 'default',
        opacity: 0.8
      },
      hover: {
        lineWidth: 4,
        //zIndex: 100,
        opacity: 1,
        cursor: 'pointer'
      },
      lineWidth: 1,
      // 柱子宽占比，决定了柱子相对于总宽度
      perWidth: 0.5,
      zIndex: 17,
      cursor: 'default',
      close: true,
      opacity: 0.8,
      shadow: {
        x: 1,
        y: 1,
        blur: 2,
        color: '#000'
      }
    },
    pie: {
      normal: {
        zIndex: 11,
        cursor: 'default',
        opacity: 0.8
      },
      hover: {
        //zIndex: 100,
        opacity: 1,
        cursor: 'pointer'
      },
      margin: {
        left: 10,
        top: 10,
        right: 10,
        bottom: 10
      },
      lineWidth: 1,
      zIndex: 11,
      cursor: 'default',
      close: true,
      opacity: 0.8,
      shadow: {
        x: 1,
        y: 1,
        blur: 2,
        color: '#ccc'
      }
    },
    candlestick: {
      normal: {
        lineWidth: 1,
        zIndex: 18,
        cursor: 'default'
      },
      hover: {
        //zIndex: 100,
        cursor: 'pointer'
      },
      perWidth: 0.5,
      // 阴线颜色
      negativeColor: 'green',
      // 阳线颜色
      masculineColor: 'red',
      lineWidth: 1
    }
  };

  /**
   * 轴
   *
   * @class jmAxis
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {string} [type] 轴类型(x/y/radar),默认为x
   * @param {string} [dataType] 当前轴的数据类型(number/date/string),默认为 number
   * @param {object} [style] 样式
   */
  class jmAxis {
    constructor(chart, options) {
      _defineProperty(this, "type", 'x');

      _defineProperty(this, "field", '');

      _defineProperty(this, "labelStart", 0);

      _defineProperty(this, "zeroBase", false);

      _defineProperty(this, "labelCount", 1);

      _defineProperty(this, "scalePoints", []);

      this.chart = chart; //初始化不显示箭头

      this.arrowVisible = !!options.arrowVisible;
      this.zeroBase = options.zeroBase || false;
      this.labelCount = options.labelCount || 5;
      this.type = options.type || 'x'; // 为横轴x或纵轴y

      if (this.type == 'x') {
        this.dataType = options.dataType || 'string';
      } else {
        this.dataType = options.dataType || 'number';
      }

      this.field = options.field || '';
      this.index = options.index || 0;
      this.init(options);
    } // 初始化一些参数
    // 这个函数可能会重入。


    init(options) {
      options = options || {}; // 深度组件默认样式

      if (options.style) this.graph.utils.clone(options.style, this.style, true);

      if (this.type == 'x') {
        if (typeof options.maxXValue !== 'undefined') this.maxValue = options.maxXValue; // 最大的值，如果指定了，则如果有数值比它大才会修改上限，否则以它为上限

        if (typeof options.minXValue !== 'undefined') this.minValue = options.minXValue; // 最小值，如果指定了，则轴的最小值为它或更小的值
      } else {
        if (typeof options.maxYValue !== 'undefined' && (options.maxYValue > this.maxValue || typeof this.maxValue === 'undefined')) this.maxValue = options.maxYValue; // 最大的值，如果指定了，则如果有数值比它大才会修改上限，否则以它为上限

        if (typeof options.minYValue !== 'undefined' && (options.minYValue < this.minValue || typeof this.minValue === 'undefined')) this.minValue = options.minYValue; // 最小值，如果指定了，则轴的最小值为它或更小的值
      }
    }
    /**
     * 轴类型(x/y/radar),默认为x
     *
     * @property type
     * @type string
     */


    /**
     * 关联访问的是chart的数据源
     */
    get data() {
      return this.graph.data;
    }

    set data(d) {
      this.graph.data = d;
    }
    /**
     * 计算当前轴的位置
     * 
     * @method reset
     */


    reset() {
      const bounds = this.graph.chartArea.getBounds(); // 获取画图区域

      switch (this.type) {
        case 'x':
          {
            //初始化显示标签个数
            this.labelCount = this.style.xLabel.count || 5;
            this.start.x = bounds.left;
            this.start.y = bounds.bottom;
            this.end.x = bounds.right;
            this.end.y = bounds.bottom; // zeroBase 时才需要移到0位置，否则依然为沉底

            if (this.graph.baseY === 0) {
              const yAxis = this.graph.yAxises[1];
              if (!yAxis) return;
              this.value = 0;
              const y = this.start.y + yAxis.min() * yAxis.step();
              this.start.y = this.end.y = y;
            }

            break;
          }

        case 'y':
          {
            const index = this.index || 1;
            let xoffset = bounds.left; //初始化显示标签个数

            this.labelCount = this.style.yLabel.count || 5; //多Y轴时，第二个为右边第一轴，其它的依此递推

            if (index == 2) {
              xoffset = bounds.right;
            } else if (index > 2) {
              xoffset = this.graph.yAxises[index - 1].start.x + this.graph.yAxises[index - 1].width + 10;
            }

            this.start.x = xoffset;
            this.start.y = bounds.bottom;
            this.end.x = this.start.x;
            this.end.y = bounds.top;
            break;
          }
      }

      this.createLabel();
    } // 绘制完成后，生成label标签


    draw() {
      this.points.push(...this.scalePoints); // 把刻度也画出来

      super.draw();
    }
    /**
     * 生成轴标签
     *
     * @method createLabel
     */


    createLabel() {
      //移除原有的标签 
      this.children.each(function (i, c) {
        c.remove();
      }, true);
      this.labels = []; //如果是？X轴则执行X轴标签生成

      if (this.type == 'x') {
        this.createXLabel();
      } else if (this.type == 'y') {
        this.createYLabel();
      }
    }
    /**
     * 生成X轴标签
     *
     * @method createXLabel
     * @private
     */


    createXLabel() {
      //var max = this.max();
      //var min = this.min();
      const step = this.step();
      this.scalePoints = []; // 刻度点集合
      //最多显示标签个数
      //var count = this.style.xLabel.count || this.data.length;	
      //字符串轴。则显示每个标签	

      const format = this.option.format || this.format;
      const top = (this.style.xLabel.margin.top || 0) * this.graph.devicePixelRatio;

      for (let i = 0; i < this.data.length; i++) {
        const d = this.data[i];
        const v = d[this.field]; // 不显示就不生成label。这里性能影响很大

        const text = format.call(this, v, d, i); // 格式化label

        if (!text) continue; /// 只有一条数据，就取这条数据就可以了	

        const w = i * step;
        const label = this.graph.createShape('label', {
          style: this.style.xLabel
        });
        label.data = d; // 当前点的数据结构值

        label.text = text;
        this.labels.push(label);
        this.children.add(label);
        label.width = label.testSize().width + 2;
        label.height = 15;
        const pos = {
          x: this.labelStart + w,
          y: top
        }; // 指定要显示网格

        if (this.style.grid && this.style.grid.y) {
          // 它的坐标是相对于轴的，所以Y轴会用负的区域高度
          const line = this.graph.createShape('line', {
            start: {
              x: pos.x,
              y: 0
            },
            end: {
              x: pos.x,
              y: -this.graph.chartArea.height
            },
            style: this.style.grid
          });
          this.children.add(line);
        } //在轴上画小标记m表示移至当前点开画


        this.scalePoints.push({
          x: pos.x + this.start.x,
          y: this.start.y,
          m: true
        });
        this.scalePoints.push({
          x: pos.x + this.start.x,
          y: this.start.y + (this.style.length || 5)
        }); //如果进行了旋转，则处理位移

        const rotation = label.style.rotation;

        if (rotation && rotation.angle) {
          //设定旋转原点为label左上角					
          rotation.point = pos; //当旋转后，其原点位移至左上角，所有当前控件必须反向移位其父容器位置

          label.position = {
            x: -this.graph.chartArea.position.x,
            y: -this.graph.chartArea.position.y
          };
        } else {
          // 如果标签居中，则把二头的标签左边的左对齐，右边的右对齐
          if (this.style.align === 'center' && this.data.length > 1 && (i === 0 || i === this.data.length - 1)) {
            if (i === this.data.length - 1) {
              pos.x -= label.width;
            }
          } else {
            pos.x -= label.width / 2; //向左偏移半个label宽度
          }

          label.position = pos;
        }
      }
    }
    /**
     * 生成Y轴标签
     *
     * @method createYLabel
     * @private
     */


    createYLabel() {
      const max = this.max();
      const min = this.min();
      const step = this.step();
      const index = this.index || 1;
      this.scalePoints = []; // 刻度点集合

      let count = this.labelCount;
      const mm = max - min;
      /*if(mm <= 10) {
      	count = mm;
      }*/
      // mm 放大10000倍，这里结果也需要除于10000

      let pervalue = mm / count || 1; //if(pervalue > 1 || pervalue < -1) pervalue = Math.floor(pervalue);		

      const format = this.option.format || this.format;
      const marginLeft = this.style.yLabel.margin.left * this.graph.devicePixelRatio || 0;
      const marginRight = this.style.yLabel.margin.right * this.graph.devicePixelRatio || 0;
      let p = 0;

      for (let i = 0; i < count + 1; i++) {
        p = min + pervalue * i;
        if (p > max || i === count) p = max;
        const h = (p - min) * step; // 当前点的偏移高度

        const label = this.graph.graph.createShape('label', {
          style: this.style.yLabel
        });
        label.text = format.call(this, p, label); // 格式化label

        this.labels.push(label);
        this.children.add(label);
        const w = label.testSize().width;
        const offy = this.height - h; // 刻度的偏移量
        // label的位置

        const pos = {
          x: 0,
          y: 0
        }; //轴的宽度

        const axiswidth = marginLeft + marginRight + w;
        this.width = Math.max(axiswidth, this.width); //计算标签位置

        if (index <= 1) {
          pos.x = -w - marginRight;
          pos.y = offy - label.height / 2; //在轴上画小标记m表示移至当前点开画

          this.scalePoints.push({
            x: this.start.x,
            y: offy + this.end.y,
            m: true
          });
          this.scalePoints.push({
            x: this.start.x,
            y: offy + this.end.y
          }); // 指定要显示网格

          if (this.style.grid && this.style.grid.x) {
            // 它的坐标是相对于轴的，所以Y轴会用负的区域高度
            const line = this.graph.createShape('line', {
              start: {
                x: 0,
                y: offy
              },
              end: {
                x: this.graph.chartArea.width,
                y: offy
              },
              style: this.style.grid
            });
            this.children.add(line);
          }
        } else {
          pos.x = marginLeft;
          pos.y = offy - label.height / 2; //在轴上画小标记m表示移至当前点开画

          this.scalePoints.push({
            x: this.start.x,
            y: offy + this.end.y,
            m: true
          });
          this.scalePoints.push({
            x: this.start.x,
            y: offy + this.end.y
          });
        } // label对齐方式


        switch (this.style.yLabel.textAlign) {
          case 'center':
            {
              pos.x = pos.x / 2 - w / 2;
              break;
            }

          case 'right':
            {
              if (index <= 1) pos.x = -axiswidth;else {
                // 轴在最右边时，轴宽减去label宽就是右对齐
                pos.x = axiswidth - w;
              }
              break;
            }
        } //如果进行了旋转，则处理位移


        const rotation = label.style.rotation;

        if (rotation && rotation.angle) {
          label.translate = pos; //先位移再旋转

          label.position = {
            x: -w / 2,
            y: 0
          };
        } else {
          label.position = pos;
        }
      }
    }
    /**
    * 获取当前轴所占宽
    *
    * @method width
    */


    get width() {
      if (this._width) {
        return this._width;
      }

      return Math.abs(this.end.x - this.start.x);
    }

    set width(w) {
      this._width = w;
    }
    /**
    * 获取当前轴所占高
    *
    * @method height
    */


    get height() {
      return Math.abs(this.end.y - this.start.y);
    } // 这里设置高度没意义


    set height(h) {}
    /**
    * 获取或设置当前轴最大值
    *
    * @method max
    * @param {number/date/string} 当前轴的最大值
    * @return 当前轴的最大值
    */


    max(m) {
      if (typeof m !== 'undefined') {
        //如果为0为基线，则最小值不能大于0
        if (this.dataType == 'number' && m < 0 && this.zeroBase) {
          m = 0;
        }

        this._max = this._max != null && typeof this._max != 'undefined' ? Math.max(m, this._max) : m; // 如果有指定默认最大值，则不超过它就采用它

        if (typeof this.maxValue != 'undefined') this._max = Math.max(this.maxValue, this._max);
      } //如果为字符串，则返回分类个数


      if (this.dataType == 'string' && this.data) {
        return this.data.length;
      } //如果是数字类型，则在最大值基础上加一定的值


      if (this.dataType == 'number') {
        m = this._max; // 如果有指定默认最大值，则不超过它就采用它

        if (typeof this.maxValue != 'undefined' && m <= this.maxValue) {
          return this.maxValue;
        }

        if (m <= 0) {
          if (m >= -10) m = 0;else m = -10;
        } else if (m > 500) {
          m = Math.ceil(m / 100);
          m = m * 100 + 100;
        } else if (m > 100) {
          m = Math.ceil(m / 50);
          m = m * 50 + 50;
        } else if (m > 10) {
          m = Math.ceil(m / 10);
          m = m * 10 + 10;
        } else {
          m = Math.ceil(m);
        }

        return m;
      }

      return this._max;
    }
    /**
    * 获取或设置当前轴最小值
    *
    * @method max
    * @param {number/date/string} 当前轴的最小值
    * @return 当前轴的最小值
    */


    min(m) {
      if (typeof m !== 'undefined') {
        //如果为0为基线，则最小值不能大于0
        if (this.dataType == 'number' && m > 0 && this.zeroBase) {
          m = 0;
        }

        this._min = this._min != null && typeof this._min != 'undefined' ? Math.min(m, this._min) : m; // 如果有指定默认最小值，则不小于它就采用它

        if (typeof this.minValue != 'undefined') this._min = Math.min(this.minValue, this._min);
      } //如果是数字类型，则在最小值基础上减去一定的值


      if (this.dataType == 'number') {
        m = this._min; // 如果有指定默认最小值，则不小于它就采用它

        if (typeof this.minValue != 'undefined') {
          return typeof m !== 'undefined' ? Math.min(this.minValue, m) : this.minValue;
        }

        if (m >= 0) {
          if (m <= 10) m = 0;else {
            m = Math.floor(m / 10) * 10 - 10;
          }
        } else if (m < -500) {
          m = Math.floor(m / 100);
          m = m * 100 - 100;
        } else if (m < -100) {
          m = Math.floor(m / 50);
          m = m * 50 - 50;
        } else if (m < -10) {
          m = Math.floor(m / 10);
          m = m * 10 - 10;
        } else {
          m = Math.floor(m);
        }

        return m;
      } //如果为字符串则返回0


      return this.dataType == 'string' ? 0 : this._min;
    }
    /**
     * 清除一些属性
     *
     * @method clear
     */


    clear() {
      this._min = null;
      this._max = null;
    }
    /**
     * 计算当前轴的单位偏移量
     *
     * @method step
     * @return {number} 单位偏移量
     */


    step() {
      if (this.type == 'x') {
        const w = this.width; //如果排版为内联，则单位占宽减少一个单位,
        //也就是起始位从一个单位开始

        if (this.graph.style.layout == 'inside') {
          const sp = w / this.max();
          this.labelStart = sp / 2;
          return sp;
        } else {
          this.labelStart = 0;
        }

        let tmp = this.max() - 1;
        if (tmp === 0) tmp = 2; // 只有一个数据的情况，就直接居中

        return w / tmp;
      } else if (this.type == 'y') {
        const h = this.height;

        switch (this.dataType) {
          case 'string':
            {
              return h / this.max();
            }

          case 'date':
          case 'number':
          default:
            {
              let tmp = Math.abs(this.max() - this.min());
              tmp = tmp || 1;
              return h / tmp;
            }
        }
      }
    } // 格式化标签值


    format(v, item) {
      return v + '';
    }

  }

  /**
   * 图例的容器
   *
   * @class jmLegend
   * @module jmChart
   * @param {jmChart} chart 当前图表
   */
  class jmLegend {
    constructor(chart, options) {
      _defineProperty(this, "legendPosition", '');

      this.chart = chart; //当前图例位置偏移量

      options.position = options.position || {
        x: 0,
        y: 0
      };
    }
    /**
     * 图例放置位置
     */


  }
  /**
   * 添加图例
   *
   * @method append
   * @param {jmSeries} series 当前图序列
   * @param {jmControl} shape 当前图例的图形对象
   */

  jmLegend.prototype.append = function (series, shape, options = {}) {
    // 如果不显示图例，就不处理
    if (this.visible === false) return;
    const panel = this.graph.createShape('rect', {
      style: this.graph.utils.clone(this.style.item),
      position: {
        x: 0,
        y: 0
      }
    });
    this.children.add(panel);
    panel.children.add(shape);
    shape.width = panel.style.shape.width;
    shape.height = panel.style.shape.height;
    let name = options.name || series.legendLabel;
    name = series.option.legendFormat ? series.option.legendFormat.call(series, options) : name;

    if (name) {
      //生成图例名称
      const label = this.graph.createShape('label', {
        style: panel.style.label,
        text: name || ''
      });
      label.height = shape.height;
      label.position = {
        x: shape.width + 4,
        y: 0
      };
      panel.children.add(label);
      panel.width = shape.width + label.testSize().width;
    } else {
      panel.width = shape.width;
    }

    panel.height = shape.height; //执行进入事件
    //触动图例后加粗显示图

    /*const hover = options.hover || function() {	
    	//应用图的动态样式		
    	//Object.assign(series.style, series.style.hover);
    
    	//Object.assign(this.style, this.style.hover || {});
    
    	//series.graph.refresh();
    };
    panel.bind('mouseover', hover);
    //执行离开
    const leave = options.leave || function() {	
    	//应用图的普通样式		
    	//Object.assign(series.style, series.style.normal);
    
    	//Object.assign(this.style, this.style.normal || {});
    	//jmUtils.apply(this.series.style.normal,this.series.style);
    	//series.graph.refresh();
    };
    panel.bind('mouseleave', leave);*/

    const legendPosition = this.legendPosition || this.style.legendPosition || 'right';

    if (legendPosition == 'top' || legendPosition == 'bottom') {
      //顶部和底部图例横排，每次右移位一个单位图例
      panel.position.x = this.width + 15 * this.graph.devicePixelRatio;
      this.width = panel.position.x + panel.width; // 把容器宽指定为所有图例宽和

      this.height = Math.max(panel.height, this.height);
    } else {
      //右边和左边图例竖排
      panel.position.y += this.height + 5 * this.graph.devicePixelRatio;
      this.height = panel.position.y + panel.height;
      this.width = Math.max(panel.width, this.width);
    }

    this.needUpdate = true;
  };
  /**
   * 初始化图例
   *
   * @method init
   */


  jmLegend.prototype.init = function () {
    this.position.x = 0;
    this.position.y = 0;
    this.width = 0;
    this.height = 0;
    this.style.lineWidth = 0;
    this.children.clear();
  };
  /**
   * 重置图例属性,根据图例内容计算期大小并更新画图区域大小
   *
   * @method reset
   */


  jmLegend.prototype.reset = function () {
    if (this.visible !== false) {
      this.position.x = this.graph.chartArea.position.x;
      this.position.y = this.graph.chartArea.position.y;
      var legendPosition = this.legendPosition || this.style.legendPosition;

      switch (legendPosition) {
        case 'left':
          {
            this.graph.chartArea.width = this.graph.chartArea.width - this.width; //画图区域向右偏移

            this.graph.chartArea.position.x = this.position.x + this.width + this.style.margin.right * this.graph.devicePixelRatio;
            break;
          }

        case 'top':
          {
            this.graph.chartArea.height = this.graph.chartArea.height - this.height;
            this.graph.chartArea.position.y = this.position.y + this.height + this.style.margin.bottom * this.graph.devicePixelRatio;
            break;
          }

        case 'bottom':
          {
            this.graph.chartArea.height = this.graph.chartArea.height - this.height;
            this.position.y = this.graph.chartArea.position.y + this.graph.chartArea.height + this.style.margin.top * this.graph.devicePixelRatio;
            break;
          }

        case 'right':
        default:
          {
            this.graph.chartArea.width = this.graph.chartArea.width - this.width;
            this.position.x = this.graph.chartArea.position.x + this.graph.chartArea.width + this.style.margin.left * this.graph.devicePixelRatio;
            break;
          }
      }
    }
  };

  var utils = {
    /**
     * 对比二个数组数据是否改变
     * @param {Array} source 被对比的数、组
     * @param {Array} target 对比数组
     * @param {Function} compare 比较函数
     */
    arrayIsChange(source, target, compare) {
      if (!source || !target) return true;
      if (source.length !== target.length) return true;

      if (typeof compare === 'function') {
        for (let i = 0; i < source.length; i++) {
          if (!compare(source[i], target[i])) return true;
        }

        return false;
      } else return source == target;
    }

  };

  /**
   * 图形基类
   *
   * @class jmSeries
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {array} mappings 图形字段映射
   * @param {style} style 样式
   */
  //构造线图

  class jmSeries {
    constructor(chart, options) {
      _defineProperty(this, "legendLabel", '');

      _defineProperty(this, "shapes", new jmList());

      _defineProperty(this, "keyPoints", []);

      _defineProperty(this, "labels", []);

      _defineProperty(this, "field", '');

      _defineProperty(this, "baseYHeight", 0);

      _defineProperty(this, "baseY", 0);

      _defineProperty(this, "baseYValue", 0);

      this.chart = chart;
      this.option = options;
      this.field = options.field || options.fields || '';
      this.index = options.index || 1;
      this.legendLabel = options.legendLabel || '';
      this.___animateCounter = 0; // 动画计数		

      this.xAxis = this.chart.createXAxis(); // 生成X轴
      // 生成当前Y轴

      this.yAxis = this.yAxis || this.chart.createYAxis({
        index: this.index,
        format: options.yLabelFormat || this.graph.option.yLabelFormat
      }); // 初始化一些参数， 因为这里有多个Y轴的可能，所以每次都需要重调一次init

      this.yAxis.init({
        field: this.field,
        minYValue: options.minYValue,
        maxYValue: options.maxYValue
      });
    }
    /**
     * 关联访问的是chart的数据源
     */


    get data() {
      return this.graph.data;
    }

    set data(d) {
      this.graph.data = d;
    } //是否启用动画效果


    get enableAnimate() {
      if (typeof this.option.enableAnimate !== 'undefined') return !!this.option.enableAnimate;else {
        return this.graph.enableAnimate;
      }
    }

    set enableAnimate(v) {
      this.option.enableAnimate = v;
    }
    /**
     * 图例名称
     *
     * @property legendLabel
     * @type string
     */


    // 做一些基础初始化工作
    initDataPoint(...args) {
      //生成描点位
      // 如果有动画，则需要判断是否改变，不然不需要重新动画
      let dataChanged = false;

      if (this.enableAnimate) {
        // 拷贝一份上次的点集合，用于判断数据是否改变
        this.lastPoints = this.graph.utils.clone(this.dataPoints, null, true, obj => {
          if (obj instanceof jmControl) return obj;
        }); // 重新生成描点

        this.dataPoints = this.createPoints(...args);
        dataChanged = utils.arrayIsChange(this.lastPoints, this.dataPoints, (s, t) => {
          return s.x === t.x && s.y === t.y;
        });
        if (dataChanged) this.___animateCounter = 0; // 数据改变。动画重新开始
      } else {
        this.dataPoints = this.createPoints(...args);
      }

      return {
        dataChanged,
        points: this.dataPoints
      };
    }
    /**
     * 根据X轴坐标，获取它最近的数据描点
     * 离点最近的一个描点
     * @param {number} x  X轴坐标
     */


    getDataPointByX(x) {
      if (!this.dataPoints) return null; // 获取最近的那个

      let prePoint = undefined;
   // 跟上一个点和下一个点的距离，哪个近用哪个

      for (let i = 0; i < this.dataPoints.length; i++) {
        const p = this.dataPoints[i];
        if (p.x == x) return p; // 上一个点

        if (p.x < x) {
          if (i === this.dataPoints.length - 1) return p;
          prePoint = p;
        } // 下一个点


        if (p.x > x) {
          // 没有上一个，只能返回这个了
          if (prePoint && x - prePoint.x < p.x - x) return prePoint;else return p;
        }
      }

      return null;
    }
    /**
     * 根据X轴值获取数据点
     * @param {number} xValue  X轴值
     */


    getDataPointByXValue(xValue) {
      if (!this.dataPoints) return null;

      for (let i = 0; i < this.dataPoints.length; i++) {
        const p = this.dataPoints[i];
        if (p.xValue == xValue) return p;
      }

      return null;
    }
    /**
     * 重置属性
     * 根据数据源计算轴的属性
     *
     * @method reset
     */


    reset() {
      // 重置所有图形
      var shape;

      while (shape = this.shapes.shift()) {
        shape && shape.remove();
      } //生成图例  这里要放到shape清理后面


      this.createLegend();
      this.initAxisValue(); // 处理最大值最小值

      return this.chartInfo = {
        xAxis: this.xAxis,
        yAxis: this.yAxis
      };
    } // 计算最大值和最小值，一般图形直接采用最大最小值即可，有些需要多值叠加


    initAxisValue() {
      // 计算最大最小值
      // 当前需要先更新axis的边界值，轴好画图
      for (var i = 0; i < this.data.length; i++) {
        if (Array.isArray(this.field)) {
          this.field.forEach(f => {
            const v = this.data[i][f];
            this.yAxis.max(v);
            this.yAxis.min(v);
          });
        } else {
          const v = this.data[i][this.field];
          this.yAxis.max(v);
          this.yAxis.min(v);
        }

        const xv = this.data[i][this.xAxis.field];
        this.xAxis.max(xv);
        this.xAxis.min(xv);
      }
    }
    /**
     * 生成序列图描点
     *
     * @method createPoints
     */


    createPoints(data) {
      data = data || this.data;
      if (!data) return;
      const xstep = this.xAxis.step();
      const minY = this.yAxis.min();
      const ystep = this.yAxis.step();
      this.baseYValue = typeof this.graph.baseY === 'undefined' ? minY : this.graph.baseY || 0;
      this.baseYHeight = (this.baseYValue - minY) * ystep; // 基线的高度		

      this.baseY = this.graph.chartArea.height - this.baseYHeight; // Y轴基线的Y坐标
      // 有些图形是有多属性值的

      const fields = Array.isArray(this.field) ? this.field : [this.field];
      this.dataPoints = [];

      for (let i = 0; i < data.length; i++) {
        const s = data[i];
        const xv = s[this.xAxis.field];
        const p = {
          data: s,
          index: i,
          xValue: xv,
          xLabel: xv,
          points: [],
          style: this.graph.utils.clone(this.style)
        }; // 这里的点应相对于chartArea

        p.x = xstep * i + this.xAxis.labelStart;

        for (const f of fields) {
          const yv = s[f];
          p.yLabel = p.yValue = yv; // 高度

          p.height = (yv - this.baseYValue) * ystep;
          const point = {
            x: p.x,
            // 高度
            height: p.height,
            yValue: yv,
            field: f
          }; //如果Y值不存在。则此点无效，不画图

          if (yv == null || typeof yv == 'undefined') {
            point.m = p.m = true;
          } else {
            if (this.yAxis.dataType != 'number') {
              yv = i;
            }

            point.y = p.y = this.baseY - point.height;
          }

          p.points.push(point);
        } // 初始化项


        if (typeof this.option.initItemHandler === 'function') {
          this.option.initItem.call(this, p);
        }

        this.dataPoints.push(p);
      }

      return this.dataPoints;
    } // 生成颜色


    getColor(p) {
      if (typeof this.style.color === 'function') {
        return this.style.color.call(this, p);
      } else {
        return this.style.color;
      }
    }
    /**
     * 生成图例
     *
     * @method createLegend
     */


    createLegend() {
      //生成图例前的图标
      const style = this.graph.utils.clone(this.style);
      style.fill = this.getColor(); //delete style.stroke;

      const shape = this.graph.createShape('rect', {
        style
      });
      this.graph.legend.append(this, shape);
    } // 生成柱图的标注


    createItemLabel(point, position) {
      if (!this.style.label || this.style.label.show !== true) return;
      const text = this.option.itemLabelFormat ? this.option.itemLabelFormat.call(this, point) : point.yValue;
      if (!text) return; // v如果指定了为控件，则直接加入

      if (text instanceof jmControl) {
        this.addShape(text);
        return text;
      }

      const style = this.graph.utils.clone(this.graph.style.itemLabel, {
        zIndex: 21,
        ...this.style.label
      });

      if (typeof style.fill === 'function') {
        style.fill = style.fill.call(this, point);
      }

      const barWidth = (this.barTotalWidth || 0) / 2 - (this.barWidth || 0) * (this.barIndex || 0) - (this.barWidth || 0) / 2;
      const baseOffset = point.y - this.baseY;
      const label = this.graph.createShape('label', {
        style,
        text: text,
        data: point,
        position: function () {
          const offh = style.offset || 5;
          const size = this.testSize();
          return {
            x: point.x - size.width / 2 - barWidth,
            y: baseOffset > 0 ? point.y + offh : point.y - size.height - offh
          };
        }
      });
      this.addShape(label);
    }
    /**
     * 在图上加下定制图形
     * @param {jmShape} shape  图形
     */


    addShape(shape) {
      this.graph.chartArea.children.add(shape);
      this.shapes.add(shape);
      return shape;
    }
    /**
     * 获取指定事件的集合
     * 比如mousedown,mouseup等
     *
     * @method getEvent
     * @param {string} name 事件名称
     * @return {list} 事件委托的集合
     */


    getEvent(name) {
      const event = this.option ? this.option[name] : null;

      if (!event) {
        return super.getEvent(name);
      } else {
        const events = new jmList();
        events.add(event);
        const oldevents = super.getEvent(name);

        if (oldevents) {
          events.concat(oldevents);
        }

        return events;
      }
    }

  }

  /**
   * 柱图
   *
   * @class jmBarSeries
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {array} mappings 图形字段映射
   * @param {style} style 样式
   */
  //构造函数

  class jmBarSeries extends jmSeries {
    constructor(chart, options) {
      super(chart, options);
    }
    /**
     * 绘制当前图形
     *
     * @method beginDraw
     * @for jmBarSeries
     */


    init() {
      //生成描点位
      const {
        points,
        dataChanged
      } = this.initDataPoint();
      const len = points.length;
      this.initWidth(len); // 是否正在动画中
      // 如果数据点多于100 个，暂时不启用动画，太慢了

      const isRunningAni = this.enableAnimate && (dataChanged || this.___animateCounter > 0) && len < 100;
      let aniIsEnd = true; // 当次是否结束动画

      const aniCount = this.style.aniCount || 10;

      for (let i = 0; i < len; i++) {
        //const label = this.xAxis.labels[i];
        const point = points[i]; //如果当前点无效，则跳致下一点

        if (typeof point.y === 'undefined' || point.y === null) {
          continue;
        }

        point.style.fill = this.getColor(point);
        const sp = this.addShape(this.graph.createPath(null, point.style)); //绑定提示框
        //this.bindTooltip(sp, point);
        //首先确定p1和p4,因为他们是底脚。会固定

        const p1 = {
          x: point.x - this.barTotalWidth / 2 + this.barWidth * this.barIndex,
          y: this.baseY
        };
        const p4 = {
          x: p1.x + this.barWidth,
          y: p1.y
        };
        const p2 = {
          x: p1.x,
          y: p1.y
        };
        const p3 = {
          x: p4.x,
          y: p1.y
        }; // 如果要动画。则动态改变高度

        if (isRunningAni) {
          const step = point.height / aniCount;
          const offHeight = step * this.___animateCounter; // 动态计算当前高度

          p2.y = p1.y - offHeight; // 计算高度
          // 当次动画完成

          if (step >= 0 && p2.y <= point.y || step < 0 && p2.y >= point.y) {
            p2.y = point.y;
          } else {
            aniIsEnd = false; // 只要有一个没完成，就还没有完成动画
          }

          p3.y = p2.y;
        } else {
          p2.y = point.y;
          p3.y = point.y;
        }

        sp.points.push(p1);
        sp.points.push(p2);
        sp.points.push(p3);
        sp.points.push(p4);
        this.createItemLabel(point); // 生成标点的回调

        this.emit('onPointCreated', point);
      }

      if (aniIsEnd) {
        this.___animateCounter = 0;
      } else {
        this.___animateCounter++; // next tick 再次刷新

        setTimeout(() => {
          this.needUpdate = true; //需要刷新
        });
      }
    } // 计算柱子宽度


    initWidth(count) {
      //计算每个柱子占宽
      //每项柱子占宽除以柱子个数,默认最大宽度为30
      const maxWidth = this.xAxis.width / count / this.graph.barSeriesCount;

      if (this.style.barWidth > 0) {
        this.barWidth = Number(this.style.barWidth);
        this.barTotalWidth = this.barWidth * this.graph.barSeriesCount;
      } else {
        this.barTotalWidth = this.xAxis.width / count * (this.style.perWidth || 0.4);
        this.barWidth = this.barTotalWidth / this.graph.barSeriesCount;
      }

      if (this.barWidth > maxWidth) {
        this.barWidth = maxWidth;
        this.barTotalWidth = maxWidth * this.graph.barSeriesCount;
      }
    }
    /**
     * 在图上加下定制图形
     * @param {jmShape} shape  图形
     */


    addShape(shape) {
      this.children.add(shape);
      this.shapes.add(shape);
      return shape;
    }

  }

  /**
   * 柱图
   *
   * @class jmBarSeries
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {array} mappings 图形字段映射
   * @param {style} style 样式
   */
  //构造函数

  class jmStackBarSeries extends jmBarSeries {
    constructor(chart, options) {
      super(chart, options);
    }
    /**
     * 绘制当前图形
     *
     * @method beginDraw
     * @for jmBarSeries
     */


    init() {
      //生成描点位
      const {
        points,
        dataChanged
      } = this.initDataPoint();
      const len = points.length;
      this.initWidth(len); // 是否正在动画中
      // 如果数据点多于100 个，暂时不启用动画，太慢了

      const isRunningAni = this.enableAnimate && (dataChanged || this.___animateCounter > 0) && len < 100;
      let aniIsEnd = true; // 当次是否结束动画

      const aniCount = this.style.aniCount || 10;

      for (let i = 0; i < len; i++) {
        const point = points[i];
        let topStartY = this.baseY;
        let bottomStartY = this.baseY;

        for (let index = 0; index < point.points.length; index++) {
          const style = this.graph.utils.clone(this.style);

          if (style.color && typeof style.color === 'function') {
            style.fill = style.color.call(this, this, index);
          } else {
            style.fill = this.graph.getColor(index);
          }

          const sp = this.addShape(this.graph.createPath(null, style));
          const p = point.points[index];
          let startY = topStartY;
          if (p.yValue < this.baseYValue) startY = bottomStartY; //首先确定p1和p4,因为他们是底脚。会固定

          const p1 = {
            x: p.x - this.barTotalWidth / 2,
            y: startY
          };
          const p4 = {
            x: p1.x + this.barWidth,
            y: p1.y
          };
          const p2 = {
            x: p1.x,
            y: p1.y
          };
          const p3 = {
            x: p4.x,
            y: p1.y
          }; // 如果要动画。则动态改变高度

          if (isRunningAni) {
            const step = p.height / aniCount;
            const offHeight = step * this.___animateCounter; // 动态计算当前高度

            p2.y = startY - offHeight; // 计算高度
            // 当次动画完成

            if (step >= 0 && offHeight >= p.height || step < 0 && offHeight <= p.height) {
              p2.y = startY - p.height;
            } else {
              aniIsEnd = false; // 只要有一个没完成，就还没有完成动画
            }

            p.y = p3.y = p2.y;
          } else {
            p2.y = startY - p.height;
            p.y = p3.y = p2.y;
          }

          if (p.yValue < this.baseYValue) bottomStartY = p2.y; // 下一个又从它顶部开始画
          else topStartY = p2.y;
          sp.points.push(p1);
          sp.points.push(p2);
          sp.points.push(p3);
          sp.points.push(p4);
        } // 生成标点的回调


        this.emit('onPointCreated', point);
      }

      if (aniIsEnd) {
        this.___animateCounter = 0;
      } else {
        this.___animateCounter++; // next tick 再次刷新

        setTimeout(() => {
          this.needUpdate = true; //需要刷新
        });
      }
    } // 计算最大值和最小值，一般图形直接采用最大最小值即可，有些需要多值叠加


    initAxisValue() {
      // 计算最大最小值
      // 当前需要先更新axis的边界值，轴好画图
      const fields = Array.isArray(this.field) ? this.field : [this.field];

      for (const row of this.data) {
        let max, min;

        for (const f of fields) {
          const v = Number(row[f]);
          if (typeof max === 'undefined') max = v;else {
            if (v < 0 || max < 0) max = Math.max(max, v);else {
              max += v;
            }
          }
          if (typeof min === 'undefined') min = v;else {
            if (v >= 0 || min >= 0) min = Math.min(min, v);else {
              min += v;
            }
          }
        }

        this.yAxis.max(max);
        this.yAxis.min(min);
        const xv = row[this.xAxis.field];
        this.xAxis.max(xv);
        this.xAxis.min(xv);
      }
    }

  }

  /**
   * 饼图
   *
   * @class jmPieSeries
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {array} mappings 图形字段映射
   * @param {style} style 样式
   */
  //构造函数

  class jmPieSeries extends jmSeries {
    constructor(chart, options) {
      super(chart, options);
      this.xAxis.visible = false;
      this.yAxis.visible = false;
    } // 重新初始化图形


    init() {
      //总和
      this.totalValue = 0; //计算最大值和最小值

      if (this.data) {
        for (const i in this.data) {
          const s = this.data[i];
          const vy = s[this.field];

          if (vy) {
            this.totalValue += Math.abs(vy);
          }
        }
      }

      const center = {
        x: this.graph.chartArea.width / 2,
        y: this.graph.chartArea.height / 2
      };
      const radius = Math.min(center.x - this.style.margin.left - this.style.margin.right * this.graph.devicePixelRatio, center.y - this.style.margin.top * this.graph.devicePixelRatio - this.style.margin.bottom * this.graph.devicePixelRatio); //生成描点位
      // super.init会把参数透传给 createPoints

      const {
        points,
        dataChanged
      } = this.initDataPoint(center, radius); // 是否正在动画中

      const isRunningAni = this.enableAnimate && (dataChanged || this.___animateCounter > 0); // 在动画中，则一直刷新

      if (isRunningAni) {
        const aniCount = this.style.aniCount || 20;
        let aniIsEnd = true; // 当次是否结束动画

        const len = points.length;

        for (let i = 0; i < len; i++) {
          const p = points[i];
          const step = (p.y - p.shape.startAngle) / aniCount;
          p.shape.endAngle = p.shape.startAngle + this.___animateCounter * step;

          if (p.shape.endAngle >= p.y) {
            p.shape.endAngle = p.y;
          } else {
            aniIsEnd = false;
          } // p.shape.points = arc.initPoints();
          // p.shape.points.push(center);			
          //绑定提示框
          //this.bindTooltip(p.shape, p);

        } // 所有动画都完成，则清空计数器


        if (aniIsEnd) {
          this.___animateCounter = 0;
        } else {
          this.___animateCounter++; // next tick 再次刷新

          setTimeout(() => {
            this.needUpdate = true; //需要刷新
          });
        }
      }
    } // 当前总起画角度


    get startAngle() {
      return this.option.startAngle || 0;
    }

    set startAngle(v) {
      this.option.startAngle = v;
    }
    /**
     * 生成序列图描点
     *
     * @method createPoints
     */


    createPoints(center, radius) {
      if (!this.data) return [];
      const points = [];
      let index = 0;
      let startAni = this.startAngle; // 总起始角度

      if (typeof startAni === 'function') {
        startAni = startAni.call(this, this.data);
      }

      let cm = Math.PI * 2; //规定应该逆时针还是顺时针绘图 false  顺时针，true 逆时针

      const anticlockwise = this.option.anticlockwise || false; // 每项之间的间隔角度  顺时钟为正，否则为负

      const marginAngle = Number(this.style.marginAngle) || 0;

      for (var i = 0; i < this.data.length; i++) {
        const s = this.data[i];
        const yv = s[this.field]; //如果Y值不存在。则此点无效，不画图

        if (yv == null || typeof yv == 'undefined') {
          continue;
        } else {
          const p = {
            data: s,
            x: i,
            yValue: yv,
            yLabel: yv,
            step: Math.abs(yv / this.totalValue),
            // 每个数值点比
            style: this.graph.utils.clone(this.style),
            anticlockwise
          }; //p.style.color = this.graph.getColor(index);

          if (p.style.color && typeof p.style.color === 'function') {
            p.style.fill = p.style.color.call(this, p);
          } else {
            p.style.fill = this.graph.getColor(index);
          }

          const start = startAni; // 上一个扇形的结束角度为当前的起始角度
          // 计算当前结束角度, 同时也是下一个的起始角度

          p.y = startAni + p.step * cm;
          startAni = p.y;
          p.startAngle = start + marginAngle;
          p.endAngle = p.y;

          if (center && radius) {
            const arcWidth = this.style.arcWidth || radius * 0.2;
            p.radius = radius; // 如果有指定动态半径，则调用

            if (typeof this.option.radius === 'function') {
              p.radius = this.option.radius.call(this, p, radius, i);
            }

            p.maxRadius = p.radius; // 如果有指定动态半径，则调用

            if (typeof this.option.maxRadius === 'function') {
              p.maxRadius = this.option.maxRadius.call(this, p, p.maxRadius, i);
            }

            p.minRadius = p.radius - arcWidth; // 如果有指定动态半径，则调用

            if (typeof this.option.minRadius === 'function') {
              p.minRadius = this.option.minRadius.call(this, p, p.minRadius, i);
            }

            p.center = center; // 如果有指定动态半径，则调用

            if (typeof this.option.center === 'function') {
              p.center = this.option.center.call(this, p, p.center, i);
            }

            p.shape = this.graph.createShape(this.style.isHollow ? 'harc' : 'arc', {
              style: p.style,
              startAngle: p.startAngle,
              endAngle: p.endAngle,
              anticlockwise: anticlockwise,
              isFan: true,
              // 表示画扇形
              center: p.center,
              radius: p.radius,
              maxRadius: p.maxRadius,
              minRadius: p.minRadius
            });
            /**
             * 因为jmgraph是按图形形状来计算所占区域和大小的， 这里我们把扇形占区域改为整个图圆。这样计算大小和渐变时才好闭合。
             */

            p.shape.getLocation = function () {
              const local = this.location = {
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                center: this.center,
                radius: p.radius
              };
              local.left = this.center.x - p.radius;
              local.top = this.center.y - p.radius;
              local.width = local.height = p.radius * 2;
              return local;
            };

            p.shape.getBounds = function () {
              return this.getLocation();
            };

            this.addShape(p.shape); // 如果有点击事件

            if (this.option.onClick) {
              p.shape.on('click', e => {
                this.option.onClick.call(this, p, e);
              });
            }

            if (this.option.onOver) {
              p.shape.on('mouseover touchover', e => {
                this.option.onOver.call(this, p, e);
              });
            }

            if (this.option.onLeave) {
              p.shape.on('mouseleave touchleave', e => {
                this.option.onLeave.call(this, p, e);
              });
            }

            this.createLabel(p); // 生成标签
          }

          points.push(p);
          index++; // 生成标点的回调

          this.emit('onPointCreated', p);
        }
      }

      return points;
    } // 生成柱图的标注


    createLabel(point) {
      if (this.style.label && this.style.label.show === false) return;
      const text = this.option.itemLabelFormat ? this.option.itemLabelFormat.call(this, point) : point.step;
      if (!text) return; // v如果指定了为控件，则直接加入

      if (text instanceof jmControl) {
        point.shape.children.add(text);
        return text;
      }

      const self = this;
      const label = this.graph.createShape('label', {
        style: this.style.label,
        text: text,
        position: function () {
          if (!this.parent || !this.parent.points || !this.parent.points.length) return {
            x: 0,
            y: 0
          }; // 动态计算位置

          const parentRect = this.parent.getBounds(); //const rect = this.getBounds.call(this.parent);
          // 圆弧的中间位，离圆心最近和最完的二个点

          let centerMaxPoint = this.parent.points[Math.floor(this.parent.points.length / 2)];
          let centerMinPoint = this.parent.center; // 如果是空心圆，则要计算 1/4 和 3/4位的点。顺时针和逆时针二个点大小不一样，这里只取，大小计算时处理

          if (self.style.isHollow) {
            centerMaxPoint = this.parent.points[Math.floor(this.parent.points.length * 0.25)];
            centerMinPoint = this.parent.points[Math.floor(this.parent.points.length * 0.75)];
          }

          const centerMinX = Math.min(centerMaxPoint.x, centerMinPoint.x);
          const centerMaxX = Math.max(centerMaxPoint.x, centerMinPoint.x);
          const centerMinY = Math.min(centerMaxPoint.y, centerMinPoint.y);
          const centerMaxY = Math.max(centerMaxPoint.y, centerMinPoint.y); // 中心点

          const center = {
            x: (centerMaxX - centerMinX) / 2 + centerMinX,
            y: (centerMaxY - centerMinY) / 2 + centerMinY
          };
          const size = this.testSize(); // 取图形中间的二个点
          // rect是相对于图形坐标点形图的图形的左上角，而parentRect是图形重新指定的整圆区域。减去整圆区域左上角就是相对于整圆区域坐标

          return {
            x: center.x - parentRect.left - size.width / 2,
            y: center.y - parentRect.top - size.height / 2
          };
        }
      });
      point.shape.children.add(label);
    }

  }
  /**
   * 生成图例
   *
   * @method createLegend	 
   */

  jmPieSeries.prototype.createLegend = function () {
    const points = this.createPoints();
    if (!points || !points.length) return;

    for (let k in points) {
      const p = points[k];
      if (!p) continue; //生成图例前的图标

      const style = this.graph.utils.clone(p.style);
      style.fill = style.fill; //delete style.stroke;

      const shape = this.graph.createShape('rect', {
        style: style,
        position: {
          x: 0,
          y: 0
        }
      }); //shape.targetShape = p.shape;
      //此处重写图例事件

      this.graph.legend.append(this, shape, {
        name: this.legendLabel,
        hover: function () {
          //var sp = this.children.get(0);
          //应用图的动态样式
          Object.assign(this.targetShape.style, this.targetShape.style.hover);
          Object.assign(this.style, this.style.hover);
        },
        leave: function () {
          //var sp = this.children.get(0);
          //应用图的普通样式
          Object.assign(this.targetShape.style, this.targetShape.style.normal);
          Object.assign(this.style, this.style.normal);
        },
        data: this.data[k]
      });
    }
  };

  /**
   * 图形基类
   *
   * @class jmLineSeries
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {array} mappings 图形字段映射
   * @param {style} style 样式
   */
  //构造函数

  class jmLineSeries extends jmSeries {
    constructor(chart, options) {
      options.style = options.style || options.graph.style.line;
      super(chart, options); //this.on('beginDraw', this[PreDrawKey]);
    }
    /**
     * 绘制图形前 初始化线条
     *
     * @method preDraw
     * @for jmLineSeries
     */


    init() {
      //生成描点位
      const {
        points,
        dataChanged
      } = this.initDataPoint(); //去除多余的线条
      //当数据源线条数比现有的少时，删除多余的线条

      const len = points.length; //设定其填充颜色
      //if(!this.style.fill) this.style.fill = jmUtils.toColor(this.style.stroke,null,null,20);	

      this.style.stroke = this.style.color; //是否启用动画效果
      //var ani = typeof this.enableAnimate === 'undefined'? this.graph.enableAnimate: this.enableAnimate;

      this.style.item.stroke = this.style.color; // 是否正在动画中
      // 如果数据点多于100 个，暂时不启用动画，太慢了

      const isRunningAni = this.enableAnimate && (dataChanged || this.___animateCounter > 0);
      let shapePoints = []; // 计算出来的曲线点集合	

      const aniCount = this.style.aniCount || 10;
      const aniStep = Math.floor(len / aniCount) || 1; // 每次动画播放点个数

      for (let i = 0; i < len; i++) {
        const p = points[i]; //如果当前点无效，则跳致下一点

        if (typeof p.y === 'undefined' || p.y === null) {
          //prePoint = null;						
          continue;
        }

        if (isRunningAni) {
          if (i > this.___animateCounter) {
            break;
          }
        } // 是否显示数值点圆


        if (this.style.showItem) {
          this.createPointItem(p);
        } // 平滑曲线


        if (this.style.curve) {
          shapePoints = this.createCurePoints(shapePoints, p);
        } // 如果是虚线
        else if (this.style.lineType === 'dotted') {
          shapePoints = this.createDotLine(shapePoints, p);
        }

        shapePoints.push(p);
        this.createItemLabel(p); // 生成关健值标注

        this.emit('onPointCreated', p);
      } // 如果所有都已经结束，则重置成初始化状态


      if (this.___animateCounter >= len - 1) {
        this.___animateCounter = 0;
      } else if (isRunningAni) {
        this.___animateCounter += aniStep; // next tick 再次刷新

        setTimeout(() => {
          this.needUpdate = true; //需要刷新
        });
      }

      this.points = shapePoints;
      this.createArea(shapePoints); // 仓建区域效果
    } // 生成点的小圆圈


    createPointItem(p) {
      const pointShape = this.graph.createShape('circle', {
        style: this.style.item,
        center: p,
        radius: this.style.radius || 3
      });
      pointShape.zIndex = (pointShape.style.zIndex || 1) + 1;
      return this.addShape(pointShape);
    } // 根据上下点生成平滑曲线


    createCurePoints(shapePoints, p) {
      const startPoint = shapePoints[shapePoints.length - 1];

      if (startPoint && startPoint.y != undefined && startPoint.y != null) {
        //如果需要画曲线，则计算贝塞尔曲线坐标				
        const p1 = {
          x: startPoint.x + (p.x - startPoint.x) / 5,
          y: startPoint.y
        };
        const p2 = {
          x: startPoint.x + (p.x - startPoint.x) / 2,
          y: p.y - (p.y - startPoint.y) / 2
        };
        const p3 = {
          x: p.x - (p.x - startPoint.x) / 5,
          y: p.y
        }; //圆滑线条使用的贝塞尔对象

        this.__bezier = this.__bezier || this.graph.createShape('bezier');
        this.__bezier.cpoints = [startPoint, p1, p2, p3, p]; //设置控制点

        const bzpoints = this.__bezier.initPoints();

        shapePoints = shapePoints.concat(bzpoints);
      }

      return shapePoints;
    } // 生成虚线


    createDotLine(shapePoints, p) {
      const startPoint = shapePoints[shapePoints.length - 1];

      if (startPoint && startPoint.y != undefined && startPoint.y != null) {
        //使用线条来画虚线效果
        this.__line = this.__line || this.graph.createShape('line', {
          style: this.style
        });
        this.__line.start = startPoint;
        this.__line.end = p;

        const dots = this.__line.initPoints();

        shapePoints = shapePoints.concat(dots);
      }

      return shapePoints;
    }
    /**
     * 生成图例
     *
     * @method createLegend	 
     */


    createLegend() {
      //生成图例前的图标
      var style = this.graph.utils.clone(this.style);
      style.stroke = style.color;
      var shape = this.graph.createShape('path', {
        style: style
      });

      if (this.curve || this.style.curve) {
        var p1 = {
          x: 0,
          y: this.graph.style.legend.item.shape.height
        };
        var p2 = {
          x: this.graph.style.legend.item.shape.width / 3,
          y: this.graph.style.legend.item.shape.height / 3
        };
        var p3 = {
          x: this.graph.style.legend.item.shape.width / 3 * 2,
          y: this.graph.style.legend.item.shape.height / 3 * 2
        };
        var p4 = {
          x: this.graph.style.legend.item.shape.width,
          y: 0
        };
        this.__bezier = this.__bezier || this.graph.createShape('bezier');
        this.__bezier.cpoints = [p1, p2, p3, p4]; //设置控制点		

        shape.points = this.__bezier.initPoints();
      } else {
        shape.points = [{
          x: 0,
          y: this.graph.style.legend.item.shape.height / 2
        }, {
          x: this.graph.style.legend.item.shape.width,
          y: this.graph.style.legend.item.shape.height / 2
        }];
      }

      this.graph.legend.append(this, shape);
    } // 生成布效果


    createArea(points, needClosePoint = true) {
      // 有指定绘制区域效果才展示
      if (!this.style.area || points.length < 2) return;
      const start = points[0];
      const end = points[points.length - 1];
      const style = this.graph.utils.clone(this.style.area, {}, true); // 连框颜色如果没指定，就透明

      style.stroke = style.stroke || 'transparent';

      if (!style.fill) {
        const color = this.graph.utils.hexToRGBA(this.style.stroke);
        style.fill = `linear-gradient(50% 0 50% 100%, 
				rgba(${color.r},${color.g},${color.b}, 0) 1,
				rgba(${color.r},${color.g},${color.b}, 0.1) 0.7, 
				rgba(${color.r},${color.g},${color.b}, 0.3) 0)`;
      } else if (typeof style.fill === 'function') {
        style.fill = style.fill.call(this, style);
      }

      const area = this.graph.createShape('path', {
        points: this.graph.utils.clone(points, true),
        style,
        width: this.graph.chartArea.width,
        height: this.graph.chartArea.height
      }); // 在点集合前后加上落地到X轴的点就可以组成一个封闭的图形area

      if (needClosePoint) {
        area.points.unshift({
          x: start.x,
          y: this.baseY
        });
        area.points.push({
          x: end.x,
          y: this.baseY
        });
      }

      this.addShape(area);
    }

  }

  /**
   * 二条线组成的区域图表
   *
   * @class jmStackLineSeries
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {array} mappings 图形字段映射
   * @param {style} style 样式
   */
  //构造函数

  class jmStackLineSeries extends jmLineSeries {
    constructor(chart, options) {
      options.style = options.style || options.graph.style.stackLine;
      super(chart, options);
    }
    /**
     * 绘制图形前 初始化线条
     *
     * @method preDraw
     * @for jmLineSeries
     */


    init() {
      //生成描点位
      const {
        points,
        dataChanged
      } = this.initDataPoint(); //去除多余的线条
      //当数据源线条数比现有的少时，删除多余的线条

      const len = points.length; //设定其填充颜色
      //if(!this.style.fill) this.style.fill = jmUtils.toColor(this.style.stroke,null,null,20);	

      this.style.stroke = this.style.color; //是否启用动画效果
      //var ani = typeof this.enableAnimate === 'undefined'? this.graph.enableAnimate: this.enableAnimate;

      this.style.item.stroke = this.style.color; // 是否正在动画中
      // 如果数据点多于100 个，暂时不启用动画，太慢了

      const isRunningAni = this.enableAnimate && (dataChanged || this.___animateCounter > 0);
      let startShapePoints = []; // 计算出来的曲线点集合	

      let endShapePoints = []; // 计算出来的曲线点集合

      const aniCount = this.style.aniCount || 10;
      const aniStep = Math.floor(len / aniCount) || 1; // 每次动画播放点个数

      for (let i = 0; i < len; i++) {
        const p = points[i];

        if (isRunningAni) {
          if (i > this.___animateCounter) {
            break;
          }
        } // 是否显示数值点圆


        if (this.style.showItem) {
          this.createPointItem(p.points[0]);
          this.createPointItem(p.points[1]);
        } // 平滑曲线


        if (this.style.curve) {
          startShapePoints = this.createCurePoints(startShapePoints, p.points[0]);
          endShapePoints = this.createCurePoints(endShapePoints, p.points[1]);
        } // 如果是虚线
        else if (this.style.lineType === 'dotted') {
          startShapePoints = this.createDotLine(startShapePoints, p.points[0]);
          endShapePoints = this.createDotLine(endShapePoints, p.points[1]);
        }

        startShapePoints.push(p.points[0]);
        endShapePoints.push(p.points[1]); // 生成标点的回调

        this.emit('onPointCreated', p);
      } // 如果所有都已经结束，则重置成初始化状态


      if (this.___animateCounter >= len - 1) {
        this.___animateCounter = 0;
      } else if (isRunningAni) {
        this.___animateCounter += aniStep; // next tick 再次刷新

        setTimeout(() => {
          this.needUpdate = true; //需要刷新
        });
      }

      if (endShapePoints.length) endShapePoints[0].m = true; // 第二条线重新开始画

      this.points = startShapePoints.concat(endShapePoints); // 仓建区域效果  这里的endShapePoints要倒过来画，才能形成一个封闭区域

      const areaPoints = startShapePoints.concat(endShapePoints.reverse());
      const areaEnd = areaPoints[areaPoints.length - 1] = this.graph.utils.clone(areaPoints[areaPoints.length - 1]);
      areaEnd.m = false;
      this.createArea(areaPoints, false);
    }
    /**
     * 生成图例
     *
     * @method createLegend	 
     */


    createLegend() {
      //生成图例前的图标
      var style = this.graph.utils.clone(this.style);
      style.stroke = style.color;
      var shape = this.graph.createShape('path', {
        style: style
      });

      if (this.curve || this.style.curve) {
        var p1 = {
          x: 0,
          y: this.graph.style.legend.item.shape.height
        };
        var p2 = {
          x: this.graph.style.legend.item.shape.width / 3,
          y: this.graph.style.legend.item.shape.height / 3
        };
        var p3 = {
          x: this.graph.style.legend.item.shape.width / 3 * 2,
          y: this.graph.style.legend.item.shape.height / 3 * 2
        };
        var p4 = {
          x: this.graph.style.legend.item.shape.width,
          y: 0
        };
        this.__bezier = this.__bezier || this.graph.createShape('bezier');
        this.__bezier.cpoints = [p1, p2, p3, p4]; //设置控制点		

        shape.points = this.__bezier.initPoints();
      } else {
        shape.points = [{
          x: 0,
          y: this.graph.style.legend.item.shape.height / 2
        }, {
          x: this.graph.style.legend.item.shape.width,
          y: this.graph.style.legend.item.shape.height / 2
        }];
      }

      this.graph.legend.append(this, shape);
    }

  }

  /**
   * K线图
   *
   * @class jmCandlestickSeries
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {array} mappings 图形字段映射
   * @param {style} style 样式
   */
  //构造函数

  class jmCandlestickSeries extends jmSeries {
    constructor(chart, options) {
      options.style = options.style || options.graph.style.line;
      super(chart, options); //this.on('beginDraw', this[PreDrawKey]);
    }
    /**
     * 绘制图形前 初始化线条
     *
     * @method preDraw
     * @for jmLineSeries
     */


    init() {
      //生成描点位
      const {
        points
      } = this.initDataPoint(); //去除多余的线条
      //当数据源线条数比现有的少时，删除多余的线条

      const len = points.length;
      this.initWidth(len);
      const w = this.barWidth / 2; //实心处宽度的一半

      for (let i = 0; i < len; i++) {
        const p = points[i]; //如果当前点无效，则跳致下一点

        if (typeof p.y === 'undefined' || p.y === null) {
          //prePoint = null;						
          continue;
        }

        const sp = this.addShape(this.graph.createPath([], p.style));
        const bl = {
          x: p.x - w,
          y: p.points[0].y
        };
        const br = {
          x: p.x + w,
          y: p.points[0].y
        };
        const tl = {
          x: p.x - w,
          y: p.points[1].y
        };
        const tr = {
          x: p.x + w,
          y: p.points[1].y
        }; // 默认认为是阳线

        let tm = p.points[1];
        let bm = p.points[0];
        p.style.stroke = p.style.fill = p.style.masculineColor || 'red'; // 开盘大于收盘，则阴线

        if (p.points[0].yValue > p.points[1].yValue) {
          p.style.stroke = p.style.fill = p.style.negativeColor || 'green';
          bl.y = br.y = p.points[1].y;
          tl.y = tr.y = p.points[0].y;
          tm = p.points[0];
          bm = p.points[1];
        }

        sp.points.push(p.points[2], tm, tl, bl, bm, p.points[3], bm, br, tr, tm, p.points[2]); // 生成关健值标注

        this.emit('onPointCreated', p);
      }
    } // 计算实心体宽度


    initWidth(count) {
      //计算每个柱子占宽
      //每项柱子占宽除以柱子个数,默认最大宽度为30
      const maxWidth = this.xAxis.width / count;

      if (this.style.barWidth > 0) {
        this.barWidth = Number(this.style.barWidth);
      } else {
        this.barWidth = maxWidth * (this.style.perWidth || 0.4);
      }

      if (this.barWidth > maxWidth) {
        this.barWidth = maxWidth;
        this.barTotalWidth = maxWidth * count;
      }
    }

  }

  /**
   * 轴
   *
   * @class jmAxis
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {string} [type] 轴类型(x/y/radar),默认为x
   * @param {string} [dataType] 当前轴的数据类型(number/date/string),默认为 number
   * @param {object} [style] 样式
   */
  class jmMarkLine extends jmLine {
    constructor(options) {
      super(options);
      this.visible = false;
      this.markLineType = options.type || 'x'; // 为横轴x或纵轴y  

      /**
      * 当前图形下的所有子图
      */

      this.shapes = new jmList();
    } // 初始化轴


    init() {
      if (!this.visible) return; // 纵标线，中间标小圆圈

      if (this.markLineType === 'y') {
        // 重置所有图形
        let shape;

        while (shape = this.shapes.shift()) {
          shape && shape.remove();
        }

        this.changeTouchPoint();
      }
    } // 滑动点改变事件


    changeTouchPoint() {
      // 纵标线，中间标小圆圈
      if (this.markLineType === 'y') {
        const touchPoints = []; // 命中的数据点

        let touchChange = false; // chartGraph 表示图表层，有可能当前graph为操作层

        const graph = this.graph.chartGraph || this.graph;
        const isTocuhGraph = graph !== this.graph; // 不在图表图层，在操作图层的情况

        try {
          // 查找最近的X坐标
          const findX = isTocuhGraph ? this.start.x - graph.chartArea.position.x : this.start.x; // 根据线条数生成标点个数

          for (const serie of graph.series) {
            // 得有数据描点的才展示圆
            if (!serie.getDataPointByX) continue;
            const point = serie.getDataPointByX(findX); // 找到最近的数据点

            if (!point) continue; // 锁定在有数据点的X轴上
            // 如果在操作图层上， 点的X轴需要加上图表图层区域偏移量

            this.start.x = this.end.x = isTocuhGraph ? point.x + graph.chartArea.position.x : point.x;

            for (const p of point.points) {
              this.markArc = graph.createShape('circle', {
                style: this.style,
                radius: (this.style.radius || 5) * this.graph.devicePixelRatio
              });
              this.markArc.center.y = p.y;
              this.children.add(this.markArc);
              this.shapes.add(this.markArc);
            } // x轴改变，表示变换了位置


            if (!touchChange && (!serie.lastMarkPoint || serie.lastMarkPoint.x != point.x)) touchChange = true;
            touchPoints.push(point);
            serie.lastMarkPoint = point; // 记下最后一次改变的点
            // 同时改变下X轴标线的位置，它的Y坐标跟随最后一个命中的线点

            if (graph && graph.markLine && graph.markLine.xMarkLine) {
              graph.markLine.xMarkLine.start.y = graph.markLine.xMarkLine.end.y = isTocuhGraph ? point.y + graph.chartArea.position.y : point.y;
            }
          }
        } catch (e) {
          console.error(e);
        } // 触发touch数据点改变事件


        touchChange && setTimeout(() => {
          graph.emit('touchPointChange', {
            points: touchPoints
          });
        }, 10);
      }
    }
    /**
    * 移动标线
    * @param { object } args 移动事件参数
    */


    move(args) {
      // 事件是挂在graph下的，，但此轴是放在chartArea中的。所以事件判断用graph坐标，但是当前位置要相对于chartArea
      if (this.visible && this.markLineType === 'x') {
        // 有操作层的情况下，相对于左上角，否则是chartarea
        if (this.graph.chartGraph) {
          if (args.position.y <= this.graph.chartGraph.chartArea.position.y) {
            this.start.y = this.end.y = this.graph.chartGraph.chartArea.position.y;
          } else if (args.position.y > this.graph.chartGraph.chartArea.height + this.graph.chartGraph.chartArea.position.y) {
            this.start.y = this.end.y = this.graph.chartGraph.chartArea.height + this.graph.chartGraph.chartArea.position.y;
          } else {
            this.start.y = this.end.y = args.position.y;
          }

          this.start.x = this.graph.chartGraph.chartArea.position.x;
          this.end.x = this.start.x + this.graph.chartGraph.chartArea.width;
        } else {
          if (args.position.y <= this.graph.chartArea.position.y) {
            this.start.y = this.end.y = 0;
          } else if (args.position.y > this.graph.chartArea.height + this.graph.chartArea.position.y) {
            this.start.y = this.end.y = this.graph.chartArea.height;
          } else {
            this.start.y = this.end.y = args.position.y - this.graph.chartArea.position.y;
          }

          this.start.x = 0;
          this.end.x = this.graph.chartArea.width;
        }

        this.needUpdate = true;
      }

      if (this.visible && this.markLineType === 'y') {
        // 有操作层的情况下，相对于左上角，否则是chartarea
        if (this.graph.chartGraph) {
          if (args.position.x < this.graph.chartGraph.chartArea.position.x) {
            this.start.x = this.end.x = this.graph.chartGraph.chartArea.position.x;
          } else if (args.position.x > this.graph.chartGraph.chartArea.width + this.graph.chartGraph.chartArea.position.x) {
            this.start.x = this.end.x = this.graph.chartGraph.chartArea.width + this.graph.chartGraph.chartArea.position.x;
          } else {
            this.start.x = this.end.x = args.position.x;
          }

          this.start.y = this.graph.chartGraph.chartArea.position.y;
          this.end.y = this.start.y + this.graph.chartGraph.chartArea.height;
        } else {
          if (args.position.x < this.graph.chartArea.position.x) {
            this.start.x = this.end.x = 0;
          } else if (args.position.x > this.graph.chartArea.width + this.graph.chartArea.position.x) {
            this.start.x = this.end.x = this.graph.chartArea.width;
          } else {
            this.start.x = this.end.x = args.position.x - this.graph.chartArea.position.x;
          }

          this.start.y = 0;
          this.end.y = this.graph.chartArea.height;
        }

        this.needUpdate = true;
      }
    }
    /**
     * 中止
     */


    cancel() {
      this.visible = false;
      this.needUpdate = true;
    }

  }

  /**
   * 轴
   *
   * @class jmMarkLineManager
   * @module jmChart
   * @param {jmChart} chart 当前图表
   * @param {string} [type] 轴类型(x/y/radar),默认为x
   * @param {string} [dataType] 当前轴的数据类型(number/date/string),默认为 number
   * @param {object} [style] 样式
   */

  class jmMarkLineManager {
    constructor(chart) {
      this.chart = chart;
      this.init(chart);
    } // 初始化


    init(chart) {
      const graph = chart.touchGraph || chart;
      graph.on('beginDraw', () => {
        // 重置标线，会处理小圆圈问题
        this.xMarkLine && this.xMarkLine.init();
        this.yMarkLine && this.yMarkLine.init();
      });

      if (chart.style.markLine) {
        // 生成标线，可以跟随鼠标或手指滑动
        if (chart.style.markLine && chart.style.markLine.x) {
          this.xMarkLine = graph.createShape(jmMarkLine, {
            type: 'x',
            style: chart.style.markLine
          });
          const area = graph.chartArea || graph;
          area.children.add(this.xMarkLine);
        }

        if (chart.style.markLine && chart.style.markLine.y) {
          this.yMarkLine = graph.createShape(jmMarkLine, {
            type: 'y',
            style: chart.style.markLine
          });
          const area = graph.chartArea || graph;
          area.children.add(this.yMarkLine);
        }

        let longtap = 0; // 是否有长按, 0 未开始，1已按下，2识别为长按

        let longtapHandler = 0;
        let touchStartPos = {
          x: 0,
          y: 0
        };
        graph.on('mousedown touchstart', args => {
          // 如果长按才启用
          if (chart.style.markLine.longtap) {
            longtap = 1;
            longtapHandler && graph.utils.cancelAnimationFrame(longtapHandler);
            let tapStartTime = Date.now();

            const reqFun = () => {
              const elapsed = Date.now() - tapStartTime;

              if (longtap === 1 || longtap === 2) {
                // 如果还未过一定时间，则继续等待
                if (elapsed < 500) {
                  longtapHandler = graph.utils.requestAnimationFrame(reqFun);
                  return;
                }

                longtap = 2;
                this.startMove(args);
                chart.emit('marklinelongtapstart', args);
              }
            }; // 如果一定时间后还没有取消，则表示长按了


            longtapHandler = graph.utils.requestAnimationFrame(reqFun); //args.event.stopPropagation();

            args.event.preventDefault(); // 阻止默认行为	
          } else {
            this.startMove(args);
          }

          args.longtap = longtap;
          touchStartPos = args.position;
        }); // 移动标线

        graph.on('mousemove touchmove', args => {
          const ox = args.position.x - touchStartPos.x;
          const oy = args.position.y - touchStartPos.y;
          const offpos = Math.sqrt(ox * ox + oy * oy);
          if (longtap === 1 && offpos > 15) longtap = 0; // 如果移动了，则取消长按

          args.longtap = longtap;
          this.move(args);
        }); // 取消移动

        graph.on('mouseup touchend touchcancel touchleave', args => {
          longtap = 0;
          this.endMove(args);
        });
      }
    } // 开始移动标线


    startMove(args, markLineType = 'xy') {
      if (this.xMarkLine && markLineType.includes('x')) {
        this.xMarkLine.visible = true;
        this.xMarkLine.move(args);
      }

      if (this.yMarkLine && markLineType.includes('y')) {
        this.yMarkLine.visible = true;
        this.yMarkLine.move(args);
      }

      if (!args.cancel) this.chart.emit('marklinestartmove', args);
    } // 移动标线


    move(args) {
      let moved = false;

      if (this.xMarkLine && this.xMarkLine.visible) {
        this.xMarkLine.move(args);
        moved = true;
      }

      if (this.yMarkLine && this.yMarkLine.visible) {
        this.yMarkLine.move(args);
        moved = true;
      }

      if (moved) {
        args.event.stopPropagation();
        args.event.preventDefault(); // 阻止默认行为	

        if (!args.cancel) this.chart.emit('marklinemove', args);
      }
    } // 终止动移


    endMove(args) {
      if (this.xMarkLine && this.xMarkLine.visible) {
        this.xMarkLine.cancel(args);
      }

      if (this.yMarkLine && this.yMarkLine.visible) {
        this.yMarkLine.cancel(args);
      }

      if (!args.cancel) this.chart.emit('marklineendmove', args);
    }

  }

  const {
    Scene,
    Sprite
  } = spritejs;
  /**
   * jm图表组件
   *
   * @class jmChart
   * @module jmChart
   * @param {element} container 图表容器
   */

  class jmChart {
    constructor(container, options) {
      _defineProperty(this, "data", []);

      _defineProperty(this, "series", new jmList());

      options = options || {};
      const enableAnimate = !!options.enableAnimate;
      options.autoRefresh = typeof options.autoRefresh === 'undefined' ? enableAnimate : options.autoRefresh;

      if (enableAnimate && !options.autoRefresh) {
        console.warn('开启了动画，却没有开户自动刷新');
      } // 深度复制默认样式，以免被改


      options.style = jmUtils.clone(defaultStyle, options.style, true);
      const opt = {
        container
      };
      if (options.width) opt.width = options.width;
      if (options.height) opt.height = options.height;
      this.scene = new Scene(opt);
      this.enableAnimate = enableAnimate;
      this.data = options.data || []; // x轴绑定的字段名

      this.xField = options.xField || ''; // 基础绘图层，不响应事件

      this.bgLayer = scene.layer({
        handleEvent: false
      }); // 可操控图层，响应事件

      this.fgLayer = scene.layer({
        handleEvent: true
      });
      this.init(options); // 创建操作图层

      this.createTouchGraph(this.scene, options);
    }
    /**
     * 绑定的数据源
     */


    /**
     * 是否启用动画
     */
    get enableAnimate() {
      if (typeof this.option.enableAnimate !== 'undefined') return !!this.option.enableAnimate;else {
        return false;
      }
    }

    set enableAnimate(v) {
      this.option.enableAnimate = v;
    }
    /**
     * Y轴的基线 默认是0
     */


    get baseY() {
      return this.option.baseY;
    }

    set baseY(v) {
      this.option.baseY = v;
    } // 初始化图表


    init(options) {
      /**
       * 绘图区域
       *
       * @property chartArea
       * @type jmControl
       */
      if (!this.chartArea) {
        this.chartArea = this.createShape('rect', {
          style: this.style.chartArea,
          position: {
            x: 0,
            y: 0
          }
        });
        this.children.add(this.chartArea);
      }
      /**
       * 图例
       *
       * @property legend
       * @type jmLegend
       */


      this.legend = this.legend || new jmLegend(this, {
        style: this.style.legend,
        visible: options.legendVisible !== false
      }); // 初始化标线

      this.markLine = new jmMarkLineManager(this);
      /**
       * 图表提示控件
       *
       * @property tooltip
       * @type jmTooltip
       */
      //this.tooltip = this.graph.createShape('tooltip',{style:this.style.tooltip});
      //this.chartArea.children.add(this.tooltip);

      this.createXAxis(); // 生成X轴
    } // 重置整个图表


    reset() {
      // 清空当前图形，重新生成
      let serie;

      while (serie = this.series.shift()) {
        serie.remove();
      } // 轴删除


      if (this.xAxis) {
        this.xAxis.remove();
        delete this.xAxis;
      }

      if (this.yAxises) {
        for (let i in this.yAxises) {
          this.yAxises[i].remove();
        }

        delete this.yAxises;
      }
    }
    /**
     * 获取颜色
     *
     * @method getColor 
     * @param {int} index 颜色索引
     */


    getColor(index) {
      //如果颜色超过最大个数，则重新获取	
      if (index >= this.style.chartColors.length) {
        index = Math.floor((index - 1) / this.style.chartColors.length);
      }

      return this.style.chartColors[index];
    }
    /**
     * 绘制当前图表
     * 先绘制轴等基础信息
     *
     * @method beginDraw 
     */


    beginDraw() {
      //const startTime = Date.now();
      //重置图例
      this.legend && this.legend.init(); //先定位图例等信息，确定画图区域

      this.resetAreaPosition();

      if (this.xAxis) {
        this.xAxis.clear();
      } //计算Y轴位置


      if (this.yAxises) {
        for (let i in this.yAxises) {
          this.yAxises[i].clear();
        }
      } //console.log('beginDraw1', Date.now() - startTime);
      //计算柱形图个数


      this.barSeriesCount = 0; //初始化图序列，并初始化轴值,生成图例项

      this.series.each((i, serie) => {
        //设定边框颜色和数据项图示颜 色
        if (!serie.style.color) serie.style.color = this.getColor(i); //如果排版指定非内缩的方式，但出现了柱图，还是会采用内缩一个刻度的方式

        if (this.style.layout != 'inside') {
          if (serie instanceof jmBarSeries) {
            this.style.layout = 'inside';
          }
        } //对柱图计算,并标记为第几个柱图，用为排列


        if (serie instanceof jmBarSeries) {
          serie.barIndex = this.barSeriesCount;
          this.barSeriesCount++;
        }

        serie.reset();
      }); //console.log('beginDraw2', Date.now() - startTime);
      //重置图例

      this.legend && this.legend.reset(); //计算Y轴位置

      if (this.yAxises) {
        for (var i in this.yAxises) {
          this.yAxises[i].reset();
        }
      } // y 处理完才能处理x


      if (this.xAxis) {
        this.xAxis.reset();
      } //console.log('beginDraw3', Date.now() - startTime);
      //最后再来初始化图形，这个必须在轴初始化完后才能执行


      this.series.each(function (i, serie) {
        serie.init && serie.init();
      }); //console.log('beginDraw4', Date.now() - startTime);
    }
    /**
     * 重新定位区域的位置
     *
     * @method resetAreaPosition
     */


    resetAreaPosition() {
      this.chartArea.position.x = this.style.margin.left || 0;
      this.chartArea.position.y = this.style.margin.top || 0;
      const w = this.width - this.style.margin.right - this.chartArea.x;
      const h = this.height - this.style.margin.bottom - this.chartArea.y;
      this.chartArea.attr({
        width: w,
        height: h
      });
    }
    /**
     * 创建轴
     *
     * @method createAxis
     * @for jmChart
     * @param {string} [type] 轴类型(x/y/radar),默认为x
     * @param {string} [dataType] 当前轴的数据类型(number/date/string),默认为 number
     * @param {object} [style] 样式
     * @return {axis} 轴
     */


    createAxis(options) {
      // 深度组件默认样式
      options.style = options.style ? this.utils.clone(this.style.axis, options.style, true) : this.style.axis;
      const axis = new jmAxis(this, options);
      if (typeof options.visible !== 'undefined') axis.visible = options.visible;
      return axis;
    }
    /**
     * 生成X轴
     *
     * @method createXAxis
     * @param {string} x轴的数据类型(string/number/date)
     * @param {bool} 是否从0开始
     */


    createXAxis(options) {
      if (!this.xAxis) {
        options = Object.assign({
          field: this.xField,
          type: 'x',
          visible: this.style.axis.x === false ? false : true,
          format: this.option.xLabelFormat,
          ...this.option.yAxisOption
        }, options || {});

        if (typeof this.option.minXValue !== 'undefined') {
          options.minXValue = typeof options.minXValue === 'undefined' ? this.option.minXValue : Math.min(this.option.minXValue, options.minXValue);
        }

        if (typeof this.option.maxXValue !== 'undefined') {
          options.maxXValue = typeof options.maxXValue === 'undefined' ? this.option.maxXValue : Math.max(this.option.maxXValue, options.maxXValue);
        }

        this.xAxis = this.createAxis(options);
      }

      return this.xAxis;
    }
    /**
     * 生成Y轴
     *
     * @method createYAxis
     * @param {int} Y轴索引，可以创建多个Y轴
     * @param {string} y轴的数据类型(string/number/date)
     * @param {bool} 是否从0开始
     */


    createYAxis(options) {
      if (!this.yAxises) {
        this.yAxises = {};
      }

      options = Object.assign({
        index: 1,
        type: 'y',
        visible: this.style.axis.y === false ? false : true,
        format: this.option.yLabelFormat,
        zeroBase: this.baseY === 0,
        ...this.option.xAxisOption
      }, options || {});

      if (typeof this.option.minYValue !== 'undefined') {
        options.minYValue = typeof options.minYValue === 'undefined' ? this.option.minYValue : Math.min(this.option.minYValue, options.minYValue);
      }

      if (typeof this.option.maxYValue !== 'undefined') {
        options.maxYValue = typeof options.maxYValue === 'undefined' ? this.option.maxYValue : Math.max(this.option.maxYValue, options.maxYValue);
      }

      var yaxis = this.yAxises[options.index] || (this.yAxises[options.index] = this.createAxis(options));
      return yaxis;
    }
    /**
     * 创建图形
     *
     * @method createSeries
     * @for jmChart
     * @param {string} [type] 图类型，（line/bar/pie/radar）
     * @param {object} [options] 生成图表选项 {xField, yField, index}
     * @return {series} 图形
     */


    createSeries(type, options = {}) {
      if (!this.serieTypes) {
        this.serieTypes = {
          'line': jmLineSeries,
          'bar': jmBarSeries,
          'stackBar': jmStackBarSeries,
          'pie': jmPieSeries,
          'stackLine': jmStackLineSeries,
          'candlestick': jmCandlestickSeries
        };
      } //默认样式为类型对应的样式


      const style = this.style[type] || this.style['line']; // 深度组件默认样式

      options.style = this.utils.clone(style, options.style, true);
      if (typeof type == 'string') type = this.serieTypes[type];
      const serie = new type(this, options);

      if (serie) {
        this.series.add(serie);
      }

      return serie;
    }

  }

  var vchart = {
    props: {
      chartData: Array,
      chartOptions: Object,
      chartSeries: Array,
      width: {
        type: String,
        default: 200
      },
      height: {
        type: String,
        default: 200
      }
    },
    data: function () {
      return {
        //chartData: this.chartData,
        option: this.chartOptions
      };
    },
    // jmChart实例
    chartInstance: null,

    mounted() {
      this.option = Object.assign({
        enableAnimate: false,
        legendPosition: 'top',
        legendVisible: true,
        // 不显示图例    
        width: this.width,
        height: this.height
      }, this.chartOptions);
      this.initChart();
    },

    // DOM更新
    updated() {
      this.initChart();
    },

    // 销毁
    destroyed() {
      this.chartInstance && this.chartInstance.destory();
      this.chartInstance && this.chartInstance.touchGraph && this.chartInstance.touchGraph.destory();
    },

    watch: {
      // 数据发生改变，刷新
      chartData: function (newData, oldData) {
        this.refresh();
      },
      width: function (newWidth, oldWidth) {
        if (!this.chartInstance) return;
        this.$nextTick(() => {
          if (!this.chartInstance || !this.$refs.jmChartContainer) return;
          this.chartInstance.width = this.$refs.jmChartContainer.clientWidth || this.$refs.jmChartContainer.offsetWidth; //this.chartInstance.refresh();
        });
      },
      height: function (newHeight, oldHeight) {
        if (!this.chartInstance) return;
        this.$nextTick(() => {
          if (!this.chartInstance || !this.$refs.jmChartContainer) return;
          this.chartInstance.height = this.$refs.jmChartContainer.clientHeight || this.$refs.jmChartContainer.offsetHeight; //this.chartInstance.refresh();
        });
      }
    },
    methods: {
      // 初始化图表组件
      initChart() {
        if (this.chartInstance) return;
        this.chartInstance = new jmChart(this.$refs.jmChartContainer, this.option);
        if (this.chartData && this.chartData.length) this.refresh(); // 这里有死循环的问题，但上面 chartInstance不为空就返回了，就没有这个问题了
        // touch改变数据点事件

        this.chartInstance.bind('touchPointChange', args => {
          this.$emit('touch-point-change', args);
        }); // touch事件

        this.chartInstance.touchGraph.bind('touchstart mousedown', args => {
          this.$emit('touchstart', args);
          this.$emit('mousedown', args);
        });
        this.chartInstance.touchGraph.bind('touchmove mousemove', args => {
          this.$emit('touchmove', args);
          this.$emit('mousemove', args);
        });
        this.chartInstance.touchGraph.bind('touchend touchcancel mouseup', args => {
          this.$emit('touchend', args);
          this.$emit('mouseup', args);
        });
        this.chartInstance.touchGraph.bind('touchleave', args => {
          this.$emit('touchleave', args);
        });
      },

      // 刷新图表
      refresh() {
        this.$nextTick(() => {
          this.initChart(); // 清空当前图形，重新生成

          this.chartInstance.reset(); // 生成图

          if (this.chartSeries.length) {
            for (let s of this.chartSeries) {
              if (!s.type) {
                console.error('必须指定serie type');
                continue;
              }

              this.chartInstance.createSeries(s.type, s);
            }
          }

          this.chartInstance.data = this.chartData;
          this.chartInstance.refresh();
        });
      }

    },
    template: `<div ref="jmChartContainer" :style="{width: width, height: height}"></div>`
  };

  exports['default'] = jmChart;
  exports.jmChart = jmChart;
  exports.vChart = vchart;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
